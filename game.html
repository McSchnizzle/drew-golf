<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-fullscreen">
  <title>Howlett Golf Chaos</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      user-select: none;
    }

    body {
      width: 100vw;
      height: 100vh;
      overflow: hidden;
      background: #87CEEB;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
      touch-action: none;
    }

    #game-canvas {
      display: block;
      width: 100%;
      height: 100%;
      touch-action: none;
    }

    #ui-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }

    #ui-overlay > * {
      pointer-events: auto;
    }

    #scoreboard {
      position: absolute;
      top: 20px;
      left: 20px;
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.98), rgba(248, 255, 248, 0.95));
      padding: 12px 16px;
      border-radius: 16px;
      font-size: 13px;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.15);
      border: 2px solid rgba(76, 175, 80, 0.3);
      min-width: 140px;
    }

    #scoreboard .score-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding-bottom: 8px;
      margin-bottom: 8px;
      border-bottom: 1px solid rgba(0, 0, 0, 0.1);
    }

    #scoreboard .hole-info {
      font-size: 18px;
      font-weight: bold;
      color: #2E7D32;
    }

    #scoreboard .par-info {
      font-size: 12px;
      color: #666;
      background: rgba(0, 0, 0, 0.05);
      padding: 2px 8px;
      border-radius: 10px;
    }

    .ingame-settings-btn {
      background: rgba(0, 0, 0, 0.1);
      border: none;
      border-radius: 50%;
      width: 28px;
      height: 28px;
      font-size: 14px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background 0.2s;
      margin-left: 8px;
    }

    .ingame-settings-btn:hover {
      background: rgba(0, 0, 0, 0.2);
    }

    #scoreboard .score-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin: 4px 0;
    }

    #scoreboard .score-label {
      color: #666;
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    #scoreboard .score-value {
      font-weight: bold;
      color: #333;
      font-size: 14px;
    }

    #scoreboard .score-value.score-good { color: #4CAF50; }
    #scoreboard .score-value.score-bad { color: #f44336; }

    #scoreboard .club-info {
      margin-top: 8px;
      padding-top: 8px;
      border-top: 1px solid rgba(0, 0, 0, 0.1);
      text-align: center;
    }

    #scoreboard .club-name {
      font-weight: bold;
      color: #1976D2;
      font-size: 14px;
    }

    #scoreboard .distance-info {
      font-size: 11px;
      color: #666;
      margin-top: 2px;
    }

    #ball-state {
      position: absolute;
      top: 20px;
      right: 20px;
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.98), rgba(245, 245, 245, 0.95));
      padding: 8px 16px;
      border-radius: 20px;
      font-size: 14px;
      font-weight: bold;
      box-shadow: 0 3px 10px rgba(0, 0, 0, 0.15);
      border: 2px solid rgba(255, 255, 255, 0.8);
    }

    #wind-indicator {
      position: absolute;
      top: 65px;
      right: 20px;
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.98), rgba(240, 248, 255, 0.95));
      padding: 10px 14px;
      border-radius: 12px;
      box-shadow: 0 3px 10px rgba(0, 0, 0, 0.15);
      text-align: center;
      min-width: 70px;
      border: 2px solid rgba(135, 206, 250, 0.5);
    }

    #wind-indicator .wind-label {
      font-size: 10px;
      color: #666;
      margin-bottom: 2px;
      font-weight: bold;
      letter-spacing: 1px;
    }

    #wind-indicator .wind-arrow {
      font-size: 24px;
      line-height: 1;
      transition: transform 0.3s ease;
    }

    #wind-indicator .wind-speed {
      font-size: 12px;
      font-weight: bold;
      color: #333;
      margin-top: 2px;
    }

    #wind-indicator.wind-calm .wind-arrow { color: #4CAF50; }
    #wind-indicator.wind-light .wind-arrow { color: #8BC34A; }
    #wind-indicator.wind-moderate .wind-arrow { color: #FFC107; }
    #wind-indicator.wind-strong .wind-arrow { color: #FF9800; }
    #wind-indicator.wind-extreme .wind-arrow { color: #f44336; }

    /* Achievement notification popup */
    #achievement-popup {
      position: fixed;
      top: -200px;
      left: 50%;
      transform: translateX(-50%);
      background: linear-gradient(135deg, #FFD700, #FFA500);
      padding: 15px 30px;
      border-radius: 12px;
      box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
      z-index: 2000;
      transition: top 0.5s ease-out, visibility 0s 0.5s;
      text-align: center;
      min-width: 250px;
      visibility: hidden;
    }

    #achievement-popup.show {
      top: 20px;
      visibility: visible;
      transition: top 0.5s ease-out, visibility 0s 0s;
    }

    #achievement-popup .achievement-icon {
      font-size: 40px;
      margin-bottom: 5px;
    }

    #achievement-popup .achievement-title {
      font-size: 14px;
      color: #333;
      font-weight: bold;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    #achievement-popup .achievement-name {
      font-size: 20px;
      font-weight: bold;
      color: #000;
      margin: 5px 0;
    }

    #achievement-popup .achievement-desc {
      font-size: 12px;
      color: #555;
    }

    /* Golf Bucks earnings popup */
    .golf-bucks-popup {
      position: fixed;
      top: 80px;
      right: -200px;
      background: linear-gradient(135deg, #4CAF50, #2E7D32);
      color: white;
      padding: 12px 20px;
      border-radius: 8px;
      font-weight: bold;
      font-size: 18px;
      z-index: 2001;
      transition: right 0.4s ease-out;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    }
    .golf-bucks-popup.show {
      right: 20px;
    }
    .golf-bucks-popup small {
      font-size: 12px;
      font-weight: normal;
      opacity: 0.9;
    }

    /* Upgrade popup */
    .upgrade-popup {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) scale(0.8);
      background: linear-gradient(135deg, #FFD700, #FF8F00);
      color: #1a1a1a;
      padding: 20px 35px;
      border-radius: 15px;
      font-size: 18px;
      z-index: 2002;
      opacity: 0;
      transition: all 0.3s ease-out;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.4), 0 0 30px rgba(255, 215, 0, 0.5);
      text-align: center;
    }
    .upgrade-popup.show {
      opacity: 1;
      transform: translate(-50%, -50%) scale(1);
    }
    .upgrade-popup span {
      font-size: 24px;
      margin-right: 8px;
    }
    .upgrade-popup strong {
      color: #1B5E20;
    }

    /* Shop overlay */
    #shop-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.9);
      z-index: 1500;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 20px;
      box-sizing: border-box;
    }
    #shop-overlay.hidden {
      display: none;
    }

    #shop-modal {
      background: linear-gradient(180deg, #1a472a 0%, #0d2818 100%);
      border: 3px solid #4CAF50;
      border-radius: 20px;
      padding: 0;
      max-width: 600px;
      width: 100%;
      max-height: 90vh;
      overflow: hidden;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5), 0 0 30px rgba(76, 175, 80, 0.3);
    }

    #shop-header {
      background: linear-gradient(135deg, #2E7D32, #1B5E20);
      padding: 20px 25px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 2px solid rgba(255, 255, 255, 0.1);
    }
    #shop-header h2 {
      margin: 0;
      color: #fff;
      font-size: 26px;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    #shop-balance-display {
      background: linear-gradient(135deg, #FFD700, #FFA000);
      padding: 10px 18px;
      border-radius: 25px;
      color: #1a1a1a;
      font-weight: bold;
      font-size: 18px;
      box-shadow: 0 4px 15px rgba(255, 215, 0, 0.4);
    }

    #shop-content {
      padding: 20px 25px;
      max-height: calc(90vh - 180px);
      overflow-y: auto;
    }

    /* Info section */
    #shop-info {
      background: rgba(255, 255, 255, 0.08);
      border-radius: 12px;
      padding: 15px;
      margin-bottom: 20px;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }
    #shop-info h3 {
      color: #FFD700;
      margin: 0 0 10px 0;
      font-size: 16px;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    #shop-info p {
      color: rgba(255, 255, 255, 0.8);
      margin: 0 0 8px 0;
      font-size: 13px;
      line-height: 1.5;
    }
    #shop-info .earn-list {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 6px;
      margin-top: 10px;
    }
    #shop-info .earn-item {
      background: rgba(76, 175, 80, 0.2);
      padding: 6px 10px;
      border-radius: 6px;
      font-size: 11px;
      color: #81C784;
      display: flex;
      justify-content: space-between;
    }
    #shop-info .earn-item span:last-child {
      color: #FFD700;
      font-weight: bold;
    }

    /* Tier legend */
    #shop-tier-legend {
      display: flex;
      justify-content: center;
      gap: 20px;
      margin-bottom: 15px;
      padding: 10px;
      background: rgba(0, 0, 0, 0.2);
      border-radius: 10px;
    }
    .tier-item {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 12px;
      color: rgba(255, 255, 255, 0.7);
    }
    .tier-item .tier-stars {
      color: #FFD700;
    }
    .tier-item.basic { color: #888; }
    .tier-item.standard { color: #90CAF9; }
    .tier-item.pro { color: #FFD700; }

    #shop-clubs-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
      gap: 10px;
      margin-bottom: 15px;
    }

    .shop-club-card {
      background: rgba(255, 255, 255, 0.05);
      border: 2px solid rgba(255, 255, 255, 0.15);
      border-radius: 12px;
      padding: 12px 8px;
      text-align: center;
      transition: all 0.2s ease;
      cursor: pointer;
    }
    .shop-club-card:hover {
      transform: translateY(-4px);
      border-color: #4CAF50;
      background: rgba(76, 175, 80, 0.15);
      box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
    }
    .shop-club-card.maxed {
      border-color: #FFD700;
      background: linear-gradient(135deg, rgba(255, 215, 0, 0.15), rgba(255, 160, 0, 0.1));
    }
    .shop-club-card.maxed:hover {
      border-color: #FFD700;
      box-shadow: 0 8px 20px rgba(255, 215, 0, 0.2);
    }

    .shop-club-icon {
      width: 42px;
      height: 42px;
      background: linear-gradient(135deg, #555, #333);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      margin: 0 auto 6px;
      font-weight: bold;
      font-size: 14px;
      color: white;
      border: 2px solid rgba(255, 255, 255, 0.2);
    }
    .shop-club-card.tier-2 .shop-club-icon {
      background: linear-gradient(135deg, #42A5F5, #1976D2);
      border-color: #64B5F6;
    }
    .shop-club-card.maxed .shop-club-icon {
      background: linear-gradient(135deg, #FFD700, #FF8F00);
      color: #1a1a1a;
      border-color: #FFE082;
    }

    .shop-club-name {
      color: #fff;
      font-size: 11px;
      font-weight: bold;
      margin-bottom: 3px;
    }

    .shop-club-tier {
      color: #FFD700;
      font-size: 12px;
      margin-bottom: 3px;
      letter-spacing: 1px;
    }

    .shop-club-distance {
      color: rgba(255, 255, 255, 0.5);
      font-size: 10px;
      margin-bottom: 5px;
    }

    .shop-club-price {
      color: #81C784;
      font-size: 11px;
      font-weight: bold;
      margin-bottom: 6px;
    }
    .shop-club-card.maxed .shop-club-price {
      color: #FFD700;
      font-size: 10px;
    }

    .shop-buy-btn {
      background: linear-gradient(135deg, #4CAF50, #2E7D32);
      border: none;
      color: white;
      padding: 6px 12px;
      border-radius: 12px;
      font-size: 10px;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.2s;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    .shop-buy-btn:hover:not(.disabled) {
      transform: scale(1.08);
      box-shadow: 0 4px 12px rgba(76, 175, 80, 0.4);
    }
    .shop-buy-btn.disabled {
      background: linear-gradient(135deg, #555, #333);
      cursor: not-allowed;
      opacity: 0.7;
    }

    .shop-club-card.just-upgraded {
      animation: card-upgrade 0.6s ease-out;
    }
    @keyframes card-upgrade {
      0% { transform: scale(1); }
      30% { transform: scale(1.15); box-shadow: 0 0 30px rgba(255, 215, 0, 0.8); }
      100% { transform: scale(1); }
    }

    #shop-footer {
      padding: 15px 25px 20px;
      background: rgba(0, 0, 0, 0.2);
      border-top: 1px solid rgba(255, 255, 255, 0.1);
    }

    #shop-close-btn {
      display: block;
      width: 100%;
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.15), rgba(255, 255, 255, 0.05));
      border: 2px solid rgba(255, 255, 255, 0.2);
      color: white;
      padding: 12px 30px;
      border-radius: 25px;
      font-size: 16px;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.2s;
    }
    #shop-close-btn:hover {
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.25), rgba(255, 255, 255, 0.1));
      transform: scale(1.02);
    }

    /* Ball skins section */
    #shop-balls-section {
      margin-top: 20px;
      padding-top: 15px;
      border-top: 1px solid rgba(255, 255, 255, 0.1);
    }
    .shop-section-title {
      color: #fff;
      font-size: 16px;
      margin-bottom: 12px;
      text-align: center;
    }
    #shop-balls-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(75px, 1fr));
      gap: 10px;
      margin-bottom: 15px;
    }
    .shop-ball-card {
      background: rgba(255, 255, 255, 0.05);
      border: 2px solid rgba(255, 255, 255, 0.15);
      border-radius: 12px;
      padding: 10px 6px;
      text-align: center;
      transition: all 0.2s ease;
      cursor: pointer;
    }
    .shop-ball-card:hover {
      transform: translateY(-4px);
      border-color: #4CAF50;
      background: rgba(76, 175, 80, 0.15);
    }
    .shop-ball-card.owned {
      border-color: #4CAF50;
      background: rgba(76, 175, 80, 0.1);
    }
    .shop-ball-card.animated {
      border-color: #9B59B6;
    }
    .shop-ball-card.animated:hover {
      border-color: #E91E63;
      box-shadow: 0 0 15px rgba(233, 30, 99, 0.3);
    }
    .shop-ball-preview {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      margin: 0 auto 8px;
      box-shadow: inset -3px -3px 6px rgba(0, 0, 0, 0.3), 0 2px 4px rgba(0, 0, 0, 0.3);
      position: relative;
    }
    .shop-ball-preview::after {
      content: '';
      position: absolute;
      top: 4px;
      left: 8px;
      width: 12px;
      height: 8px;
      background: radial-gradient(ellipse at center, rgba(255,255,255,0.7) 0%, rgba(255,255,255,0) 70%);
      border-radius: 50%;
    }
    .animated-indicator {
      position: absolute;
      bottom: -4px;
      right: -4px;
      font-size: 12px;
    }
    .shop-ball-name {
      color: #fff;
      font-size: 10px;
      font-weight: bold;
      margin-bottom: 3px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .shop-ball-price {
      color: #81C784;
      font-size: 10px;
      font-weight: bold;
      margin-bottom: 5px;
    }
    .shop-ball-card.owned .shop-ball-price {
      color: #4CAF50;
    }
    .shop-ball-card .shop-buy-btn {
      font-size: 10px;
      padding: 4px 8px;
    }

    /* Menu balance display */
    #menu-balance {
      position: absolute;
      top: 15px;
      right: 15px;
      background: linear-gradient(135deg, #FFD700, #FFA000);
      padding: 8px 16px;
      border-radius: 20px;
      color: #1a1a1a;
      font-weight: bold;
      font-size: 14px;
      z-index: 10;
      box-shadow: 0 4px 12px rgba(255, 215, 0, 0.3);
      cursor: pointer;
    }
    #menu-balance:hover {
      transform: scale(1.05);
    }

    #distance-display {
      position: absolute;
      bottom: 20px;
      right: 20px;
      background: rgba(255, 255, 255, 0.95);
      padding: 15px 25px;
      border-radius: 12px;
      font-size: 24px;
      font-weight: bold;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      color: #2196F3;
    }

    #distance-display .label {
      font-size: 12px;
      color: #666;
      font-weight: normal;
      display: block;
      margin-bottom: 5px;
    }

    #club-selector-container {
      position: absolute;
      bottom: 15px;
      left: 50%;
      transform: translateX(-50%);
      display: none;
    }

    #club-selector {
      display: flex;
      align-items: flex-end;
      justify-content: center;
      gap: 4px;
      padding: 15px 20px 10px 20px;
      background: linear-gradient(to bottom, #8B4513 0%, #654321 50%, #3d2817 100%);
      border-radius: 20px 20px 8px 8px;
      box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4), inset 0 2px 4px rgba(255,255,255,0.1);
      border: 3px solid #2d1810;
      position: relative;
    }

    #club-selector::before {
      content: '';
      position: absolute;
      top: 5px;
      left: 15px;
      right: 15px;
      height: 4px;
      background: linear-gradient(to right, transparent, rgba(255,215,0,0.3), transparent);
      border-radius: 2px;
    }

    #club-selector.minimized {
      display: none;
    }

    .club-slot {
      display: flex;
      flex-direction: column;
      align-items: center;
      cursor: pointer;
      transition: transform 0.15s ease;
      padding: 5px;
      border-radius: 8px;
    }

    .club-slot:hover {
      transform: translateY(-5px);
    }

    .club-slot.selected {
      transform: translateY(-12px);
    }

    .club-slot.selected .club-head {
      box-shadow: 0 0 15px rgba(255, 215, 0, 0.8), 0 4px 8px rgba(0,0,0,0.3);
    }

    .club-shaft {
      width: 4px;
      height: 35px;
      background: linear-gradient(to right, #888, #ccc, #888);
      border-radius: 2px;
      box-shadow: 1px 0 2px rgba(0,0,0,0.3);
    }

    .club-head {
      width: 44px;
      height: 44px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      font-size: 11px;
      color: white;
      text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
      box-shadow: 0 3px 6px rgba(0,0,0,0.3);
      border: 2px solid rgba(255,255,255,0.3);
      transition: box-shadow 0.15s ease;
    }

    .club-head.driver {
      background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
    }

    .club-head.wood {
      background: linear-gradient(135deg, #e67e22 0%, #d35400 100%);
    }

    .club-head.iron {
      background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
    }

    .club-head.wedge {
      background: linear-gradient(135deg, #f1c40f 0%, #f39c12 100%);
      color: #333;
      text-shadow: none;
    }

    .club-head.putter {
      background: linear-gradient(135deg, #2ecc71 0%, #27ae60 100%);
    }

    .club-distance {
      font-size: 9px;
      color: rgba(255,255,255,0.8);
      margin-top: 3px;
      text-align: center;
      text-shadow: 1px 1px 1px rgba(0,0,0,0.5);
    }

    /* Recommended club - green pulsing outline */
    .club-slot.recommended .club-head {
      outline: 3px solid #4CAF50;
      outline-offset: 2px;
      animation: rec-outline-pulse 1.2s ease-in-out infinite;
    }
    @keyframes rec-outline-pulse {
      0%, 100% { outline-color: #4CAF50; outline-offset: 2px; }
      50% { outline-color: #81C784; outline-offset: 4px; }
    }

    /* Tier-based club styling */
    .club-slot {
      position: relative;
    }

    /* Tier 1 - Basic: gray color */
    .club-slot.tier-1 .club-head {
      border-color: rgba(255, 255, 255, 0.2);
      background: linear-gradient(135deg, #6b6b6b 0%, #4a4a4a 50%, #3a3a3a 100%) !important;
    }
    .club-slot.tier-1 .club-shaft {
      background: linear-gradient(to right, #5a5a5a, #888, #5a5a5a);
    }

    /* Tier 2 - Standard: blue glow with pulsing animation */
    .club-slot.tier-2 .club-head {
      border: 3px solid #64B5F6;
      animation: tier2-pulse 2s ease-in-out infinite;
      background: linear-gradient(135deg, #5a9fd4 0%, #3a7cb8 50%, #2a5c8a 100%) !important;
    }
    @keyframes tier2-pulse {
      0%, 100% { box-shadow: 0 0 10px rgba(100, 181, 246, 0.6), 0 0 20px rgba(100, 181, 246, 0.3), 0 3px 6px rgba(0,0,0,0.3); }
      50% { box-shadow: 0 0 15px rgba(100, 181, 246, 0.9), 0 0 30px rgba(100, 181, 246, 0.5), 0 3px 6px rgba(0,0,0,0.3); }
    }
    .club-slot.tier-2 .club-distance {
      color: #90CAF9;
      font-weight: bold;
    }
    .club-slot.tier-2::after {
      content: '★';
      position: absolute;
      top: -8px;
      right: -8px;
      font-size: 14px;
      color: #fff;
      background: linear-gradient(135deg, #64B5F6, #1976D2);
      border-radius: 50%;
      width: 22px;
      height: 22px;
      line-height: 22px;
      text-align: center;
      text-shadow: 0 1px 2px rgba(0,0,0,0.5);
      box-shadow: 0 2px 4px rgba(0,0,0,0.3);
      border: 2px solid #fff;
    }
    .club-slot.tier-2 .club-shaft {
      background: linear-gradient(to right, #5a8bc7, #8ab8e8, #5a8bc7);
    }

    /* Tier 3 - Pro: gold glow with intense pulsing + sparkle */
    .club-slot.tier-3 .club-head {
      border: 3px solid #FFD700;
      animation: tier3-pulse 1.5s ease-in-out infinite;
      background: linear-gradient(135deg, #e6b800 0%, #cc9900 50%, #a67c00 100%) !important;
    }
    @keyframes tier3-pulse {
      0%, 100% { box-shadow: 0 0 15px rgba(255, 215, 0, 0.7), 0 0 30px rgba(255, 165, 0, 0.4), 0 3px 6px rgba(0,0,0,0.3); }
      50% { box-shadow: 0 0 25px rgba(255, 215, 0, 1), 0 0 45px rgba(255, 165, 0, 0.6), 0 3px 6px rgba(0,0,0,0.3); }
    }
    .club-slot.tier-3 .club-distance {
      color: #FFD700;
      font-weight: bold;
      text-shadow: 0 0 4px rgba(255, 215, 0, 0.5);
    }
    .club-slot.tier-3::after {
      content: '★★';
      position: absolute;
      top: -10px;
      right: -10px;
      font-size: 12px;
      letter-spacing: -3px;
      color: #fff;
      background: linear-gradient(135deg, #FFD700, #FFA500, #FF8C00);
      border-radius: 50%;
      width: 28px;
      height: 28px;
      line-height: 28px;
      text-align: center;
      text-shadow: 0 1px 2px rgba(0,0,0,0.5);
      box-shadow: 0 0 8px rgba(255, 215, 0, 0.6), 0 2px 4px rgba(0,0,0,0.3);
      border: 2px solid #fff;
      animation: tier3-badge-pulse 1.5s ease-in-out infinite;
    }
    @keyframes tier3-badge-pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.1); }
    }
    .club-slot.tier-3 .club-shaft {
      background: linear-gradient(to right, #B8860B, #FFD700, #B8860B);
    }

    #club-toggle-btn {
      background: linear-gradient(to bottom, #5a3d2b, #3d2817);
      border: 2px solid #2d1810;
      border-radius: 8px;
      padding: 8px 20px;
      font-size: 14px;
      font-weight: bold;
      color: #f4e4bc;
      cursor: pointer;
      box-shadow: 0 3px 6px rgba(0, 0, 0, 0.3);
      margin-top: 8px;
      width: 100%;
      text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
    }

    #club-toggle-btn:active {
      background: linear-gradient(to bottom, #4a3020, #2d1810);
    }

    .button {
      padding: 12px 24px;
      margin: 5px;
      background: #4CAF50;
      color: white;
      border: none;
      border-radius: 8px;
      font-size: 16px;
      cursor: pointer;
      font-weight: 600;
      transition: background 0.2s;
    }

    .button:active {
      background: #45a049;
    }

    .button.selected {
      background: #2196F3;
    }

    #debug-info {
      position: absolute;
      top: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 10px;
      border-radius: 8px;
      font-size: 14px;
      font-family: monospace;
    }

    #menu-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      /* Golf course background image */
      background: url('menu-background.png') center center / cover no-repeat;
      display: flex;
      justify-content: center;
      align-items: center;
      flex-direction: column;
    }

    /* Slight darkening overlay for better text readability */
    #menu-overlay::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.15);
      pointer-events: none;
    }

    #menu-overlay h1 {
      color: white;
      font-size: 48px;
      margin-bottom: 40px;
      text-shadow: 2px 2px 8px rgba(0,0,0,0.5);
    }

    .menu-button {
      padding: 18px 52px;
      margin: 10px;
      background: linear-gradient(to bottom, #4CAF50, #3d8b40);
      color: white;
      border: 3px solid #2d6b30;
      border-radius: 12px;
      font-size: 26px;
      cursor: pointer;
      font-weight: 800;
      transition: all 0.2s;
      box-shadow: 0 4px 12px rgba(0,0,0,0.4), inset 0 1px 0 rgba(255,255,255,0.3);
      text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
    }

    .menu-button:active {
      background: linear-gradient(to bottom, #3d8b40, #2d6b30);
      transform: translateY(2px);
      box-shadow: 0 2px 6px rgba(0,0,0,0.4);
    }

    .hidden {
      display: none !important;
    }

    #scorecard-overlay {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(255, 255, 255, 0.98);
      padding: 30px;
      border-radius: 16px;
      box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
      max-width: 500px;
      max-height: 80vh;
      overflow-y: auto;
    }

    #scorecard-overlay h2 {
      margin-bottom: 20px;
      color: #333;
    }

    .scorecard-table {
      width: 100%;
      border-collapse: collapse;
      margin: 20px 0;
    }

    .scorecard-table th, .scorecard-table td {
      padding: 10px;
      text-align: center;
      border-bottom: 1px solid #ddd;
    }

    .scorecard-table th {
      background: #f5f5f5;
      font-weight: bold;
    }

    .score-birdie { color: #4CAF50; font-weight: bold; }
    .score-eagle { color: #FFD700; font-weight: bold; }
    .score-par { color: #2196F3; }
    .score-bogey { color: #FF9800; }
    .score-double { color: #F44336; }

    #round-progress {
      position: absolute;
      bottom: 80px;
      left: 20px;
      background: rgba(255, 255, 255, 0.95);
      padding: 10px 15px;
      border-radius: 8px;
      font-size: 14px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    }

    #reset-shot-btn {
      position: absolute;
      bottom: 100px;
      right: 20px;
      padding: 8px 16px;
      background: rgba(244, 67, 54, 0.9);
      color: white;
      border: none;
      border-radius: 8px;
      font-size: 14px;
      font-weight: bold;
      cursor: pointer;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
      z-index: 1000;
      transition: background 0.2s;
    }

    #reset-shot-btn:active {
      background: rgba(211, 47, 47, 0.95);
    }

    .club-power-info {
      font-size: 12px;
      color: #666;
      margin-top: 2px;
    }

    /* === Leaderboard Styles (T077) === */
    #leaderboard-overlay {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(255, 255, 255, 0.98);
      padding: 30px;
      border-radius: 16px;
      box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
      max-width: 600px;
      max-height: 80vh;
      overflow-y: auto;
      z-index: 1000;
    }

    #leaderboard-overlay h2 {
      margin-bottom: 20px;
      color: #333;
      text-align: center;
    }

    .leaderboard-table {
      width: 100%;
      border-collapse: collapse;
      margin: 20px 0;
    }

    .leaderboard-table th,
    .leaderboard-table td {
      padding: 12px;
      text-align: center;
      border-bottom: 1px solid #ddd;
    }

    .leaderboard-table th {
      background: #f5f5f5;
      font-weight: bold;
      position: sticky;
      top: 0;
    }

    .leaderboard-table tr:hover {
      background: #f9f9f9;
    }

    .leaderboard-rank {
      font-weight: bold;
      color: #666;
    }

    .leaderboard-rank-1 { color: #FFD700; }
    .leaderboard-rank-2 { color: #C0C0C0; }
    .leaderboard-rank-3 { color: #CD7F32; }

    .leaderboard-score-under { color: #4CAF50; font-weight: bold; }
    .leaderboard-score-par { color: #2196F3; }
    .leaderboard-score-over { color: #F44336; }

    .leaderboard-empty {
      text-align: center;
      padding: 40px 20px;
      color: #999;
      font-style: italic;
    }

    .new-best-indicator {
      background: #FFD700;
      color: #333;
      padding: 10px 20px;
      border-radius: 8px;
      margin-bottom: 20px;
      text-align: center;
      font-weight: bold;
      animation: pulse 1s ease-in-out;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }

    /* === Menu Bottom Buttons (Settings/Achievements) === */
    .menu-bottom-buttons {
      position: absolute;
      bottom: 20px;
      right: 20px;
      display: flex;
      gap: 10px;
    }

    .menu-icon-btn {
      width: 50px;
      height: 50px;
      border-radius: 50%;
      border: 3px solid rgba(255, 255, 255, 0.4);
      background: rgba(0, 0, 0, 0.3);
      color: white;
      font-size: 24px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
    }

    .menu-icon-btn:hover {
      background: rgba(0, 0, 0, 0.5);
      transform: scale(1.1);
    }

    /* Music prompt button */
    #music-prompt-btn {
      position: absolute;
      bottom: 20px;
      left: 20px;
      padding: 12px 20px;
      background: linear-gradient(135deg, #9C27B0, #7B1FA2);
      border: 3px solid rgba(255, 255, 255, 0.4);
      border-radius: 25px;
      color: white;
      font-size: 16px;
      font-weight: bold;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 8px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      transition: all 0.2s;
      animation: musicPulse 2s ease-in-out infinite;
    }

    #music-prompt-btn:hover {
      transform: scale(1.05);
      box-shadow: 0 6px 16px rgba(0, 0, 0, 0.4);
    }

    #music-prompt-btn.playing {
      background: linear-gradient(135deg, #4CAF50, #388E3C);
      animation: none;
    }

    @keyframes musicPulse {
      0%, 100% { box-shadow: 0 4px 12px rgba(156, 39, 176, 0.4); }
      50% { box-shadow: 0 4px 20px rgba(156, 39, 176, 0.7); }
    }

    .menu-icon-btn:active {
      transform: scale(0.95);
    }

    /* === Settings Overlay === */
    #settings-overlay {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: linear-gradient(145deg, #ffffff 0%, #f5f5f5 100%);
      padding: 30px;
      border-radius: 20px;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.4);
      max-width: 400px;
      width: 90%;
      z-index: 1001;
    }

    #settings-overlay h2 {
      margin: 0 0 25px 0;
      color: #333;
      text-align: center;
      font-size: 28px;
    }

    .settings-group {
      margin-bottom: 20px;
    }

    .settings-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 0;
      border-bottom: 1px solid #eee;
    }

    .settings-row:last-child {
      border-bottom: none;
    }

    .settings-label {
      font-size: 16px;
      color: #333;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .settings-label .icon {
      font-size: 20px;
    }

    /* Toggle switch */
    .toggle-switch {
      position: relative;
      width: 52px;
      height: 28px;
    }

    .toggle-switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }

    .toggle-slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: #ccc;
      transition: 0.3s;
      border-radius: 28px;
    }

    .toggle-slider:before {
      position: absolute;
      content: "";
      height: 22px;
      width: 22px;
      left: 3px;
      bottom: 3px;
      background-color: white;
      transition: 0.3s;
      border-radius: 50%;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }

    .toggle-switch input:checked + .toggle-slider {
      background-color: #4CAF50;
    }

    .toggle-switch input:checked + .toggle-slider:before {
      transform: translateX(24px);
    }

    .settings-buttons {
      display: flex;
      justify-content: center;
      margin-top: 25px;
    }

    /* === Achievements Overlay === */
    #achievements-overlay {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: linear-gradient(145deg, #ffffff 0%, #f5f5f5 100%);
      padding: 30px;
      border-radius: 20px;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.4);
      max-width: 500px;
      width: 90%;
      max-height: 80vh;
      overflow-y: auto;
      z-index: 1001;
    }

    #achievements-overlay h2 {
      margin: 0 0 20px 0;
      color: #333;
      text-align: center;
      font-size: 28px;
    }

    .achievements-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
      gap: 12px;
      margin-bottom: 20px;
    }

    .achievement-card {
      background: #f9f9f9;
      border-radius: 12px;
      padding: 15px 10px;
      text-align: center;
      border: 2px solid #e0e0e0;
      transition: all 0.2s;
    }

    .achievement-card.unlocked {
      background: linear-gradient(145deg, #fff9e6 0%, #fff3cd 100%);
      border-color: #FFD700;
    }

    .achievement-card.locked {
      opacity: 0.5;
      filter: grayscale(100%);
    }

    .achievement-card .icon {
      font-size: 32px;
      margin-bottom: 8px;
    }

    .achievement-card .name {
      font-size: 12px;
      font-weight: bold;
      color: #333;
      margin-bottom: 4px;
    }

    .achievement-card .desc {
      font-size: 10px;
      color: #666;
    }

    .achievements-progress {
      text-align: center;
      color: #666;
      font-size: 14px;
      margin-bottom: 15px;
      padding: 10px;
      background: rgba(76, 175, 80, 0.1);
      border-radius: 8px;
    }

    .achievements-buttons {
      display: flex;
      justify-content: center;
    }

    /* === Hole Complete Modal Styles === */
    #hole-complete-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.75);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1002;
      animation: fadeIn 0.3s ease-out;
    }

    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    @keyframes slideUp {
      from { transform: translate(-50%, -40%); opacity: 0; }
      to { transform: translate(-50%, -50%); opacity: 1; }
    }

    @keyframes scorePop {
      0% { transform: scale(0.5); opacity: 0; }
      70% { transform: scale(1.1); }
      100% { transform: scale(1); opacity: 1; }
    }

    .hole-complete-modal {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: linear-gradient(145deg, #ffffff 0%, #f0f0f0 100%);
      padding: 30px 40px;
      border-radius: 20px;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.4);
      text-align: center;
      min-width: 280px;
      max-width: 90%;
      animation: slideUp 0.4s ease-out;
    }

    .hole-complete-header {
      font-size: 16px;
      color: #666;
      text-transform: uppercase;
      letter-spacing: 2px;
      margin-bottom: 5px;
    }

    .hole-complete-number {
      font-size: 48px;
      font-weight: 800;
      color: #333;
      margin-bottom: 15px;
    }

    .hole-complete-score-name {
      font-size: 32px;
      font-weight: 700;
      margin-bottom: 10px;
      animation: scorePop 0.5s ease-out 0.2s both;
    }

    .hole-complete-score-name.eagle { color: #FFD700; text-shadow: 0 2px 10px rgba(255, 215, 0, 0.5); }
    .hole-complete-score-name.birdie { color: #4CAF50; }
    .hole-complete-score-name.par { color: #2196F3; }
    .hole-complete-score-name.bogey { color: #FF9800; }
    .hole-complete-score-name.double-bogey { color: #F44336; }

    .hole-complete-details {
      display: flex;
      justify-content: center;
      gap: 30px;
      margin: 20px 0;
      padding: 15px 0;
      border-top: 1px solid #e0e0e0;
      border-bottom: 1px solid #e0e0e0;
    }

    .hole-complete-stat {
      text-align: center;
    }

    .hole-complete-stat-value {
      font-size: 28px;
      font-weight: 700;
      color: #333;
    }

    .hole-complete-stat-label {
      font-size: 12px;
      color: #888;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .hole-complete-total {
      font-size: 18px;
      color: #555;
      margin-bottom: 25px;
    }

    .hole-complete-total span {
      font-weight: 700;
    }

    .hole-complete-btn {
      padding: 14px 40px;
      background: linear-gradient(145deg, #4CAF50 0%, #45a049 100%);
      color: white;
      border: none;
      border-radius: 30px;
      font-size: 18px;
      font-weight: 700;
      cursor: pointer;
      box-shadow: 0 4px 15px rgba(76, 175, 80, 0.4);
      transition: transform 0.2s, box-shadow 0.2s;
    }

    .hole-complete-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(76, 175, 80, 0.5);
    }

    .hole-complete-btn:active {
      transform: translateY(0);
    }

    /* === Name Entry Modal Styles === */
    #name-entry-overlay {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(255, 255, 255, 0.98);
      padding: 30px;
      border-radius: 16px;
      box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
      max-width: 400px;
      width: 90%;
      z-index: 1001;
      text-align: center;
    }

    #name-entry-overlay h2 {
      margin-bottom: 10px;
      color: #333;
    }

    #name-entry-overlay p {
      color: #666;
      margin-bottom: 20px;
      font-size: 14px;
    }

    #player-name-input {
      width: 100%;
      padding: 15px;
      font-size: 18px;
      border: 2px solid #ddd;
      border-radius: 8px;
      margin-bottom: 20px;
      text-align: center;
      outline: none;
      transition: border-color 0.2s;
    }

    #player-name-input:focus {
      border-color: #4CAF50;
    }

    .name-entry-buttons {
      display: flex;
      gap: 10px;
      justify-content: center;
    }

    .name-entry-buttons .button {
      flex: 1;
      max-width: 150px;
    }

    .name-entry-buttons .cancel-btn {
      background: #999;
    }

    .name-entry-buttons .cancel-btn:active {
      background: #777;
    }

    /* === Tutorial Styles === */
    #tutorial-prompt-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1002;
    }

    #tutorial-overlay {
      position: fixed;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 1002;
      pointer-events: none; /* Allow clicks to pass through to game */
    }

    #tutorial-overlay .tutorial-modal {
      pointer-events: auto; /* Modal itself is clickable */
    }

    .tutorial-modal {
      background: rgba(255, 255, 255, 0.95);
      padding: 15px 25px;
      border-radius: 12px;
      box-shadow: 0 6px 24px rgba(0, 0, 0, 0.4);
      max-width: 380px;
      width: 90vw;
      text-align: center;
      border: 3px solid #4CAF50;
    }

    .tutorial-modal h2 {
      color: #333;
      margin: 0 0 8px 0;
      font-size: 20px;
    }

    .tutorial-modal p {
      color: #555;
      font-size: 15px;
      line-height: 1.4;
      margin: 0 0 12px 0;
    }

    .tutorial-buttons {
      display: flex;
      gap: 10px;
      justify-content: center;
      flex-wrap: wrap;
    }

    .tutorial-buttons .menu-button {
      padding: 8px 20px;
      font-size: 14px;
    }

    #tutorial-progress {
      margin-top: 10px;
      color: #888;
      font-size: 12px;
    }

    .tutorial-highlight {
      position: relative;
      box-shadow: 0 0 0 4px rgba(255, 165, 0, 0.8), 0 0 20px rgba(255, 165, 0, 0.5) !important;
      animation: tutorialPulse 1.5s ease-in-out infinite;
      z-index: 100;
    }

    @keyframes tutorialPulse {
      0%, 100% { box-shadow: 0 0 0 4px rgba(255, 165, 0, 0.8), 0 0 20px rgba(255, 165, 0, 0.5); }
      50% { box-shadow: 0 0 0 6px rgba(255, 165, 0, 1), 0 0 30px rgba(255, 165, 0, 0.7); }
    }

    /* === Ball Color Selector Styles === */
    .ball-color-section {
      margin: 20px 0;
    }

    .ball-color-section label {
      display: block;
      color: #333;
      font-weight: 600;
      margin-bottom: 12px;
    }

    .ball-color-options {
      display: flex;
      justify-content: center;
      gap: 12px;
      flex-wrap: wrap;
    }

    .ball-color-option {
      width: 44px;
      height: 44px;
      border-radius: 50%;
      border: 3px solid transparent;
      cursor: pointer;
      transition: transform 0.2s, border-color 0.2s, box-shadow 0.2s;
      position: relative;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }

    .ball-color-option:hover {
      transform: scale(1.1);
    }

    .ball-color-option.selected {
      border-color: #4CAF50;
      box-shadow: 0 0 0 3px rgba(76, 175, 80, 0.3), 0 2px 4px rgba(0, 0, 0, 0.2);
    }

    .ball-color-option.animated-ball {
      animation: rainbow-border 2s linear infinite;
    }

    .ball-color-option.animated-ball.selected {
      animation: rainbow-border-selected 2s linear infinite;
    }

    @keyframes rainbow-border {
      0% { box-shadow: 0 0 8px #ff0000, 0 2px 4px rgba(0, 0, 0, 0.2); }
      16% { box-shadow: 0 0 8px #ff8800, 0 2px 4px rgba(0, 0, 0, 0.2); }
      33% { box-shadow: 0 0 8px #ffff00, 0 2px 4px rgba(0, 0, 0, 0.2); }
      50% { box-shadow: 0 0 8px #00ff00, 0 2px 4px rgba(0, 0, 0, 0.2); }
      66% { box-shadow: 0 0 8px #0088ff, 0 2px 4px rgba(0, 0, 0, 0.2); }
      83% { box-shadow: 0 0 8px #8800ff, 0 2px 4px rgba(0, 0, 0, 0.2); }
      100% { box-shadow: 0 0 8px #ff0000, 0 2px 4px rgba(0, 0, 0, 0.2); }
    }

    @keyframes rainbow-border-selected {
      0% { box-shadow: 0 0 12px #ff0000, 0 0 0 3px rgba(76, 175, 80, 0.3); border-color: #4CAF50; }
      16% { box-shadow: 0 0 12px #ff8800, 0 0 0 3px rgba(76, 175, 80, 0.3); border-color: #4CAF50; }
      33% { box-shadow: 0 0 12px #ffff00, 0 0 0 3px rgba(76, 175, 80, 0.3); border-color: #4CAF50; }
      50% { box-shadow: 0 0 12px #00ff00, 0 0 0 3px rgba(76, 175, 80, 0.3); border-color: #4CAF50; }
      66% { box-shadow: 0 0 12px #0088ff, 0 0 0 3px rgba(76, 175, 80, 0.3); border-color: #4CAF50; }
      83% { box-shadow: 0 0 12px #8800ff, 0 0 0 3px rgba(76, 175, 80, 0.3); border-color: #4CAF50; }
      100% { box-shadow: 0 0 12px #ff0000, 0 0 0 3px rgba(76, 175, 80, 0.3); border-color: #4CAF50; }
    }

    .ball-color-option::after {
      content: '';
      position: absolute;
      top: 4px;
      left: 8px;
      width: 12px;
      height: 8px;
      background: radial-gradient(ellipse at center, rgba(255,255,255,0.8) 0%, rgba(255,255,255,0) 70%);
      border-radius: 50%;
    }

    /* Mobile phone optimizations */
    @media (max-width: 480px) {
      #scoreboard {
        top: 10px;
        left: 10px;
        padding: 8px 12px;
        font-size: 14px;
        border-radius: 8px;
      }

      #scoreboard div {
        margin: 3px 0;
      }

      #ball-state {
        top: 10px;
        right: 10px;
        padding: 6px 12px;
        font-size: 13px;
        border-radius: 8px;
      }

      #distance-display {
        bottom: 10px;
        right: 10px;
        padding: 10px 15px;
        font-size: 18px;
        border-radius: 8px;
      }

      #distance-display .label {
        font-size: 10px;
      }

      #club-selector-container {
        bottom: 8px;
        max-width: calc(100% - 16px);
      }

      #club-selector {
        padding: 10px 12px 8px 12px;
        gap: 2px;
        overflow-x: auto;
        -webkit-overflow-scrolling: touch;
        border-radius: 15px 15px 6px 6px;
      }

      .club-slot {
        padding: 3px;
      }

      .club-head {
        width: 38px;
        height: 38px;
        font-size: 10px;
      }

      .club-shaft {
        height: 25px;
        width: 3px;
      }

      .club-distance {
        font-size: 8px;
      }

      #club-toggle-btn {
        padding: 6px 14px;
        font-size: 12px;
        margin-top: 5px;
      }

      .button {
        padding: 8px 16px;
        margin: 3px;
        font-size: 13px;
        border-radius: 6px;
      }

      #menu-container {
        padding: 20px 15px;
      }

      #menu-container h1 {
        font-size: 32px;
      }

      #round-progress {
        top: auto;
        bottom: 120px;
        left: 10px;
        font-size: 12px;
        padding: 6px 12px;
      }

      .overlay-panel {
        padding: 20px 15px;
        max-width: 95%;
      }

      .overlay-panel h2 {
        font-size: 22px;
      }

      .scorecard-table, .leaderboard-table {
        font-size: 13px;
      }

      .scorecard-table th,
      .scorecard-table td,
      .leaderboard-table th,
      .leaderboard-table td {
        padding: 6px 8px;
      }
    }

    /* Small tablets and large phones */
    @media (min-width: 481px) and (max-width: 768px) {
      #scoreboard {
        top: 15px;
        left: 15px;
        padding: 12px 16px;
        font-size: 16px;
      }

      #ball-state {
        top: 15px;
        right: 15px;
        padding: 8px 16px;
        font-size: 14px;
      }

      #distance-display {
        bottom: 15px;
        right: 15px;
        padding: 12px 20px;
        font-size: 20px;
      }

      #club-selector-container {
        bottom: 12px;
        max-width: calc(100% - 24px);
      }

      #club-selector {
        padding: 12px 16px 8px 16px;
        gap: 3px;
        overflow-x: auto;
        -webkit-overflow-scrolling: touch;
      }

      .club-head {
        width: 42px;
        height: 42px;
        font-size: 11px;
      }

      .club-shaft {
        height: 30px;
      }

      .button {
        padding: 10px 20px;
        margin: 4px;
        font-size: 15px;
      }
    }
  </style>
</head>
<body>
  <canvas id="game-canvas"></canvas>

  <div id="ui-overlay">
    <div id="scoreboard">
      <div class="score-header">
        <span class="hole-info">Hole <span id="hole-number">1</span></span>
        <span class="par-info">Par <span id="hole-par">3</span></span>
        <button class="ingame-settings-btn" id="ingame-settings-btn" title="Settings">⚙️</button>
      </div>
      <div class="score-row">
        <span class="score-label">Strokes</span>
        <span class="score-value" id="stroke-count">0</span>
      </div>
      <div class="score-row">
        <span class="score-label">Score</span>
        <span class="score-value" id="total-score">E</span>
      </div>
      <div class="club-info">
        <div class="club-name" id="current-club">Driver</div>
        <div class="distance-info"><span id="distance-to-hole">---</span> yds to hole</div>
      </div>
    </div>

    <div id="ball-state">🔴 Ready</div>

    <div id="wind-indicator" class="hidden wind-calm">
      <div class="wind-label">WIND</div>
      <div class="wind-arrow">➤</div>
      <div class="wind-speed">0 mph</div>
    </div>

    <div id="achievement-popup">
      <div class="achievement-icon">🏆</div>
      <div class="achievement-title">Achievement Unlocked!</div>
      <div class="achievement-name"></div>
      <div class="achievement-desc"></div>
    </div>

    <div id="distance-display" class="hidden">
      <span class="label">Distance to Hole</span>
      <span id="distance-value">---</span>yd
    </div>

    <div id="round-progress" class="hidden">
      <strong>Progress:</strong> <span id="progress-text">0/9 holes</span>
    </div>

    <div id="club-selector-container">
      <div id="club-selector">
        <button class="button selected" data-club="driver">Driver</button>
      </div>
      <button id="club-toggle-btn">Hide Clubs</button>
    </div>

    <div id="scorecard-overlay" class="hidden">
      <h2>Scorecard</h2>
      <div id="scorecard-content"></div>
      <button class="button" onclick="document.getElementById('scorecard-overlay').classList.add('hidden')">Close</button>
    </div>

    <div id="leaderboard-overlay" class="hidden">
      <h2>🏆 Leaderboard - Top 10</h2>
      <div id="leaderboard-content"></div>
      <button class="button" onclick="document.getElementById('leaderboard-overlay').classList.add('hidden')">Close</button>
    </div>

    <div id="settings-overlay" class="hidden">
      <h2>⚙️ Settings</h2>
      <div class="settings-group">
        <div class="settings-row">
          <span class="settings-label"><span class="icon">🔊</span> Sound Effects</span>
          <label class="toggle-switch">
            <input type="checkbox" id="setting-sound" checked>
            <span class="toggle-slider"></span>
          </label>
        </div>
        <div class="settings-row">
          <span class="settings-label"><span class="icon">🎵</span> Background Music</span>
          <label class="toggle-switch">
            <input type="checkbox" id="setting-music" checked>
            <span class="toggle-slider"></span>
          </label>
        </div>
        <div class="settings-row">
          <span class="settings-label"><span class="icon">💨</span> Ball Trails</span>
          <label class="toggle-switch">
            <input type="checkbox" id="setting-trails" checked>
            <span class="toggle-slider"></span>
          </label>
        </div>
        <div class="settings-row">
          <span class="settings-label"><span class="icon">🌪️</span> Random Events</span>
          <label class="toggle-switch">
            <input type="checkbox" id="setting-events" checked>
            <span class="toggle-slider"></span>
          </label>
        </div>
        <div class="settings-row">
          <span class="settings-label"><span class="icon">📖</span> Reset Tutorial</span>
          <button class="button" id="reset-tutorial-btn" style="padding: 8px 16px; font-size: 14px;">Reset</button>
        </div>
      </div>
      <div class="settings-buttons">
        <button class="button" id="close-settings-btn">Close</button>
      </div>
    </div>

    <div id="achievements-overlay" class="hidden">
      <h2>🏆 Achievements</h2>
      <div class="achievements-progress" id="achievements-progress">0 / 0 unlocked</div>
      <div class="achievements-grid" id="achievements-grid"></div>
      <div class="achievements-buttons">
        <button class="button" id="close-achievements-btn">Close</button>
      </div>
    </div>

    <!-- Shop Overlay -->
    <div id="shop-overlay" class="hidden">
      <div id="shop-modal">
        <div id="shop-header">
          <h2>🛒 Club Shop</h2>
          <div id="shop-balance-display">💵 <span id="shop-balance">0</span> Golf Bucks</div>
        </div>
        <div id="shop-content">
          <div id="shop-info">
            <h3>💰 How to Earn Golf Bucks</h3>
            <p>Upgrade your clubs to hit farther! Better clubs = lower scores.</p>
            <div class="earn-list">
              <div class="earn-item"><span>Birdie</span><span>+50 GB</span></div>
              <div class="earn-item"><span>Eagle</span><span>+150 GB</span></div>
              <div class="earn-item"><span>Hole-in-One</span><span>+500 GB</span></div>
              <div class="earn-item"><span>Complete Round</span><span>+100 GB</span></div>
              <div class="earn-item"><span>Under Par Bonus</span><span>+50/stroke</span></div>
              <div class="earn-item"><span>Achievement</span><span>+200 GB</span></div>
            </div>
          </div>
          <div id="shop-tier-legend">
            <div class="tier-item basic"><span class="tier-stars">★☆☆</span> Basic (70%)</div>
            <div class="tier-item standard"><span class="tier-stars">★★☆</span> Standard (85%)</div>
            <div class="tier-item pro"><span class="tier-stars">★★★</span> Pro (100%)</div>
          </div>
          <div id="shop-clubs-grid"></div>

          <!-- Ball Skins Section -->
          <div id="shop-balls-section">
            <h3 class="shop-section-title">🎱 Ball Skins</h3>
            <div id="shop-balls-grid"></div>
          </div>
        </div>
        <div id="shop-footer">
          <button id="shop-close-btn">Close Shop</button>
        </div>
      </div>
    </div>

    <div id="name-entry-overlay" class="hidden">
      <h2>Enter Your Name</h2>
      <p>Your scores will appear on the global leaderboard!</p>
      <input type="text" id="player-name-input" maxlength="20" placeholder="Your name" autocomplete="off">

      <div class="ball-color-section">
        <label>Choose Your Ball</label>
        <div class="ball-color-options" id="ball-color-options">
          <!-- Dynamically populated based on owned skins -->
        </div>
      </div>

      <div class="name-entry-buttons">
        <button class="button" id="start-with-name-btn">Start Game</button>
        <button class="button cancel-btn" id="cancel-name-entry-btn">Cancel</button>
      </div>
    </div>

    <div id="debug-info" class="hidden"></div>

    <button id="reset-shot-btn" class="hidden">Cancel Shot</button>

    <div id="hole-complete-overlay" class="hidden">
      <div class="hole-complete-modal">
        <div class="hole-complete-header">Hole Complete</div>
        <div class="hole-complete-number" id="hole-complete-number">1</div>
        <div class="hole-complete-score-name" id="hole-complete-score-name">Par</div>
        <div class="hole-complete-details">
          <div class="hole-complete-stat">
            <div class="hole-complete-stat-value" id="hole-complete-strokes">4</div>
            <div class="hole-complete-stat-label">Strokes</div>
          </div>
          <div class="hole-complete-stat">
            <div class="hole-complete-stat-value" id="hole-complete-par">4</div>
            <div class="hole-complete-stat-label">Par</div>
          </div>
        </div>
        <div class="hole-complete-total">Round Total: <span id="hole-complete-total">E</span></div>
        <button class="hole-complete-btn" id="hole-complete-btn">Next Hole</button>
      </div>
    </div>
  </div>

  <!-- Tutorial Overlay -->
  <div id="tutorial-overlay" class="hidden">
    <div class="tutorial-modal">
      <h2 id="tutorial-title">Welcome!</h2>
      <p id="tutorial-text">Tutorial text here</p>
      <div class="tutorial-buttons">
        <button id="tutorial-next-btn" class="menu-button">Next</button>
        <button id="tutorial-skip-btn" class="menu-button cancel-btn">Skip Tutorial</button>
      </div>
      <div id="tutorial-progress">Step 1 of 5</div>
    </div>
  </div>

  <!-- Tutorial Prompt Overlay -->
  <div id="tutorial-prompt-overlay" class="hidden">
    <div class="tutorial-modal">
      <h2>First Time Playing?</h2>
      <p>Would you like a quick tutorial to learn how to play?</p>
      <div class="tutorial-buttons">
        <button id="tutorial-yes-btn" class="menu-button">Yes, Show Me!</button>
        <button id="tutorial-no-btn" class="menu-button cancel-btn">No Thanks</button>
      </div>
    </div>
  </div>

  <div id="menu-overlay">
    <h1>Howlett Golf Chaos</h1>
    <p style="color: white; font-size: 18px; margin: 20px; max-width: 500px; text-align: center;">
      🖱️ Desktop: Click and drag backward from the ball, then release to swing<br>
      📱 Touch: Drag backward from the ball, then release
    </p>
    <button class="menu-button" id="new-game-btn">New Game</button>
    <button class="menu-button hidden" id="resume-game-btn">Resume Game</button>
    <button class="menu-button" id="leaderboard-btn">Leaderboard</button>
    <button class="menu-button" id="tutorial-btn" style="background: #9C27B0;">Tutorial</button>

    <button id="music-prompt-btn">🎵 Tap for Music</button>

    <div class="menu-bottom-buttons">
      <button class="menu-icon-btn" id="shop-btn" title="Shop">🛒</button>
      <button class="menu-icon-btn" id="achievements-btn" title="Achievements">🏆</button>
      <button class="menu-icon-btn" id="settings-btn" title="Settings">⚙️</button>
    </div>
    <div id="menu-balance">0 GB</div>
  </div>

  <script>
    'use strict';

    // T001-T005: Basic setup complete
    // T006-T012: Foundational modules below

    // === Ball Color Definitions ===
    const BallColors = {
      white:  { highlight: '#FFFFFF', base: '#CCCCCC', stroke: '#999999' },
      yellow: { highlight: '#FFEB3B', base: '#FBC02D', stroke: '#F9A825' },
      orange: { highlight: '#FF9800', base: '#F57C00', stroke: '#E65100' },
      pink:   { highlight: '#FF69B4', base: '#DB7093', stroke: '#C71585' },
      red:    { highlight: '#F44336', base: '#C62828', stroke: '#B71C1C' },
      blue:   { highlight: '#2196F3', base: '#1565C0', stroke: '#0D47A1' },
      green:  { highlight: '#4CAF50', base: '#2E7D32', stroke: '#1B5E20' },
      purple: { highlight: '#9C27B0', base: '#6A1B9A', stroke: '#4A148C' }
    };

    // Premium ball colors (purchasable in shop)
    const PremiumBallColors = {
      // Solid premium colors
      gold:     { highlight: '#FFD700', base: '#B8860B', stroke: '#8B6914' },
      chrome:   { highlight: '#E8E8E8', base: '#A8A8A8', stroke: '#787878' },
      neon:     { highlight: '#39FF14', base: '#32CD32', stroke: '#228B22' },
      midnight: { highlight: '#1a1a40', base: '#0d0d20', stroke: '#000010' },
      rose:     { highlight: '#FFB6C1', base: '#FF69B4', stroke: '#DB7093' },
      // Animated/special effects
      galaxy:   { highlight: '#9B59B6', base: '#8E44AD', stroke: '#6C3483', animated: 'galaxy' },
      fire:     { highlight: '#FF4500', base: '#FF6347', stroke: '#DC143C', animated: 'fire' },
      rainbow:  { highlight: '#FF0000', base: '#FF7F00', stroke: '#FFFF00', animated: 'rainbow' }
    };

    // === SeededRandom Class (T006) ===
    class SeededRandom {
      constructor(seed = Date.now()) {
        this.state = seed;
      }

      next() {
        let t = this.state += 0x6D2B79F5;
        t = Math.imul(t ^ t >>> 15, t | 1);
        t ^= t + Math.imul(t ^ t >>> 7, t | 61);
        return ((t ^ t >>> 14) >>> 0) / 4294967296;
      }

      nextInt(min, max) {
        return Math.floor(this.next() * (max - min + 1)) + min;
      }

      nextFloat(min, max) {
        return this.next() * (max - min) + min;
      }
    }

    // === Distance Conversion ===
    // ScreenScale manages consistent yardage across all screen sizes
    // Holes are defined in YARDS and scaled to fit the screen
    const ScreenScale = {
      pixelsPerYard: 1, // Will be calculated based on screen size

      // Initialize scale based on canvas size
      // Longest hole (par 5) is ~480 yards, should use ~85% of screen width
      init(canvasWidth) {
        const longestHoleYards = 480;
        const usableWidth = canvasWidth * 0.85; // Leave margins
        this.pixelsPerYard = usableWidth / longestHoleYards;
      },

      // Convert yards to pixels
      yardsToPixels(yards) {
        return yards * this.pixelsPerYard;
      },

      // Convert pixels to yards
      pixelsToYards(pixels) {
        return pixels / this.pixelsPerYard;
      }
    };

    // Legacy constant for backwards compatibility (will be overwritten by ScreenScale)
    let PIXELS_TO_YARDS = 0.42;

    // === PhysicsEngine Module (T008, T016, T017, T018) ===
    const PhysicsEngine = {
      gravity: 980,
      friction: 0.98,
      airResistance: 0.995,
      baseStopThreshold: 5,
      holeRadius: 15,

      // Stop threshold scaled to screen size (in yards, converted to pixels)
      get stopThreshold() {
        const thresholdYards = 2; // Ball stops when moving less than 2 yards/sec
        return thresholdYards * ScreenScale.pixelsPerYard;
      },

      add(v1, v2) {
        return { x: v1.x + v2.x, y: v1.y + v2.y };
      },

      subtract(v1, v2) {
        return { x: v1.x - v2.x, y: v1.y - v2.y };
      },

      magnitude(v) {
        return Math.sqrt(v.x * v.x + v.y * v.y);
      },

      normalize(v) {
        const mag = this.magnitude(v);
        if (mag === 0) return { x: 0, y: 0 };
        return { x: v.x / mag, y: v.y / mag };
      },

      distance(p1, p2) {
        const dx = p2.x - p1.x;
        const dy = p2.y - p1.y;
        return Math.sqrt(dx * dx + dy * dy);
      },

      applySwing(ball, swingVector) {
        // Fixed max distance - clubs always hit the same distance in yards
        // Calculate velocity needed to travel 280 yards after friction
        const targetYards = 280; // Driver at 100% = 280 yards
        const targetPixels = targetYards * ScreenScale.pixelsPerYard;
        // With friction 0.98 at 60fps, velocity needs to be ~1.2x target distance
        // This compensates for the friction decay during ball travel
        const maxVelocity = targetPixels * 1.2;

        ball.velocityX = -Math.cos(swingVector.angle) * swingVector.power * maxVelocity;
        ball.velocityY = -Math.sin(swingVector.angle) * swingVector.power * maxVelocity;
        ball.isAirborne = true;
        ball.isMoving = true;
        ball.spin = swingVector.power * 0.5;
      },

      updateBall(ball, deltaTime, obstacles) {
        if (!ball.isMoving) return;

        // Apply wind force only when ball is moving fast enough (not when nearly stopped)
        const currentSpeed = Math.sqrt(ball.velocityX * ball.velocityX + ball.velocityY * ball.velocityY);
        if (currentSpeed > 20) {
          const wind = WindSystem.getWindForce();
          // Scale wind effect by speed - less effect when slowing down
          const windScale = Math.min(1, currentSpeed / 100);
          ball.velocityX += wind.x * deltaTime * windScale;
          ball.velocityY += wind.y * deltaTime * windScale;
        }

        // Apply friction (frame-rate independent: same slowdown regardless of FPS)
        const frictionFactor = Math.pow(this.friction, deltaTime * 60);
        ball.velocityX *= frictionFactor;
        ball.velocityY *= frictionFactor;

        // Update position
        ball.x += ball.velocityX * deltaTime;
        ball.y += ball.velocityY * deltaTime;

        // Check obstacle collisions
        if (obstacles) {
          this.checkObstacleCollisions(ball, obstacles);
        }

        // Stop ball if moving too slowly
        const speed = Math.sqrt(ball.velocityX * ball.velocityX + ball.velocityY * ball.velocityY);
        if (speed < this.stopThreshold) {
          ball.velocityX = 0;
          ball.velocityY = 0;
          ball.isMoving = false;
          ball.isAirborne = false;
          ball.leavingSand = false;  // Clear escape flag when ball stops
          // Note: inSand will be set by collision detection if ball lands in sand
        }

        ball.rotation += speed * deltaTime * 0.1;
        ball.distanceFromHole = this.distance(ball, ball.holePosition);
      },

      checkObstacleCollisions(ball, obstacles) {
        let inSandNow = false;
        for (const obstacle of obstacles) {
          if (this.checkCollision(ball, obstacle)) {
            if (obstacle.type === 'sand') {
              inSandNow = true;
            }
            this.handleObstacleCollision(ball, obstacle);
          }
        }
        // Clear leavingSand flag once ball has left all sand areas
        if (!inSandNow && ball.leavingSand) {
          ball.leavingSand = false;
          ball.inSand = false;
        }
      },

      checkCollision(ball, obstacle) {
        if (obstacle.shape === 'circle') {
          const dist = this.distance(ball, obstacle);
          return dist < (8 + obstacle.radius);
        } else if (obstacle.shape === 'rectangle') {
          return ball.x >= obstacle.x && ball.x <= obstacle.x + obstacle.width &&
                 ball.y >= obstacle.y && ball.y <= obstacle.y + obstacle.height;
        }
        return false;
      },

      handleObstacleCollision(ball, obstacle) {
        // Track if this is a new collision to avoid repeated sounds
        if (!ball.lastCollision || ball.lastCollision !== obstacle) {
          ball.lastCollision = obstacle;
          ball.collisionSoundPlayed = false;
        }

        if (obstacle.type === 'sand') {
          // If ball is being hit out of sand, let it pass through
          if (ball.leavingSand) {
            return;  // Don't stop - ball is escaping
          }

          // Ball entering sand - slow it dramatically and pull toward center
          if (!ball.collisionSoundPlayed) {
            AudioManager.playLandSound('sand');
            AudioManager.playCrowdGasp();  // Crowd reacts to bunker
            ball.collisionSoundPlayed = true;
          }

          // Calculate direction toward center of bunker
          const dx = obstacle.x - ball.x;
          const dy = obstacle.y - ball.y;
          const dist = Math.sqrt(dx * dx + dy * dy);

          // Slow the ball and redirect toward center (simulating rolling into depression)
          const currentSpeed = Math.sqrt(ball.velocityX * ball.velocityX + ball.velocityY * ball.velocityY);
          if (dist > 10 && currentSpeed > 5) {
            // Roll toward center with reduced speed
            const rollSpeed = Math.min(currentSpeed * 0.3, 80);
            ball.velocityX = (dx / dist) * rollSpeed;
            ball.velocityY = (dy / dist) * rollSpeed;
          } else {
            // Close to center or very slow - stop
            ball.velocityX = 0;
            ball.velocityY = 0;
            ball.isMoving = false;
          }

          ball.inSand = true;  // Flag for reduced power on next shot
          // Track for achievements
          AchievementManager.stats.hadSand = true;
        } else if (obstacle.type === 'water') {
          if (!ball.collisionSoundPlayed) {
            AudioManager.playLandSound('water');
            AudioManager.playCrowdGasp();  // Crowd reacts to water hazard
            ball.collisionSoundPlayed = true;
          }
          if (ball.lastSafePosition) {
            ball.x = ball.lastSafePosition.x;
            ball.y = ball.lastSafePosition.y;
            ball.velocityX = 0;
            ball.velocityY = 0;
            ball.isMoving = false;
            ball.waterPenalty = true;
            // Track for achievements
            AchievementManager.stats.hadWater = true;
          }
        } else if (obstacle.type === 'tree' || obstacle.type === 'rock') {
          if (!ball.collisionSoundPlayed) {
            AudioManager.playLandSound('grass');
            ball.collisionSoundPlayed = true;
          }
          const dx = ball.x - obstacle.x;
          const dy = ball.y - obstacle.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          const nx = dx / dist;
          const ny = dy / dist;

          ball.x = obstacle.x + nx * (obstacle.radius + 10);
          ball.y = obstacle.y + ny * (obstacle.radius + 10);

          const dotProduct = ball.velocityX * nx + ball.velocityY * ny;
          ball.velocityX = (ball.velocityX - 2 * dotProduct * nx) * 0.6;
          ball.velocityY = (ball.velocityY - 2 * dotProduct * ny) * 0.6;
        }
      },

      isBallInHole(ball) {
        if (ball.distanceFromHole >= this.holeRadius) return false;

        // Ball goes in if it's in the hole radius and moving slowly or stopped
        const speed = Math.sqrt(ball.velocityX * ball.velocityX + ball.velocityY * ball.velocityY);
        const slowEnough = speed < 50; // Ball moving slower than 50 units/second

        return slowEnough;
      }
    };

    // === Renderer Module (T009, T019, T020, T021) ===
    const Renderer = {
      canvas: null,
      ctx: null,
      backgroundCache: null,

      init(canvas) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        this.backgroundCache = document.createElement('canvas');
        this.resizeCanvas();
        window.addEventListener('resize', () => this.resizeCanvas());
      },

      resizeCanvas() {
        const dpr = window.devicePixelRatio || 1;
        const rect = this.canvas.getBoundingClientRect();

        this.canvas.width = rect.width * dpr;
        this.canvas.height = rect.height * dpr;

        this.ctx.scale(dpr, dpr);

        this.canvas.style.width = rect.width + 'px';
        this.canvas.style.height = rect.height + 'px';
      },

      renderFrame(gameState, animationTime = 0) {
        if (!gameState) return;

        this.clearCanvas();

        if (gameState.currentHole && gameState.ball) {
          this.drawCourse(gameState.currentHole, animationTime);
          // Crowd disabled for now - this.drawCrowd(gameState.currentHole);
          if (gameState.currentHole.obstacles) {
            this.drawObstacles(gameState.currentHole.obstacles);
          }

          // Update and draw ball trail (if enabled)
          const trailsEnabled = StorageManager.loadSettings().trailsEnabled !== false;
          if (trailsEnabled) {
            BallTrail.update(gameState.ball);
            BallTrail.draw(this.ctx);
          }

          this.drawBall(gameState.ball);

          if (gameState.strikeFlash && gameState.strikeFlash.active) {
            this.drawStrikeFlash(gameState.ball, gameState.strikeFlash);
          }

          // Draw confetti particles
          ConfettiSystem.draw(this.ctx);

          // Draw streaker (random event)
          RandomEventManager.draw(this.ctx);
        }

        const swingPreview = InputHandler.getSwingPreview();
        if (swingPreview && gameState.ball && !gameState.ball.isMoving) {
          this.drawGuideArrow(swingPreview, gameState.ball, gameState.selectedClub);
        }
      },

      clearCanvas() {
        const rect = this.canvas.getBoundingClientRect();
        this.ctx.clearRect(0, 0, rect.width, rect.height);
      },

      clearRegion(x, y, width, height) {
        this.ctx.clearRect(x, y, width, height);
      },

      drawCourse(hole, animationTime = 0) {
        const ctx = this.ctx;
        const canvasW = this.canvas.width;
        const canvasH = this.canvas.height;

        // === ROUGH (brown-ish dried grass with visible long grass texture) ===
        // Base rough color - yellow-brown tinge
        const roughGradient = ctx.createLinearGradient(0, 0, canvasW, canvasH);
        roughGradient.addColorStop(0, '#5A7A42');   // Olive green
        roughGradient.addColorStop(0.4, '#6B8850'); // Yellow-green
        roughGradient.addColorStop(0.7, '#5A7540'); // Darker olive
        roughGradient.addColorStop(1, '#4A6535');   // Brown-green
        ctx.fillStyle = roughGradient;
        ctx.fillRect(0, 0, canvasW, canvasH);

        // Long grass blade texture - MORE VISIBLE
        ctx.lineWidth = 2;  // Thicker lines
        for (let i = 0; i < 800; i++) {  // More grass blades
          const seed1 = (i * 7919 + 1) % 997;
          const seed2 = (i * 6271 + 3) % 991;
          const seed3 = (i * 3571 + 7) % 983;
          const x = (seed1 / 997) * canvasW;
          const y = (seed2 / 991) * canvasH;
          const len = 8 + (seed3 % 10);  // Longer blades: 8-17px
          const lean = ((seed3 % 7) - 3) * 0.8; // More lean variation

          // More visible colors - darker strokes
          if (seed3 % 4 === 0) {
            ctx.strokeStyle = 'rgba(50, 70, 30, 0.7)';  // Dark grass
          } else if (seed3 % 4 === 1) {
            ctx.strokeStyle = 'rgba(70, 90, 40, 0.6)';  // Medium grass
          } else {
            ctx.strokeStyle = 'rgba(85, 105, 50, 0.5)'; // Light grass
          }
          ctx.beginPath();
          ctx.moveTo(x, y);
          ctx.lineTo(x + lean, y - len);
          ctx.stroke();
        }

        // === FAIRWAY with smooth curves and fringe transition ===
        const path = hole.fairwayPath || [hole.teePosition, hole.greenPosition];

        const fairwayWidth = 140;  // WIDER fairway
        const fringeWidth = 25;    // Wider fringe

        // Draw tee-to-fairway connector FIRST (underneath everything)
        // This fills the gap between tee box and fairway start
        const teePos = path[0];
        const nextPos = path[1] || path[0];
        const toGreenDx = nextPos.x - teePos.x;
        const toGreenDy = nextPos.y - teePos.y;
        const toGreenLen = Math.sqrt(toGreenDx * toGreenDx + toGreenDy * toGreenDy) || 1;
        const dirX = toGreenDx / toGreenLen;
        const dirY = toGreenDy / toGreenLen;
        const perpX = -dirY;
        const perpY = dirX;

        // First cut connector from tee to fairway
        ctx.fillStyle = '#4A9A40';  // Same as fringe
        ctx.beginPath();
        const fringeW = (fairwayWidth + fringeWidth * 2) / 2;
        // Start behind tee box, end past where fairway rounded end will be
        ctx.moveTo(teePos.x - dirX * 60 + perpX * fringeW, teePos.y - dirY * 60 + perpY * fringeW);
        ctx.lineTo(teePos.x + dirX * 20 + perpX * fringeW, teePos.y + dirY * 20 + perpY * fringeW);
        ctx.lineTo(teePos.x + dirX * 20 - perpX * fringeW, teePos.y + dirY * 20 - perpY * fringeW);
        ctx.lineTo(teePos.x - dirX * 60 - perpX * fringeW, teePos.y - dirY * 60 - perpY * fringeW);
        ctx.closePath();
        ctx.fill();

        // Main fairway connector
        ctx.fillStyle = '#5DBF50';  // Same as fairway
        ctx.beginPath();
        const fairwayW = fairwayWidth / 2;
        ctx.moveTo(teePos.x - dirX * 55 + perpX * fairwayW, teePos.y - dirY * 55 + perpY * fairwayW);
        ctx.lineTo(teePos.x + dirX * 20 + perpX * fairwayW, teePos.y + dirY * 20 + perpY * fairwayW);
        ctx.lineTo(teePos.x + dirX * 20 - perpX * fairwayW, teePos.y + dirY * 20 - perpY * fairwayW);
        ctx.lineTo(teePos.x - dirX * 55 - perpX * fairwayW, teePos.y - dirY * 55 - perpY * fairwayW);
        ctx.closePath();
        ctx.fill();

        // Helper to get perpendicular at a segment
        const getPerp = (p1, p2) => {
          const dx = p2.x - p1.x;
          const dy = p2.y - p1.y;
          const len = Math.sqrt(dx * dx + dy * dy) || 1;
          return { x: -dy / len, y: dx / len };
        };

        // Build SMOOTH fairway path with bezier curves at corners (original curvy style)
        // NOTE: No rounded end at tee - fairway starts with straight edge at tee position
        const buildSmoothFairwayPath = (width) => {
          ctx.beginPath();
          const w = width / 2;

          if (path.length === 2) {
            // Straight hole - rectangle with rounded end at GREEN only, flat at tee
            const p1 = path[0];
            const p2 = path[1];
            const perp = getPerp(p1, p2);

            // Start at tee right edge, go to green
            ctx.moveTo(p1.x + perp.x * w, p1.y + perp.y * w);
            ctx.lineTo(p2.x + perp.x * w, p2.y + perp.y * w);
            // Rounded end at green
            ctx.arc(p2.x, p2.y, w, Math.atan2(perp.y, perp.x), Math.atan2(-perp.y, -perp.x), false);
            // Back to tee left edge
            ctx.lineTo(p1.x - perp.x * w, p1.y - perp.y * w);
            // Flat end at tee (just close the path)
            ctx.closePath();
          } else {
            // Dogleg - use curves at the bend, flat end at tee
            const p1 = path[0];
            const p2 = path[1];  // Bend point
            const p3 = path[2];

            const perp1 = getPerp(p1, p2);
            const perp2 = getPerp(p2, p3);

            // Right edge: tee to bend to green
            ctx.moveTo(p1.x + perp1.x * w, p1.y + perp1.y * w);
            // Curve through the bend point
            ctx.quadraticCurveTo(
              p2.x + (perp1.x + perp2.x) * w * 0.5,
              p2.y + (perp1.y + perp2.y) * w * 0.5,
              p2.x + perp2.x * w, p2.y + perp2.y * w
            );
            ctx.lineTo(p3.x + perp2.x * w, p3.y + perp2.y * w);

            // Rounded end at green
            ctx.arc(p3.x, p3.y, w, Math.atan2(perp2.y, perp2.x), Math.atan2(-perp2.y, -perp2.x), false);

            // Left edge: green to bend to tee
            ctx.lineTo(p2.x - perp2.x * w, p2.y - perp2.y * w);
            ctx.quadraticCurveTo(
              p2.x - (perp1.x + perp2.x) * w * 0.5,
              p2.y - (perp1.y + perp2.y) * w * 0.5,
              p1.x - perp1.x * w, p1.y - perp1.y * w
            );

            // Flat end at tee (just close the path)
            ctx.closePath();
          }
        };

        // Fringe / first-cut (medium green border)
        ctx.fillStyle = '#4A9A40';  // Medium green - between rough and fairway
        buildSmoothFairwayPath(fairwayWidth + fringeWidth * 2);
        ctx.fill();

        // Main fairway (bright green)
        ctx.fillStyle = '#5DBF50';  // Bright maintained grass
        buildSmoothFairwayPath(fairwayWidth);
        ctx.fill();

        // VISIBLE mowing stripes along fairway direction
        ctx.save();
        buildSmoothFairwayPath(fairwayWidth);
        ctx.clip();

        // Draw thick alternating stripes
        const stripeWidth = 20;
        for (let seg = 0; seg < path.length - 1; seg++) {
          const p1 = path[seg];
          const p2 = path[seg + 1];
          const dx = p2.x - p1.x;
          const dy = p2.y - p1.y;
          const segLen = Math.sqrt(dx * dx + dy * dy);
          const normX = dx / segLen;
          const normY = dy / segLen;
          const perp = getPerp(p1, p2);

          // Draw alternating stripes
          for (let d = 0; d < segLen; d += stripeWidth * 2) {
            const t = d / segLen;
            const cx = p1.x + dx * t;
            const cy = p1.y + dy * t;

            // Lighter stripe - more visible
            ctx.fillStyle = 'rgba(130, 220, 110, 0.4)';
            ctx.beginPath();
            ctx.moveTo(cx + perp.x * 100, cy + perp.y * 100);
            ctx.lineTo(cx - perp.x * 100, cy - perp.y * 100);
            ctx.lineTo(cx - perp.x * 100 + normX * stripeWidth, cy - perp.y * 100 + normY * stripeWidth);
            ctx.lineTo(cx + perp.x * 100 + normX * stripeWidth, cy + perp.y * 100 + normY * stripeWidth);
            ctx.closePath();
            ctx.fill();
          }
        }
        ctx.restore();

        // Stylized tee box - oval shape with stripes
        ctx.save();
        ctx.translate(hole.teePosition.x, hole.teePosition.y);

        // Tee box shadow
        ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
        ctx.beginPath();
        ctx.ellipse(4, 6, 55, 35, 0, 0, Math.PI * 2);
        ctx.fill();

        // Tee box base
        const teeGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, 50);
        teeGradient.addColorStop(0, '#3CB371');
        teeGradient.addColorStop(1, '#2E8B57');
        ctx.fillStyle = teeGradient;
        ctx.beginPath();
        ctx.ellipse(0, 0, 50, 30, 0, 0, Math.PI * 2);
        ctx.fill();

        // Tee box outline
        ctx.strokeStyle = '#228B22';
        ctx.lineWidth = 3;
        ctx.stroke();

        // Tee markers (cartoon style)
        ctx.fillStyle = '#FF6B6B';
        ctx.beginPath();
        ctx.arc(-20, -5, 6, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = '#CC5555';
        ctx.lineWidth = 2;
        ctx.stroke();

        ctx.fillStyle = '#FF6B6B';
        ctx.beginPath();
        ctx.arc(20, -5, 6, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();

        ctx.restore();

        // Approach collar - connects fairway/fringe to green seamlessly
        // Draw before green so green overlaps it
        const lastPathPoint = path[path.length - 1];
        const prevPoint = path.length > 1 ? path[path.length - 2] : path[0];
        const approachAngle = Math.atan2(lastPathPoint.y - prevPoint.y, lastPathPoint.x - prevPoint.x);

        // First cut collar extending from fairway to green
        ctx.save();
        ctx.translate(hole.greenPosition.x, hole.greenPosition.y);
        ctx.fillStyle = '#4A9A40';  // Same as fringe/first-cut color
        ctx.beginPath();
        // Draw an extended ellipse in the direction the fairway comes from
        const collarExtend = 40;
        ctx.ellipse(
          Math.cos(approachAngle + Math.PI) * collarExtend * 0.5,
          Math.sin(approachAngle + Math.PI) * collarExtend * 0.5,
          110 + collarExtend * 0.3, 95 + collarExtend * 0.2,
          0, 0, Math.PI * 2
        );
        ctx.fill();
        ctx.restore();

        // Stylized putting green with contours
        ctx.save();
        ctx.translate(hole.greenPosition.x, hole.greenPosition.y);

        // Green shadow
        ctx.fillStyle = 'rgba(0, 0, 0, 0.15)';
        ctx.beginPath();
        ctx.ellipse(5, 8, 95, 75, 0, 0, Math.PI * 2);
        ctx.fill();

        // Outer fringe - larger to overlap with collar
        ctx.fillStyle = '#32CD32';
        ctx.beginPath();
        ctx.ellipse(0, 0, 105, 90, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = '#228B22';
        ctx.lineWidth = 3;
        ctx.stroke();

        // Main green with gradient
        const greenGradient = ctx.createRadialGradient(-20, -20, 0, 0, 0, 80);
        greenGradient.addColorStop(0, '#90EE90');
        greenGradient.addColorStop(0.7, '#3CB371');
        greenGradient.addColorStop(1, '#2E8B57');
        ctx.fillStyle = greenGradient;
        ctx.beginPath();
        ctx.ellipse(0, 0, 85, 70, 0, 0, Math.PI * 2);
        ctx.fill();

        // Putting surface (smoothest part)
        const puttingGradient = ctx.createRadialGradient(-10, -10, 0, 0, 0, 50);
        puttingGradient.addColorStop(0, '#98FB98');
        puttingGradient.addColorStop(1, '#7CCD7C');
        ctx.fillStyle = puttingGradient;
        ctx.beginPath();
        ctx.ellipse(0, 0, 55, 45, 0, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();

        // Stylized hole
        const hx = hole.holePosition.x;
        const hy = hole.holePosition.y;

        // Hole shadow/depth
        ctx.fillStyle = '#1a1a1a';
        ctx.beginPath();
        ctx.ellipse(hx, hy + 2, 18, 14, 0, 0, Math.PI * 2);
        ctx.fill();

        // Hole opening with gradient for depth
        const holeGradient = ctx.createRadialGradient(hx, hy, 0, hx, hy, 15);
        holeGradient.addColorStop(0, '#000000');
        holeGradient.addColorStop(0.7, '#1a1a1a');
        holeGradient.addColorStop(1, '#333333');
        ctx.fillStyle = holeGradient;
        ctx.beginPath();
        ctx.ellipse(hx, hy, 15, 12, 0, 0, Math.PI * 2);
        ctx.fill();

        // Hole rim (white cup edge)
        ctx.strokeStyle = '#FFFFFF';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.ellipse(hx, hy, 15, 12, 0, 0, Math.PI * 2);
        ctx.stroke();

        // Stylized flagstick with cartoon 3D effect
        // Flagstick shadow
        ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
        ctx.lineWidth = 6;
        ctx.beginPath();
        ctx.moveTo(hx + 3, hy);
        ctx.lineTo(hx + 3, hy - 70);
        ctx.stroke();

        // Main flagstick
        const poleGradient = ctx.createLinearGradient(hx - 3, 0, hx + 3, 0);
        poleGradient.addColorStop(0, '#FFE4B5');
        poleGradient.addColorStop(0.5, '#FAFAD2');
        poleGradient.addColorStop(1, '#DAA520');
        ctx.strokeStyle = poleGradient;
        ctx.lineWidth = 5;
        ctx.lineCap = 'round';
        ctx.beginPath();
        ctx.moveTo(hx, hy);
        ctx.lineTo(hx, hy - 75);
        ctx.stroke();

        // Stylized flag with animated wave effect - follows wind direction
        ctx.save();
        ctx.translate(hx, hy - 75);

        // Get wind direction and flip flag accordingly
        const windDir = WindSystem.direction || 0;
        const windSpeed = WindSystem.speed || 0;
        const windX = Math.cos(windDir);
        const flipFlag = windX < 0; // Flip if wind blowing left

        // Scale wave amplitude by wind speed (more wind = more wave)
        const baseAmplitude = 2;
        const windAmplitude = Math.min(windSpeed / 5, 3); // Max extra 3px from wind
        const waveAmplitude = baseAmplitude + windAmplitude;

        // Wave animation parameters
        const waveSpeed = 3 + windSpeed * 0.2; // Faster wave with more wind
        const wave1 = Math.sin(animationTime * waveSpeed * Math.PI * 2) * waveAmplitude;
        const wave2 = Math.sin(animationTime * waveSpeed * Math.PI * 2 + 1) * waveAmplitude;
        const wave3 = Math.sin(animationTime * waveSpeed * Math.PI * 2 + 2) * waveAmplitude;

        // Flip flag based on wind direction
        if (flipFlag) {
          ctx.scale(-1, 1);
        }

        // Flag shadow (with wave)
        ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
        ctx.beginPath();
        ctx.moveTo(2, 2);
        ctx.quadraticCurveTo(18, 8 + wave1 * 0.5, 30 + wave2, 4 + wave1);
        ctx.quadraticCurveTo(22, 17 + wave2 * 0.5, 30 + wave3, 27 + wave2);
        ctx.quadraticCurveTo(15, 22 + wave3 * 0.5, 2, 27);
        ctx.closePath();
        ctx.fill();

        // Flag main color with gradient
        const flagGradient = ctx.createLinearGradient(0, 0, 28, 25);
        flagGradient.addColorStop(0, '#FF4757');
        flagGradient.addColorStop(0.5, '#FF6B81');
        flagGradient.addColorStop(1, '#EE3B4D');
        ctx.fillStyle = flagGradient;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.quadraticCurveTo(15, 5 + wave1 * 0.5, 28 + wave2, 2 + wave1);
        ctx.quadraticCurveTo(20, 15 + wave2 * 0.5, 28 + wave3, 25 + wave2);
        ctx.quadraticCurveTo(12, 20 + wave3 * 0.5, 0, 25);
        ctx.closePath();
        ctx.fill();

        // Flag outline
        ctx.strokeStyle = '#CC2936';
        ctx.lineWidth = 2;
        ctx.stroke();

        // Flag highlight (with wave)
        ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
        ctx.beginPath();
        ctx.moveTo(3, 3);
        ctx.quadraticCurveTo(12, 6 + wave1 * 0.3, 20 + wave2 * 0.5, 4 + wave1 * 0.5);
        ctx.quadraticCurveTo(14, 10 + wave2 * 0.3, 8, 12);
        ctx.quadraticCurveTo(5, 8, 3, 3);
        ctx.fill();

        // Ball on top of flagstick
        ctx.beginPath();
        ctx.arc(0, -3, 4, 0, Math.PI * 2);
        ctx.fillStyle = '#FFD700';
        ctx.fill();
        ctx.strokeStyle = '#DAA520';
        ctx.lineWidth = 1;
        ctx.stroke();

        ctx.restore();
      },

      drawCrowd(hole) {
        const ctx = this.ctx;
        const canvasW = this.canvas.width;
        const canvasH = this.canvas.height;

        // Crowd colors (muted, tournament-appropriate)
        const shirtColors = ['#3A5A8B', '#8B4A4A', '#4A7A4A', '#7A6A4A', '#5A4A7A', '#4A6A7A'];
        const skinTones = ['#FFDAB9', '#DEB887', '#CD853F', '#A0522D'];

        // Draw spectators along a horizontal line at screen edge
        const drawEdgeCrowd = (startX, endX, y, rowCount, seedBase, facingUp) => {
          const spacing = 12;
          const count = Math.floor((endX - startX) / spacing);

          for (let row = 0; row < rowCount; row++) {
            const rowY = facingUp ? y - row * 10 : y + row * 10;
            const scale = 0.7 - row * 0.08;

            for (let i = 0; i < count; i++) {
              const seed = (seedBase + row * 100 + i * 13) % 1000;
              const x = startX + i * spacing + (row % 2) * 6;

              if (x > endX - 5) continue;

              // Simple spectator - just head and shoulders
              ctx.fillStyle = shirtColors[seed % shirtColors.length];
              const bodyH = 8 * scale;
              const bodyW = 6 * scale;
              ctx.fillRect(x - bodyW/2, rowY, bodyW, bodyH);

              // Head
              ctx.fillStyle = skinTones[(seed * 3) % skinTones.length];
              ctx.beginPath();
              ctx.arc(x, rowY - 2 * scale, 4 * scale, 0, Math.PI * 2);
              ctx.fill();
            }
          }
        };

        // Draw rope barrier
        const drawRope = (x1, y1, x2, y2) => {
          // Rope posts
          ctx.fillStyle = '#8B4513';
          ctx.fillRect(x1 - 2, y1 - 15, 4, 20);
          ctx.fillRect(x2 - 2, y2 - 15, 4, 20);

          // Rope
          ctx.strokeStyle = '#DAA520';
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.moveTo(x1, y1 - 8);
          // Slight sag in the rope
          const midX = (x1 + x2) / 2;
          const midY = ((y1 + y2) / 2) - 5 + 8;
          ctx.quadraticCurveTo(midX, midY, x2, y2 - 8);
          ctx.stroke();
        };

        // Top edge crowd (behind rope)
        const topY = 25;
        drawRope(20, topY + 20, canvasW - 20, topY + 20);
        drawEdgeCrowd(25, canvasW - 25, topY, 2, 123, false);

        // Bottom edge crowd (behind rope)
        const bottomY = canvasH - 15;
        drawRope(20, bottomY - 15, canvasW - 20, bottomY - 15);
        drawEdgeCrowd(25, canvasW - 25, bottomY, 2, 456, true);
      },

      drawObstacles(obstacles) {
        const ctx = this.ctx;

        for (const obstacle of obstacles) {
          if (obstacle.type === 'sand') {
            // Stylized sand bunker with organic shape (original style)
            ctx.save();
            ctx.translate(obstacle.x, obstacle.y);

            // Bunker shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
            ctx.beginPath();
            ctx.ellipse(4, 5, obstacle.radius * 1.1, obstacle.radius * 0.85, 0.1, 0, Math.PI * 2);
            ctx.fill();

            // Bunker rim (darker edge)
            ctx.fillStyle = '#C4A35A';
            ctx.beginPath();
            ctx.ellipse(0, 0, obstacle.radius * 1.05, obstacle.radius * 0.8, 0.1, 0, Math.PI * 2);
            ctx.fill();

            // Main sand with gradient
            const sandGradient = ctx.createRadialGradient(-5, -5, 0, 0, 0, obstacle.radius);
            sandGradient.addColorStop(0, '#F5DEB3');
            sandGradient.addColorStop(0.5, '#E6D5A8');
            sandGradient.addColorStop(1, '#D4B896');
            ctx.fillStyle = sandGradient;
            ctx.beginPath();
            ctx.ellipse(0, 0, obstacle.radius * 0.95, obstacle.radius * 0.7, 0.1, 0, Math.PI * 2);
            ctx.fill();

            // Sand texture - small dots
            ctx.fillStyle = 'rgba(139, 119, 101, 0.4)';
            for (let i = 0; i < 12; i++) {
              const seed = (i * 137 + Math.floor(obstacle.x)) % 100;
              const angle = (seed / 100) * Math.PI * 2;
              const dist = ((i * 73) % 70) / 100 * obstacle.radius * 0.7;
              const dotX = Math.cos(angle) * dist;
              const dotY = Math.sin(angle) * dist * 0.7;
              const dotSize = 2 + (i % 3);
              ctx.beginPath();
              ctx.arc(dotX, dotY, dotSize, 0, Math.PI * 2);
              ctx.fill();
            }

            // Highlight
            ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.beginPath();
            ctx.ellipse(-obstacle.radius * 0.3, -obstacle.radius * 0.2, obstacle.radius * 0.4, obstacle.radius * 0.25, -0.3, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();

          } else if (obstacle.type === 'water') {
            // Stylized water hazard with cartoon look
            ctx.save();

            const cx = obstacle.x + obstacle.width / 2;
            const cy = obstacle.y + obstacle.height / 2;

            // Water shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
            ctx.beginPath();
            ctx.ellipse(cx + 4, cy + 5, obstacle.width / 2 + 5, obstacle.height / 2 + 3, 0, 0, Math.PI * 2);
            ctx.fill();

            // Water base with gradient
            const waterGradient = ctx.createRadialGradient(cx - 10, cy - 10, 0, cx, cy, obstacle.width / 2);
            waterGradient.addColorStop(0, '#5BC0EB');
            waterGradient.addColorStop(0.6, '#3498DB');
            waterGradient.addColorStop(1, '#2171A5');
            ctx.fillStyle = waterGradient;
            ctx.beginPath();
            ctx.ellipse(cx, cy, obstacle.width / 2, obstacle.height / 2, 0, 0, Math.PI * 2);
            ctx.fill();

            // Water outline
            ctx.strokeStyle = '#1A5276';
            ctx.lineWidth = 3;
            ctx.stroke();

            // Cartoon sparkle/reflection
            ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
            ctx.beginPath();
            ctx.ellipse(cx - obstacle.width * 0.2, cy - obstacle.height * 0.15, obstacle.width * 0.15, obstacle.height * 0.1, -0.4, 0, Math.PI * 2);
            ctx.fill();

            // Small sparkle
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.beginPath();
            ctx.arc(cx - obstacle.width * 0.25, cy - obstacle.height * 0.2, 3, 0, Math.PI * 2);
            ctx.fill();

            // Ripple lines
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.ellipse(cx + 5, cy + 5, obstacle.width * 0.25, obstacle.height * 0.15, 0, 0, Math.PI * 2);
            ctx.stroke();

            ctx.restore();

          } else if (obstacle.type === 'tree') {
            // Stylized cartoon tree with better grounding
            ctx.save();
            ctx.translate(obstacle.x, obstacle.y);

            const r = obstacle.radius;

            // Large tree shadow on ground (more spread out)
            ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
            ctx.beginPath();
            ctx.ellipse(10, 20, r * 1.2, r * 0.45, 0.1, 0, Math.PI * 2);
            ctx.fill();

            // Ground dirt patch around base
            ctx.fillStyle = 'rgba(101, 67, 33, 0.4)';
            ctx.beginPath();
            ctx.ellipse(0, 28, 18, 8, 0, 0, Math.PI * 2);
            ctx.fill();

            // Grass tufts around base
            ctx.strokeStyle = '#2E7D32';
            ctx.lineWidth = 2;
            for (let i = 0; i < 6; i++) {
              const angle = (i / 6) * Math.PI * 2;
              const gx = Math.cos(angle) * 14;
              const gy = 26 + Math.sin(angle) * 5;
              ctx.beginPath();
              ctx.moveTo(gx, gy);
              ctx.quadraticCurveTo(gx + (Math.random() - 0.5) * 4, gy - 8, gx + (Math.random() - 0.5) * 3, gy - 12);
              ctx.stroke();
            }

            // Trunk shadow
            ctx.fillStyle = '#5D4037';
            ctx.beginPath();
            ctx.moveTo(8, 5);
            ctx.lineTo(12, 30);
            ctx.lineTo(4, 30);
            ctx.closePath();
            ctx.fill();

            // Main trunk with gradient
            const trunkGradient = ctx.createLinearGradient(-8, 0, 8, 0);
            trunkGradient.addColorStop(0, '#8B5A2B');
            trunkGradient.addColorStop(0.3, '#A0522D');
            trunkGradient.addColorStop(0.7, '#8B4513');
            trunkGradient.addColorStop(1, '#654321');
            ctx.fillStyle = trunkGradient;
            ctx.beginPath();
            ctx.moveTo(-6, 0);
            ctx.lineTo(-10, 28);
            ctx.lineTo(10, 28);
            ctx.lineTo(6, 0);
            ctx.closePath();
            ctx.fill();

            // Trunk outline
            ctx.strokeStyle = '#3E2723';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Trunk detail lines
            ctx.strokeStyle = 'rgba(62, 39, 35, 0.5)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(-2, 5);
            ctx.lineTo(-3, 25);
            ctx.moveTo(3, 8);
            ctx.lineTo(4, 22);
            ctx.stroke();

            // Foliage layers (back to front for depth)
            // Back layer
            const foliageGradient1 = ctx.createRadialGradient(-5, -r - 5, 0, 0, -r / 2, r * 1.2);
            foliageGradient1.addColorStop(0, '#43A047');
            foliageGradient1.addColorStop(1, '#1B5E20');
            ctx.fillStyle = foliageGradient1;
            ctx.beginPath();
            ctx.arc(-8, -r * 0.6, r * 0.7, 0, Math.PI * 2);
            ctx.fill();

            ctx.beginPath();
            ctx.arc(10, -r * 0.5, r * 0.65, 0, Math.PI * 2);
            ctx.fill();

            // Middle layer
            const foliageGradient2 = ctx.createRadialGradient(-3, -r - 3, 0, 0, -r / 2, r);
            foliageGradient2.addColorStop(0, '#66BB6A');
            foliageGradient2.addColorStop(1, '#2E7D32');
            ctx.fillStyle = foliageGradient2;
            ctx.beginPath();
            ctx.arc(0, -r * 0.8, r * 0.85, 0, Math.PI * 2);
            ctx.fill();

            // Front layer (brightest)
            const foliageGradient3 = ctx.createRadialGradient(-5, -r - 8, 0, 0, -r * 0.7, r * 0.7);
            foliageGradient3.addColorStop(0, '#81C784');
            foliageGradient3.addColorStop(1, '#4CAF50');
            ctx.fillStyle = foliageGradient3;
            ctx.beginPath();
            ctx.arc(-3, -r, r * 0.6, 0, Math.PI * 2);
            ctx.fill();

            // Foliage outline
            ctx.strokeStyle = '#1B5E20';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(0, -r * 0.8, r * 0.85, 0, Math.PI * 2);
            ctx.stroke();

            // Highlight spots
            ctx.fillStyle = 'rgba(255, 255, 255, 0.25)';
            ctx.beginPath();
            ctx.arc(-r * 0.3, -r * 1.1, r * 0.2, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();

          } else if (obstacle.type === 'rock') {
            // Stylized cartoon rock with better grounding
            ctx.save();
            ctx.translate(obstacle.x, obstacle.y);

            const r = obstacle.radius;

            // Larger ground shadow (more visible)
            ctx.fillStyle = 'rgba(0, 0, 0, 0.25)';
            ctx.beginPath();
            ctx.ellipse(6, r * 0.9, r * 1.1, r * 0.4, 0.1, 0, Math.PI * 2);
            ctx.fill();

            // Ground dirt/grass around base
            ctx.fillStyle = 'rgba(101, 67, 33, 0.35)';
            ctx.beginPath();
            ctx.ellipse(0, r * 0.6, r * 0.8, r * 0.3, 0, 0, Math.PI * 2);
            ctx.fill();

            // Small grass tufts around rock
            ctx.strokeStyle = '#3D8B37';
            ctx.lineWidth = 1.5;
            for (let i = 0; i < 5; i++) {
              const angle = (i / 5) * Math.PI + 0.3;
              const gx = Math.cos(angle) * r * 0.7;
              const gy = r * 0.5 + Math.sin(angle) * r * 0.2;
              ctx.beginPath();
              ctx.moveTo(gx, gy);
              ctx.lineTo(gx + (i % 2 ? 2 : -2), gy - 6);
              ctx.stroke();
            }

            // Main rock shape (irregular polygon for cartoon look)
            const rockGradient = ctx.createRadialGradient(-r * 0.3, -r * 0.3, 0, 0, 0, r * 1.2);
            rockGradient.addColorStop(0, '#A0A0A0');
            rockGradient.addColorStop(0.5, '#787878');
            rockGradient.addColorStop(1, '#4A4A4A');
            ctx.fillStyle = rockGradient;

            ctx.beginPath();
            ctx.moveTo(-r * 0.8, r * 0.4);
            ctx.lineTo(-r * 0.95, -r * 0.1);
            ctx.lineTo(-r * 0.6, -r * 0.65);
            ctx.lineTo(-r * 0.1, -r * 0.8);
            ctx.lineTo(r * 0.5, -r * 0.7);
            ctx.lineTo(r * 0.85, -r * 0.3);
            ctx.lineTo(r * 0.9, r * 0.2);
            ctx.lineTo(r * 0.5, r * 0.55);
            ctx.lineTo(-r * 0.3, r * 0.6);
            ctx.closePath();
            ctx.fill();

            // Rock outline
            ctx.strokeStyle = '#2A2A2A';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Rock highlight (top-left)
            ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.beginPath();
            ctx.moveTo(-r * 0.5, -r * 0.35);
            ctx.lineTo(-r * 0.25, -r * 0.6);
            ctx.lineTo(r * 0.15, -r * 0.55);
            ctx.lineTo(r * 0.05, -r * 0.2);
            ctx.lineTo(-r * 0.35, -r * 0.1);
            ctx.closePath();
            ctx.fill();

            // Moss/lichen patches (greenish spots)
            ctx.fillStyle = 'rgba(85, 107, 47, 0.4)';
            ctx.beginPath();
            ctx.arc(-r * 0.4, r * 0.1, r * 0.15, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(r * 0.3, -r * 0.15, r * 0.12, 0, Math.PI * 2);
            ctx.fill();

            // Crack details
            ctx.strokeStyle = 'rgba(33, 33, 33, 0.6)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(-r * 0.15, -r * 0.35);
            ctx.lineTo(r * 0.05, r * 0.15);
            ctx.lineTo(r * 0.25, r * 0.05);
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(r * 0.25, -r * 0.35);
            ctx.lineTo(r * 0.35, r * 0.05);
            ctx.stroke();

            ctx.restore();
          }
        }
      },

      drawBall(ball) {
        const ctx = this.ctx;
        // Check both standard and premium colors
        const colors = BallColors[ball.color] || PremiumBallColors[ball.color] || BallColors.white;
        const isAnimated = PremiumBallColors[ball.color]?.animated;

        // Calculate shadow properties based on airborne state
        const baseHeight = ball.isAirborne ? 1.5 : 0;
        const heightFactor = baseHeight + (ball.isAirborne ? Math.abs(ball.velocityY || 0) / 400 : 0);
        const shadowOffset = 4 + heightFactor * 3;
        const shadowScale = 1 + heightFactor * 0.5;
        const shadowOpacity = Math.max(0.1, 0.35 - heightFactor * 0.1);

        if (ball.inHole && ball.holeProgress !== undefined) {
          const fadeProgress = ball.holeProgress;
          if (fadeProgress >= 1) return;

          // Draw shadow (fading with ball)
          ctx.save();
          ctx.globalAlpha = (1 - fadeProgress) * shadowOpacity;
          ctx.fillStyle = 'rgba(0, 0, 0, 1)';
          ctx.beginPath();
          ctx.ellipse(ball.x + shadowOffset, ball.y + shadowOffset, 8 * shadowScale, 5 * shadowScale, 0, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();

          ctx.save();
          ctx.globalAlpha = 1 - fadeProgress;
          ctx.translate(ball.x, ball.y);
          ctx.rotate(ball.rotation);

          const scale = 1 - (fadeProgress * 0.5);
          ctx.scale(scale, scale);

          let holeGradient;
          if (isAnimated) {
            const time = Date.now() / 1000;
            if (isAnimated === 'galaxy') {
              holeGradient = ctx.createRadialGradient(-2, -2, 0, 0, 0, 8);
              const hue = (time * 30) % 360;
              holeGradient.addColorStop(0, `hsl(${hue}, 70%, 70%)`);
              holeGradient.addColorStop(0.5, `hsl(${(hue + 60) % 360}, 80%, 40%)`);
              holeGradient.addColorStop(1, `hsl(${(hue + 120) % 360}, 90%, 20%)`);
            } else if (isAnimated === 'fire') {
              const flicker = Math.sin(time * 10) * 0.2 + 0.8;
              holeGradient = ctx.createRadialGradient(-2, -2, 0, 0, 0, 8);
              holeGradient.addColorStop(0, `rgba(255, 255, 100, ${flicker})`);
              holeGradient.addColorStop(0.4, '#FF6347');
              holeGradient.addColorStop(1, '#8B0000');
            } else if (isAnimated === 'rainbow') {
              const hue = (time * 50) % 360;
              holeGradient = ctx.createRadialGradient(-2, -2, 0, 0, 0, 8);
              holeGradient.addColorStop(0, `hsl(${hue}, 100%, 80%)`);
              holeGradient.addColorStop(1, `hsl(${(hue + 180) % 360}, 100%, 50%)`);
            }
          } else {
            holeGradient = ctx.createRadialGradient(-2, -2, 0, 0, 0, 8);
            holeGradient.addColorStop(0, colors.highlight);
            holeGradient.addColorStop(1, colors.base);
          }

          ctx.fillStyle = holeGradient;
          ctx.beginPath();
          ctx.arc(0, 0, 8, 0, Math.PI * 2);
          ctx.fill();

          ctx.strokeStyle = colors.stroke;
          ctx.lineWidth = 0.5;
          ctx.stroke();

          ctx.restore();
          return;
        }

        // Draw ball shadow (ellipse offset to bottom-right for 3D effect)
        ctx.save();
        ctx.globalAlpha = shadowOpacity;
        ctx.fillStyle = 'rgba(0, 0, 0, 1)';
        ctx.beginPath();
        ctx.ellipse(ball.x + shadowOffset, ball.y + shadowOffset, 8 * shadowScale, 5 * shadowScale, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();

        // Draw ball
        ctx.save();
        ctx.translate(ball.x, ball.y);
        ctx.rotate(ball.rotation);

        let gradient;
        if (isAnimated) {
          // Animated ball effects
          const time = Date.now() / 1000;
          if (isAnimated === 'galaxy') {
            // Rotating galaxy swirl effect
            gradient = ctx.createRadialGradient(-2, -2, 0, 0, 0, 8);
            const hue = (time * 30) % 360;
            gradient.addColorStop(0, `hsl(${hue}, 70%, 70%)`);
            gradient.addColorStop(0.5, `hsl(${(hue + 60) % 360}, 80%, 40%)`);
            gradient.addColorStop(1, `hsl(${(hue + 120) % 360}, 90%, 20%)`);
          } else if (isAnimated === 'fire') {
            // Flickering fire effect
            const flicker = Math.sin(time * 10) * 0.2 + 0.8;
            gradient = ctx.createRadialGradient(-2, -2, 0, 0, 0, 8);
            gradient.addColorStop(0, `rgba(255, 255, 100, ${flicker})`);
            gradient.addColorStop(0.4, '#FF6347');
            gradient.addColorStop(1, '#8B0000');
          } else if (isAnimated === 'rainbow') {
            // Shifting rainbow
            const hue = (time * 50) % 360;
            gradient = ctx.createRadialGradient(-2, -2, 0, 0, 0, 8);
            gradient.addColorStop(0, `hsl(${hue}, 100%, 80%)`);
            gradient.addColorStop(1, `hsl(${(hue + 180) % 360}, 100%, 50%)`);
          }
        } else {
          // Standard ball gradient
          gradient = ctx.createRadialGradient(-2, -2, 0, 0, 0, 8);
          gradient.addColorStop(0, colors.highlight);
          gradient.addColorStop(1, colors.base);
        }

        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(0, 0, 8, 0, Math.PI * 2);
        ctx.fill();

        ctx.strokeStyle = colors.stroke;
        ctx.lineWidth = 0.5;
        ctx.stroke();

        ctx.restore();
      },

      drawGuideArrow(swingPreview, ball, selectedClub) {
        const ctx = this.ctx;
        const dx = swingPreview.current.x - swingPreview.start.x;
        const dy = swingPreview.current.y - swingPreview.start.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        const swingPower = Math.min(distance / 150, 1.0); // User's swing 0-100%

        const club = ClubSystem.getClub(selectedClub || 'driver');
        const effectivePower = swingPower * club.maxPower; // Actual ball power

        const arrowLength = effectivePower * 150;
        const angle = Math.atan2(dy, dx) + Math.PI;

        const endX = ball.x + Math.cos(angle) * arrowLength;
        const endY = ball.y + Math.sin(angle) * arrowLength;

        // Color based on user's swing power (0-100%), not club-adjusted power
        const arrowColor = swingPower > 0.8 ? [255, 100, 0] :
                          swingPower > 0.5 ? [255, 200, 0] : [100, 200, 255];

        ctx.strokeStyle = `rgba(${arrowColor[0]}, ${arrowColor[1]}, ${arrowColor[2]}, ${0.4 + effectivePower * 0.4})`;
        ctx.lineWidth = 3 + effectivePower * 5;
        ctx.setLineDash([5, 5]);

        ctx.beginPath();
        ctx.moveTo(ball.x, ball.y);
        ctx.lineTo(endX, endY);
        ctx.stroke();

        ctx.setLineDash([]);

        const arrowSize = 12 + effectivePower * 12;
        ctx.fillStyle = `rgba(${arrowColor[0]}, ${arrowColor[1]}, ${arrowColor[2]}, ${0.6 + effectivePower * 0.4})`;
        ctx.beginPath();
        ctx.moveTo(endX, endY);
        ctx.lineTo(
          endX - arrowSize * Math.cos(angle - Math.PI / 6),
          endY - arrowSize * Math.sin(angle - Math.PI / 6)
        );
        ctx.lineTo(
          endX - arrowSize * Math.cos(angle + Math.PI / 6),
          endY - arrowSize * Math.sin(angle + Math.PI / 6)
        );
        ctx.closePath();
        ctx.fill();

        ctx.font = 'bold 16px Arial';
        ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
        ctx.fillText(`Power: ${Math.round(swingPower * 100)}%`, ball.x + 15, ball.y - 15);
        ctx.fillText(`${club.name}`, ball.x + 15, ball.y - 35);

        const powerBarWidth = 100;
        const powerBarHeight = 10;
        const powerBarX = ball.x - powerBarWidth / 2;
        const powerBarY = ball.y - 55;

        ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
        ctx.fillRect(powerBarX, powerBarY, powerBarWidth, powerBarHeight);

        ctx.fillStyle = `rgba(${arrowColor[0]}, ${arrowColor[1]}, ${arrowColor[2]}, 0.8)`;
        ctx.fillRect(powerBarX, powerBarY, powerBarWidth * swingPower, powerBarHeight);

        ctx.strokeStyle = 'rgba(0, 0, 0, 0.6)';
        ctx.lineWidth = 2;
        ctx.strokeRect(powerBarX, powerBarY, powerBarWidth, powerBarHeight);
      },

      drawStrikeFlash(ball, strikeFlash) {
        const ctx = this.ctx;
        const progress = strikeFlash.progress;
        const alpha = 1 - progress;
        const radius = 15 + progress * 20;

        ctx.save();
        ctx.globalAlpha = alpha * 0.6;

        const gradient = ctx.createRadialGradient(ball.x, ball.y, 0, ball.x, ball.y, radius);
        gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
        gradient.addColorStop(0.5, 'rgba(255, 200, 0, 0.8)');
        gradient.addColorStop(1, 'rgba(255, 100, 0, 0)');

        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(ball.x, ball.y, radius, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();
      }
    };

    // === InputHandler Module (T010 + Mouse Support) ===
    const InputHandler = {
      canvas: null,
      gameEngine: null,
      touchStartPos: null,
      currentTouchPos: null,
      isSwinging: false,

      init(canvas, gameEngine) {
        this.canvas = canvas;
        this.gameEngine = gameEngine;

        canvas.addEventListener('touchstart', (e) => this.onTouchStart(e), { passive: false });
        canvas.addEventListener('touchmove', (e) => this.onTouchMove(e), { passive: false });
        canvas.addEventListener('touchend', (e) => this.onTouchEnd(e), { passive: false });

        canvas.addEventListener('mousedown', (e) => this.onMouseDown(e));
        canvas.addEventListener('mousemove', (e) => this.onMouseMove(e));
        canvas.addEventListener('mouseup', (e) => this.onMouseUp(e));

        const resetBtn = document.getElementById('reset-shot-btn');
        resetBtn.addEventListener('click', () => this.resetShot());
      },

      resetShot() {
        this.touchStartPos = null;
        this.currentTouchPos = null;
        this.isSwinging = false;
        document.getElementById('reset-shot-btn').classList.add('hidden');
      },

      onTouchStart(e) {
        e.preventDefault();
        if (this.gameEngine && this.gameEngine.gameState && this.gameEngine.gameState.ball && this.gameEngine.gameState.ball.isMoving) {
          return;
        }
        const touch = e.touches[0];
        const rect = this.canvas.getBoundingClientRect();
        this.touchStartPos = {
          x: touch.clientX - rect.left,
          y: touch.clientY - rect.top
        };
        this.isSwinging = true;
      },

      onTouchMove(e) {
        e.preventDefault();
        if (!this.isSwinging) return;

        const touch = e.touches[0];
        const rect = this.canvas.getBoundingClientRect();
        this.currentTouchPos = {
          x: touch.clientX - rect.left,
          y: touch.clientY - rect.top
        };

        document.getElementById('reset-shot-btn').classList.remove('hidden');
      },

      onTouchEnd(e) {
        e.preventDefault();
        if (!this.isSwinging) return;

        document.getElementById('reset-shot-btn').classList.add('hidden');

        const swingVector = this.calculateSwingVector();
        if (swingVector && this.gameEngine) {
          this.gameEngine.executeSwing(swingVector);
        }

        this.touchStartPos = null;
        this.currentTouchPos = null;
        this.isSwinging = false;
      },

      onMouseDown(e) {
        if (this.gameEngine && this.gameEngine.gameState && this.gameEngine.gameState.ball && this.gameEngine.gameState.ball.isMoving) {
          return;
        }
        const rect = this.canvas.getBoundingClientRect();
        this.touchStartPos = {
          x: e.clientX - rect.left,
          y: e.clientY - rect.top
        };
        this.isSwinging = true;
      },

      onMouseMove(e) {
        if (!this.isSwinging) return;

        const rect = this.canvas.getBoundingClientRect();
        this.currentTouchPos = {
          x: e.clientX - rect.left,
          y: e.clientY - rect.top
        };

        document.getElementById('reset-shot-btn').classList.remove('hidden');
      },

      onMouseUp(e) {
        if (!this.isSwinging) return;

        document.getElementById('reset-shot-btn').classList.add('hidden');

        const swingVector = this.calculateSwingVector();
        if (swingVector && this.gameEngine) {
          this.gameEngine.executeSwing(swingVector);
        }

        this.touchStartPos = null;
        this.currentTouchPos = null;
        this.isSwinging = false;
      },

      calculateSwingVector() {
        if (!this.touchStartPos || !this.currentTouchPos) return null;

        const dx = this.currentTouchPos.x - this.touchStartPos.x;
        const dy = this.currentTouchPos.y - this.touchStartPos.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        const angle = Math.atan2(dy, dx);

        return {
          power: Math.min(distance / 150, 1.0),
          angle: angle
        };
      },

      getSwingPreview() {
        return this.currentTouchPos && this.touchStartPos ? {
          start: this.touchStartPos,
          current: this.currentTouchPos
        } : null;
      }
    };

    // === WindSystem Module ===
    const WindSystem = {
      direction: 0,      // Angle in radians (0 = right, PI/2 = down, PI = left, etc)
      speed: 0,          // Wind speed in mph
      gustTimer: 0,      // Timer for wind gusts
      gustIntensity: 0,  // Current gust multiplier

      // Generate new wind for a hole
      generateWind(holeNumber) {
        // Wind gets stronger on later holes
        const baseSpeed = 2 + (holeNumber * 0.8);
        const maxSpeed = Math.min(5 + holeNumber * 1.5, 25);

        this.speed = baseSpeed + Math.random() * (maxSpeed - baseSpeed);
        this.direction = Math.random() * Math.PI * 2;
        this.gustTimer = 0;
        this.gustIntensity = 0;

        this.updateUI();
      },

      // Update wind (called each frame for gusts)
      update(deltaTime) {
        // Random gusts
        this.gustTimer -= deltaTime;
        if (this.gustTimer <= 0) {
          this.gustTimer = 2 + Math.random() * 4; // Gust every 2-6 seconds
          this.gustIntensity = Math.random() * 0.5; // Up to 50% stronger
        }

        // Decay gust
        this.gustIntensity *= 0.95;
      },

      // Get wind force to apply to ball
      getWindForce() {
        const effectiveSpeed = this.speed * (1 + this.gustIntensity);
        // Convert mph to pixels/second force (tuned for gameplay)
        const force = effectiveSpeed * 3;

        return {
          x: Math.cos(this.direction) * force,
          y: Math.sin(this.direction) * force
        };
      },

      // Update the wind indicator UI
      updateUI() {
        const indicator = document.getElementById('wind-indicator');
        if (!indicator) return;

        indicator.classList.remove('hidden');

        // Update arrow rotation (rotate to point in wind direction)
        const arrow = indicator.querySelector('.wind-arrow');
        const degrees = (this.direction * 180 / Math.PI);
        arrow.style.transform = `rotate(${degrees}deg)`;

        // Update speed text
        const speedEl = indicator.querySelector('.wind-speed');
        speedEl.textContent = `${Math.round(this.speed)} mph`;

        // Update color class based on speed
        indicator.classList.remove('wind-calm', 'wind-light', 'wind-moderate', 'wind-strong', 'wind-extreme');
        if (this.speed < 5) {
          indicator.classList.add('wind-calm');
        } else if (this.speed < 10) {
          indicator.classList.add('wind-light');
        } else if (this.speed < 15) {
          indicator.classList.add('wind-moderate');
        } else if (this.speed < 20) {
          indicator.classList.add('wind-strong');
        } else {
          indicator.classList.add('wind-extreme');
        }
      },

      // Hide wind indicator
      hide() {
        const indicator = document.getElementById('wind-indicator');
        if (indicator) indicator.classList.add('hidden');
      }
    };

    // === BallTrail System ===
    const BallTrail = {
      positions: [],
      maxLength: 20,
      lastBallPos: null,

      update(ball) {
        if (!ball || !ball.isMoving) {
          // Clear trail when ball stops
          this.positions = [];
          this.lastBallPos = null;
          return;
        }

        // Only add position if ball moved enough
        const minDist = 8;
        if (this.lastBallPos) {
          const dx = ball.x - this.lastBallPos.x;
          const dy = ball.y - this.lastBallPos.y;
          if (dx * dx + dy * dy < minDist * minDist) {
            return;
          }
        }

        this.positions.push({
          x: ball.x,
          y: ball.y,
          age: 0,
          color: ball.color || 'white'
        });

        // Trim to max length
        if (this.positions.length > this.maxLength) {
          this.positions.shift();
        }

        this.lastBallPos = { x: ball.x, y: ball.y };

        // Age all positions
        for (const pos of this.positions) {
          pos.age++;
        }
      },

      draw(ctx) {
        if (this.positions.length < 2) return;

        ctx.save();

        for (let i = 0; i < this.positions.length; i++) {
          const pos = this.positions[i];
          const progress = i / this.positions.length;

          // Fade out and shrink based on age
          const alpha = progress * 0.6;
          const radius = 4 + progress * 6;

          ctx.globalAlpha = alpha;
          ctx.fillStyle = pos.color === 'white' ? '#ffffff' : pos.color;
          ctx.beginPath();
          ctx.arc(pos.x, pos.y, radius, 0, Math.PI * 2);
          ctx.fill();
        }

        ctx.restore();
      },

      clear() {
        this.positions = [];
        this.lastBallPos = null;
      }
    };

    // === Shop System (Golf Bucks & Club Tiers) ===
    const ShopSystem = {
      golfBucks: 0,
      ownedClubs: {}, // { 'driver': 1, 'wood3': 1, ... } - tier level owned (1-3)

      // Tier multipliers for club power
      tierMultipliers: {
        1: 0.7,   // Basic: 70% distance
        2: 0.85,  // Standard: 85% distance
        3: 1.0    // Pro: 100% distance (current clubs)
      },

      // Prices for each club tier upgrade
      clubPrices: {
        driver: { 2: 400, 3: 800 },
        wood3:  { 2: 350, 3: 700 },
        wood5:  { 2: 300, 3: 600 },
        iron4:  { 2: 250, 3: 500 },
        iron5:  { 2: 250, 3: 500 },
        iron6:  { 2: 200, 3: 400 },
        iron7:  { 2: 200, 3: 400 },
        iron8:  { 2: 150, 3: 300 },
        iron9:  { 2: 150, 3: 300 },
        wedge:  { 2: 200, 3: 400 },
        putter: { 2: 300, 3: 600 }
      },

      // Club display names for shop UI
      clubNames: {
        driver: 'Driver',
        wood3: '3 Wood',
        wood5: '5 Wood',
        iron4: '4 Iron',
        iron5: '5 Iron',
        iron6: '6 Iron',
        iron7: '7 Iron',
        iron8: '8 Iron',
        iron9: '9 Iron',
        wedge: 'Wedge',
        putter: 'Putter'
      },

      // Ball skins - free colors are always owned
      ownedBallSkins: ['white', 'yellow', 'orange', 'pink', 'red', 'blue', 'green', 'purple'],

      // Ball skin prices (only premium colors)
      ballSkinPrices: {
        gold: 200,
        chrome: 150,
        neon: 175,
        midnight: 225,
        rose: 175,
        galaxy: 500,
        fire: 500,
        rainbow: 750
      },

      // Ball skin display names
      ballSkinNames: {
        white: 'White', yellow: 'Yellow', orange: 'Orange', pink: 'Pink',
        red: 'Red', blue: 'Blue', green: 'Green', purple: 'Purple',
        gold: 'Gold', chrome: 'Chrome', neon: 'Neon Green', midnight: 'Midnight',
        rose: 'Rose', galaxy: 'Galaxy Swirl', fire: 'Fire Trail', rainbow: 'Rainbow Shift'
      },

      init() {
        this.load();
      },

      load() {
        const data = localStorage.getItem('golf-shop-data');
        if (data) {
          const parsed = JSON.parse(data);
          this.golfBucks = parsed.golfBucks || 0;
          this.ownedClubs = parsed.ownedClubs || {};
          // Load owned ball skins, default to free colors
          if (parsed.ownedBallSkins && parsed.ownedBallSkins.length > 0) {
            this.ownedBallSkins = parsed.ownedBallSkins;
          }
        }
        // Initialize all clubs to tier 1 if not owned
        const allClubIds = Object.keys(this.clubPrices);
        for (const clubId of allClubIds) {
          if (!this.ownedClubs[clubId]) {
            this.ownedClubs[clubId] = 1;
          }
        }
        this.save();
      },

      save() {
        localStorage.setItem('golf-shop-data', JSON.stringify({
          golfBucks: this.golfBucks,
          ownedClubs: this.ownedClubs,
          ownedBallSkins: this.ownedBallSkins
        }));
      },

      getBalance() {
        return this.golfBucks;
      },

      addBucks(amount, reason = '') {
        this.golfBucks += amount;
        this.save();
        this.showEarningsPopup(amount, reason);
        this.updateBalanceDisplay();
      },

      spendBucks(amount) {
        if (this.golfBucks >= amount) {
          this.golfBucks -= amount;
          this.save();
          this.updateBalanceDisplay();
          return true;
        }
        return false;
      },

      canAfford(cost) {
        return this.golfBucks >= cost;
      },

      getOwnedTier(clubId) {
        return this.ownedClubs[clubId] || 1;
      },

      getTierMultiplier(clubId) {
        const tier = this.getOwnedTier(clubId);
        return this.tierMultipliers[tier];
      },

      getClubPrice(clubId, tier) {
        if (this.clubPrices[clubId] && this.clubPrices[clubId][tier]) {
          return this.clubPrices[clubId][tier];
        }
        return 0;
      },

      getNextTierPrice(clubId) {
        const currentTier = this.getOwnedTier(clubId);
        if (currentTier >= 3) return null; // Already maxed
        return this.getClubPrice(clubId, currentTier + 1);
      },

      purchaseClub(clubId) {
        const currentTier = this.getOwnedTier(clubId);
        if (currentTier >= 3) return false; // Already maxed

        const nextTier = currentTier + 1;
        const price = this.getClubPrice(clubId, nextTier);

        if (this.spendBucks(price)) {
          this.ownedClubs[clubId] = nextTier;
          this.save();
          if (AudioManager.playAchievement) AudioManager.playAchievement();

          // Show upgrade notification
          const tierName = nextTier === 2 ? 'Standard' : 'Pro';
          this.showUpgradePopup(this.clubNames[clubId], tierName);

          return true;
        }
        return false;
      },

      // Called directly from button onclick
      upgradeClub(clubId) {
        if (this.purchaseClub(clubId)) {
          this.renderShop();
        }
      },

      // Called directly from button onclick
      buyBallSkin(skinId) {
        if (this.purchaseBallSkin(skinId)) {
          this.renderShop();
        }
      },

      showUpgradePopup(clubName, tierName) {
        const popup = document.createElement('div');
        popup.className = 'upgrade-popup';
        popup.innerHTML = `<span>⬆️</span> ${clubName} upgraded to <strong>${tierName}</strong>!`;
        document.body.appendChild(popup);

        setTimeout(() => popup.classList.add('show'), 10);
        setTimeout(() => {
          popup.classList.remove('show');
          setTimeout(() => popup.remove(), 500);
        }, 2500);
      },

      showEarningsPopup(amount, reason) {
        // Create a brief popup showing earnings
        const popup = document.createElement('div');
        popup.className = 'golf-bucks-popup';
        popup.innerHTML = `+${amount} GB${reason ? '<br><small>' + reason + '</small>' : ''}`;
        document.body.appendChild(popup);

        // Animate and remove
        setTimeout(() => popup.classList.add('show'), 10);
        setTimeout(() => {
          popup.classList.remove('show');
          setTimeout(() => popup.remove(), 500);
        }, 2000);
      },

      // Ball skin methods
      ownsBallSkin(skinId) {
        return this.ownedBallSkins.includes(skinId);
      },

      getBallSkinPrice(skinId) {
        return this.ballSkinPrices[skinId] || 0;
      },

      purchaseBallSkin(skinId) {
        if (this.ownsBallSkin(skinId)) return false; // Already owned

        const price = this.getBallSkinPrice(skinId);
        if (price === 0) return false; // Invalid skin or free

        if (this.spendBucks(price)) {
          this.ownedBallSkins.push(skinId);
          this.save();
          if (AudioManager.playAchievement) AudioManager.playAchievement();

          // Show unlock notification
          const skinName = this.ballSkinNames[skinId] || skinId;
          this.showBallSkinUnlockPopup(skinName);
          return true;
        }
        return false;
      },

      showBallSkinUnlockPopup(skinName) {
        const popup = document.createElement('div');
        popup.className = 'upgrade-popup';
        popup.innerHTML = `<span>🎱</span> Unlocked <strong>${skinName}</strong> ball!`;
        document.body.appendChild(popup);

        setTimeout(() => popup.classList.add('show'), 10);
        setTimeout(() => {
          popup.classList.remove('show');
          setTimeout(() => popup.remove(), 500);
        }, 2500);
      },

      updateBalanceDisplay() {
        const balanceEl = document.getElementById('shop-balance');
        if (balanceEl) {
          balanceEl.textContent = this.golfBucks;
        }
        const menuBalanceEl = document.getElementById('menu-balance');
        if (menuBalanceEl) {
          menuBalanceEl.textContent = this.golfBucks + ' GB';
        }
      },

      renderShop() {
        const container = document.getElementById('shop-clubs-grid');
        if (!container) return;

        container.innerHTML = '';
        const clubOrder = ['driver', 'wood3', 'wood5', 'iron4', 'iron5', 'iron6', 'iron7', 'iron8', 'iron9', 'wedge', 'putter'];

        // Base max distances at tier 3 (pro level)
        const baseDistances = {
          driver: 280, wood3: 252, wood5: 238, iron4: 224, iron5: 210,
          iron6: 196, iron7: 182, iron8: 168, iron9: 154, wedge: 140, putter: 84
        };

        for (const clubId of clubOrder) {
          const tier = this.getOwnedTier(clubId);
          const nextPrice = this.getNextTierPrice(clubId);
          const canBuy = nextPrice !== null && this.canAfford(nextPrice);
          const isMaxed = tier >= 3;

          const card = document.createElement('div');
          let tierClass = '';
          if (tier === 2) tierClass = ' tier-2';
          if (isMaxed) tierClass = ' maxed';
          card.className = 'shop-club-card' + tierClass;
          card.dataset.club = clubId;

          // Tier stars
          const stars = '★'.repeat(tier) + '☆'.repeat(3 - tier);

          // Calculate current max distance based on tier
          const currentDist = Math.round(baseDistances[clubId] * this.tierMultipliers[tier]);

          // Get short label
          let label = clubId.charAt(0).toUpperCase();
          if (clubId === 'driver') label = 'D';
          else if (clubId === 'wood3') label = '3W';
          else if (clubId === 'wood5') label = '5W';
          else if (clubId === 'wedge') label = 'W';
          else if (clubId === 'putter') label = 'P';
          else if (clubId.startsWith('iron')) label = clubId.replace('iron', '');

          card.innerHTML = `
            <div class="shop-club-icon">${label}</div>
            <div class="shop-club-name">${this.clubNames[clubId]}</div>
            <div class="shop-club-tier">${stars}</div>
            <div class="shop-club-distance">${currentDist} yds</div>
            <div class="shop-club-price">${isMaxed ? '✓ MAX' : nextPrice + ' GB'}</div>
            ${isMaxed ? '' : `<button class="shop-buy-btn ${canBuy ? '' : 'disabled'}" data-club="${clubId}" ${canBuy ? '' : 'disabled'} onclick="ShopSystem.upgradeClub('${clubId}')">Upgrade</button>`}
          `;

          container.appendChild(card);
        }

        // Click handlers are set up via event delegation in main init

        // Add animation to just-upgraded club
        if (this.lastUpgradedClub) {
          const upgradedCard = container.querySelector(`[data-club="${this.lastUpgradedClub}"]`);
          if (upgradedCard) {
            upgradedCard.classList.add('just-upgraded');
            setTimeout(() => {
              upgradedCard.classList.remove('just-upgraded');
            }, 600);
          }
          this.lastUpgradedClub = null;
        }

        this.updateBalanceDisplay();
        this.renderBallSkins();
      },

      renderBallSkins() {
        const container = document.getElementById('shop-balls-grid');
        if (!container) return;

        container.innerHTML = '';

        // All ball skins: free colors first, then premium
        const freeSkins = ['white', 'yellow', 'orange', 'pink', 'red', 'blue', 'green', 'purple'];
        const premiumSkins = Object.keys(this.ballSkinPrices);
        const allSkins = [...freeSkins, ...premiumSkins];

        for (const skinId of allSkins) {
          const isFree = freeSkins.includes(skinId);
          const isOwned = this.ownsBallSkin(skinId);
          const price = isFree ? 0 : this.getBallSkinPrice(skinId);
          const canBuy = !isOwned && this.canAfford(price);
          const isAnimated = PremiumBallColors[skinId]?.animated;

          const card = document.createElement('div');
          let cardClass = 'shop-ball-card';
          if (isOwned) cardClass += ' owned';
          if (isAnimated) cardClass += ' animated';
          card.className = cardClass;
          card.dataset.skin = skinId;

          // Get colors for preview
          const colors = PremiumBallColors[skinId] || BallColors[skinId] || BallColors.white;
          const gradientStyle = `background: radial-gradient(circle at 30% 30%, ${colors.highlight}, ${colors.base})`;

          const name = this.ballSkinNames[skinId] || skinId;

          card.innerHTML = `
            <div class="shop-ball-preview" style="${gradientStyle}">
              ${isAnimated ? '<div class="animated-indicator">✨</div>' : ''}
            </div>
            <div class="shop-ball-name">${name}</div>
            <div class="shop-ball-price">${isOwned ? '✓ OWNED' : (isFree ? 'FREE' : price + ' GB')}</div>
            ${!isOwned && !isFree ? `<button class="shop-buy-btn ${canBuy ? '' : 'disabled'}" data-skin="${skinId}" ${canBuy ? '' : 'disabled'} onclick="ShopSystem.buyBallSkin('${skinId}')">Buy</button>` : ''}
          `;

          container.appendChild(card);
        }

        // Click handlers are set up via event delegation in main init

        // Add animation to just-unlocked skin
        if (this.lastUnlockedSkin) {
          const unlockedCard = container.querySelector(`[data-skin="${this.lastUnlockedSkin}"]`);
          if (unlockedCard) {
            unlockedCard.classList.add('just-upgraded');
            setTimeout(() => unlockedCard.classList.remove('just-upgraded'), 600);
          }
          this.lastUnlockedSkin = null;
        }
      },

      lastUpgradedClub: null,
      lastUnlockedSkin: null
    };

    // === Achievement System ===
    const AchievementManager = {
      achievements: {
        // Scoring achievements
        firstBirdie: { name: 'First Birdie!', desc: 'Score your first birdie', icon: '🐦', unlocked: false },
        firstEagle: { name: 'Soaring Eagle', desc: 'Score an eagle or better', icon: '🦅', unlocked: false },
        holeInOne: { name: 'ACE!', desc: 'Get a hole in one', icon: '🎯', unlocked: false },
        parStreak: { name: 'Par for the Course', desc: 'Get par or better on 3 holes in a row', icon: '⭐', unlocked: false },
        underPar: { name: 'Under Pressure', desc: 'Finish a round under par', icon: '🏆', unlocked: false },

        // Progress achievements
        firstHole: { name: 'Getting Started', desc: 'Complete your first hole', icon: '⛳', unlocked: false },
        halfway: { name: 'Halfway There', desc: 'Complete 5 holes', icon: '🌟', unlocked: false },
        fullRound: { name: 'Full Round', desc: 'Complete all 9 holes', icon: '🎉', unlocked: false },

        // Special achievements
        longDrive: { name: 'Big Hitter', desc: 'Hit a drive over 280 yards', icon: '💪', unlocked: false },
        sandSave: { name: 'Sandy Save', desc: 'Get par after landing in a bunker', icon: '🏖️', unlocked: false },
        waterRecovery: { name: 'Water Walker', desc: 'Get par after a water hazard', icon: '🌊', unlocked: false },

        // Streak achievements
        threePutts: { name: 'Putting Pro', desc: 'One-putt 3 greens in a round', icon: '🎱', unlocked: false },
        noDouble: { name: 'Steady Eddie', desc: 'Complete a round with no double bogeys', icon: '🛡️', unlocked: false }
      },

      // Track stats for achievements
      stats: {
        parStreak: 0,
        holesCompleted: 0,
        onePutts: 0,
        hadWater: false,
        hadSand: false,
        hasDoubleBogey: false,
        longestDrive: 0
      },

      popupQueue: [],
      isShowing: false,
      popupTimeout: null,

      init() {
        // Ensure popup is hidden on init
        const popup = document.getElementById('achievement-popup');
        if (popup) {
          popup.classList.remove('show');
        }
        this.isShowing = false;
        this.popupQueue = [];
        if (this.popupTimeout) {
          clearTimeout(this.popupTimeout);
          this.popupTimeout = null;
        }

        // Load unlocked achievements from localStorage
        const saved = localStorage.getItem('golf-achievements');
        if (saved) {
          try {
            const unlocked = JSON.parse(saved);
            for (const id of unlocked) {
              if (this.achievements[id]) {
                this.achievements[id].unlocked = true;
              }
            }
          } catch (e) {
            console.error('Failed to load achievements:', e);
          }
        }
      },

      resetRoundStats() {
        this.stats.parStreak = 0;
        this.stats.holesCompleted = 0;
        this.stats.onePutts = 0;
        this.stats.hadWater = false;
        this.stats.hadSand = false;
        this.stats.hasDoubleBogey = false;
      },

      unlock(achievementId) {
        const achievement = this.achievements[achievementId];
        if (!achievement || achievement.unlocked) return false;

        achievement.unlocked = true;
        this.saveToStorage();
        this.queuePopup(achievement);
        AudioManager.playAchievement();

        // Award Golf Bucks for achievement unlock
        ShopSystem.addBucks(200, 'Achievement');

        return true;
      },

      queuePopup(achievement) {
        this.popupQueue.push(achievement);
        if (!this.isShowing) {
          this.showNextPopup();
        }
      },

      showNextPopup() {
        if (this.popupQueue.length === 0) {
          this.isShowing = false;
          return;
        }

        this.isShowing = true;
        const achievement = this.popupQueue.shift();

        const popup = document.getElementById('achievement-popup');
        if (!popup) {
          this.isShowing = false;
          return;
        }

        popup.querySelector('.achievement-icon').textContent = achievement.icon;
        popup.querySelector('.achievement-name').textContent = achievement.name;
        popup.querySelector('.achievement-desc').textContent = achievement.desc;

        popup.classList.add('show');

        // Clear any existing timeout
        if (this.popupTimeout) {
          clearTimeout(this.popupTimeout);
        }

        this.popupTimeout = setTimeout(() => {
          popup.classList.remove('show');
          this.popupTimeout = setTimeout(() => this.showNextPopup(), 500);
        }, 3000);
      },

      saveToStorage() {
        const unlocked = Object.keys(this.achievements)
          .filter(id => this.achievements[id].unlocked);
        localStorage.setItem('golf-achievements', JSON.stringify(unlocked));
      },

      // Called when a hole is completed
      onHoleComplete(holeNumber, strokes, par, wasInWater, wasInSand, putts) {
        const score = strokes - par;

        // First hole
        if (!this.achievements.firstHole.unlocked) {
          this.unlock('firstHole');
        }

        this.stats.holesCompleted++;

        // Halfway
        if (this.stats.holesCompleted >= 5) {
          this.unlock('halfway');
        }

        // Full round
        if (this.stats.holesCompleted >= 9) {
          this.unlock('fullRound');
        }

        // Hole in one
        if (strokes === 1) {
          this.unlock('holeInOne');
        }

        // Eagle or better
        if (score <= -2) {
          this.unlock('firstEagle');
        }

        // Birdie
        if (score === -1) {
          this.unlock('firstBirdie');
        }

        // Par streak
        if (score <= 0) {
          this.stats.parStreak++;
          if (this.stats.parStreak >= 3) {
            this.unlock('parStreak');
          }
        } else {
          this.stats.parStreak = 0;
        }

        // Double bogey check
        if (score >= 2) {
          this.stats.hasDoubleBogey = true;
        }

        // One putt tracking
        if (putts === 1) {
          this.stats.onePutts++;
          if (this.stats.onePutts >= 3) {
            this.unlock('threePutts');
          }
        }

        // Water/Sand recovery
        if (wasInWater && score <= 0) {
          this.unlock('waterRecovery');
        }
        if (wasInSand && score <= 0) {
          this.unlock('sandSave');
        }
      },

      // Called when a drive is hit
      onDriveHit(distanceYards) {
        if (distanceYards > this.stats.longestDrive) {
          this.stats.longestDrive = distanceYards;
        }
        if (distanceYards >= 280) {
          this.unlock('longDrive');
        }
      },

      // Called when round is complete
      onRoundComplete(totalScore) {
        if (totalScore < 0) {
          this.unlock('underPar');
        }
        if (!this.stats.hasDoubleBogey) {
          this.unlock('noDouble');
        }
      }
    };

    // === CourseGenerator Module (T026-T029) ===
    const CourseGenerator = {
      holeTemplates: null,
      rng: null,

      init(seed) {
        this.rng = new SeededRandom(seed);
        this.holeTemplates = this.defineHoleTemplates();
      },

      defineHoleTemplates() {
        // Distances are now in YARDS (real golf distances)
        // Par 3: 150-220 yards, Par 4: 300-450 yards, Par 5: 450-550 yards
        // dogleg: 'none', 'left', 'right' - direction the fairway bends
        // doglegSharp: true for 90° turns, false for gentle curves
        return [
          { holeNumber: 1, par: 3, length: 'short', distanceYards: 185, dogleg: 'none' },
          { holeNumber: 2, par: 4, length: 'medium', distanceYards: 340, dogleg: 'left', doglegSharp: false },
          { holeNumber: 3, par: 3, length: 'short', distanceYards: 165, dogleg: 'none' },
          { holeNumber: 4, par: 5, length: 'long', distanceYards: 480, dogleg: 'right', doglegSharp: true },
          { holeNumber: 5, par: 4, length: 'medium', distanceYards: 295, dogleg: 'none' },
          { holeNumber: 6, par: 4, length: 'medium', distanceYards: 370, dogleg: 'right', doglegSharp: false },
          { holeNumber: 7, par: 3, length: 'short', distanceYards: 200, dogleg: 'none' },
          { holeNumber: 8, par: 5, length: 'long', distanceYards: 465, dogleg: 'left', doglegSharp: true },
          { holeNumber: 9, par: 4, length: 'medium', distanceYards: 355, dogleg: 'left', doglegSharp: false }
        ];
      },

      generateHole(holeNumber, canvasWidth, canvasHeight) {
        const template = this.holeTemplates[holeNumber - 1];

        // Initialize screen scale if not already done
        ScreenScale.init(canvasWidth);
        // Update legacy constant for backwards compatibility
        PIXELS_TO_YARDS = 1 / ScreenScale.pixelsPerYard;

        // Convert yards to pixels for positioning
        const distancePixels = ScreenScale.yardsToPixels(template.distanceYards);

        // Scale tee position margin based on screen size
        const teeMargin = Math.max(50, canvasWidth * 0.05);
        const teeX = teeMargin;
        const teeY = canvasHeight / 2 + this.rng.nextInt(-30, 30);

        // Calculate fairway path based on dogleg
        let fairwayPath = []; // Array of waypoints from tee to green
        let greenX, greenY;

        if (template.dogleg === 'none') {
          // Straight hole
          greenX = Math.min(teeX + distancePixels, canvasWidth - teeMargin);
          greenY = canvasHeight / 2 + this.rng.nextInt(-60, 60);
          fairwayPath = [
            { x: teeX, y: teeY },
            { x: greenX, y: greenY }
          ];
        } else {
          // Dogleg hole - create bend point
          const bendDistance = template.doglegSharp ? 0.45 : 0.55; // Where the turn happens
          const bendAmount = template.doglegSharp ? 120 : 70; // How far off-center
          const bendDir = template.dogleg === 'left' ? -1 : 1;

          // First segment goes mostly horizontal with slight vertical offset
          const bendX = teeX + distancePixels * bendDistance;
          const bendY = teeY + bendDir * bendAmount;

          // Clamp bend point to stay on screen
          const clampedBendY = Math.max(80, Math.min(canvasHeight - 80, bendY));

          // Green position - continue from bend
          greenX = Math.min(teeX + distancePixels, canvasWidth - teeMargin);
          // Green goes opposite direction from bend to create the turn
          greenY = clampedBendY - bendDir * (template.doglegSharp ? 60 : 30);
          greenY = Math.max(80, Math.min(canvasHeight - 80, greenY));

          fairwayPath = [
            { x: teeX, y: teeY },
            { x: bendX, y: clampedBendY },
            { x: greenX, y: greenY }
          ];
        }

        const hole = {
          holeNumber: template.holeNumber,
          par: template.par,
          length: template.length,
          distanceYards: template.distanceYards,
          dogleg: template.dogleg,
          doglegSharp: template.doglegSharp || false,
          fairwayPath: fairwayPath, // Waypoints for drawing curved fairway
          teePosition: { x: teeX, y: teeY },
          greenPosition: { x: greenX, y: greenY },
          holePosition: { x: greenX, y: greenY },
          obstacles: this.placeObstaclesWithDogleg(template, fairwayPath, canvasWidth, canvasHeight)
        };

        return hole;
      },

      placeObstacles(template, teeX, teeY, greenX, greenY, canvasWidth, canvasHeight) {
        const obstacles = [];

        // Calculate fairway direction and perpendicular
        const fairwayDx = greenX - teeX;
        const fairwayDy = greenY - teeY;
        const fairwayLength = Math.sqrt(fairwayDx * fairwayDx + fairwayDy * fairwayDy);
        const fairwayNormX = fairwayDx / fairwayLength;
        const fairwayNormY = fairwayDy / fairwayLength;

        // Perpendicular direction (for placing obstacles to sides of fairway)
        const perpX = -fairwayNormY;
        const perpY = fairwayNormX;

        // Helper to check if position overlaps existing obstacles
        const overlapsExisting = (x, y, radius) => {
          for (const obs of obstacles) {
            const obsRadius = obs.shape === 'rectangle'
              ? Math.max(obs.width, obs.height) / 2 + 10
              : obs.radius + 10;
            const dist = Math.sqrt((x - obs.x) ** 2 + (y - obs.y) ** 2);
            const minDist = radius + obsRadius + 15; // 15px buffer between obstacles
            if (dist < minDist) return true;
          }
          return false;
        };

        // Helper to check if position is valid (not too close to tee/green, on screen)
        const isValidPosition = (x, y, radius) => {
          const distFromTee = Math.sqrt((x - teeX) ** 2 + (y - teeY) ** 2);
          const distFromGreen = Math.sqrt((x - greenX) ** 2 + (y - greenY) ** 2);
          const margin = 50;
          return distFromTee > 80 &&
                 distFromGreen > 100 &&
                 x > margin && x < canvasWidth - margin &&
                 y > margin && y < canvasHeight - margin;
        };

        // Helper to try placing an obstacle of a specific type
        const tryPlaceObstacle = (type, minDist, maxDist, sideOnly, closerToCenter) => {
          for (let attempt = 0; attempt < 20; attempt++) {
            const distAlongFairway = minDist + this.rng.next() * (maxDist - minDist);
            const baseX = teeX + fairwayDx * distAlongFairway;
            const baseY = teeY + fairwayDy * distAlongFairway;

            let perpOffset;
            if (sideOnly) {
              perpOffset = (this.rng.next() < 0.5 ? -1 : 1) * (60 + this.rng.nextInt(0, 80));
            } else if (closerToCenter) {
              // Place closer to the fairway center line for more challenge
              perpOffset = this.rng.nextInt(-70, 70);
            } else {
              perpOffset = this.rng.nextInt(-100, 100);
            }

            const x = baseX + perpX * perpOffset;
            const y = baseY + perpY * perpOffset;

            let radius, width, height, shape;
            if (type === 'water') {
              width = this.rng.nextInt(80, 110);
              height = this.rng.nextInt(50, 70);
              radius = Math.max(width, height) / 2;
              shape = 'rectangle';
            } else if (type === 'sand') {
              // Variable bunker sizes - greenside bunkers (closer to green) are larger
              const isGreenside = distAlongFairway > 0.6;
              if (isGreenside) {
                radius = this.rng.nextInt(45, 70);  // Large greenside bunkers
              } else {
                radius = this.rng.nextInt(35, 55);  // Medium fairway bunkers
              }
              width = 0;
              height = 0;
              shape = 'circle';
            } else if (type === 'tree') {
              radius = this.rng.nextInt(24, 32);
              width = 0;
              height = 0;
              shape = 'circle';
            } else { // rock
              radius = this.rng.nextInt(16, 26);
              width = 0;
              height = 0;
              shape = 'circle';
            }

            if (isValidPosition(x, y, radius) && !overlapsExisting(x, y, radius)) {
              obstacles.push({ type, x, y, radius, width, height, shape });
              return true;
            }
          }
          return false;
        };

        // === GUARANTEED MINIMUM OBSTACLES ===

        // 2 trees minimum - one on each side of fairway in early-mid section
        tryPlaceObstacle('tree', 0.25, 0.45, true, false);  // Left or right side
        tryPlaceObstacle('tree', 0.35, 0.55, true, false);  // Other side

        // 2-3 rocks minimum - scattered along fairway
        tryPlaceObstacle('rock', 0.20, 0.40, false, false);
        tryPlaceObstacle('rock', 0.45, 0.65, false, true);  // Mid fairway, closer to center
        if (this.rng.next() < 0.6) {
          tryPlaceObstacle('rock', 0.55, 0.75, false, false);
        }

        // 1 sand bunker minimum - near the green approach
        tryPlaceObstacle('sand', 0.65, 0.85, false, true);  // Closer to center for challenge

        // === ADDITIONAL RANDOM OBSTACLES FOR DIFFICULTY ===

        // Extra obstacles based on hole length
        const extraCount = template.length === 'short' ? this.rng.nextInt(1, 2) :
                          template.length === 'medium' ? this.rng.nextInt(2, 3) :
                          this.rng.nextInt(2, 4);

        for (let i = 0; i < extraCount; i++) {
          const rand = this.rng.next();
          let type, minD, maxD, side, center;

          if (rand < 0.25) {
            // Extra tree
            type = 'tree';
            minD = 0.30;
            maxD = 0.70;
            side = this.rng.next() < 0.5;
            center = false;
          } else if (rand < 0.45) {
            // Extra rock in play area
            type = 'rock';
            minD = 0.35;
            maxD = 0.75;
            side = false;
            center = true;  // More challenging - in the way!
          } else if (rand < 0.70) {
            // Extra sand bunker
            type = 'sand';
            minD = 0.50;
            maxD = 0.80;
            side = false;
            center = this.rng.next() < 0.6;
          } else {
            // Water hazard - dangerous!
            type = 'water';
            minD = 0.40;
            maxD = 0.65;
            side = false;
            center = this.rng.next() < 0.4;  // Sometimes in the way
          }

          tryPlaceObstacle(type, minD, maxD, side, center);
        }

        // Sort obstacles for proper draw order (water first, then sand, then trees/rocks)
        const typeOrder = { water: 0, sand: 1, rock: 2, tree: 3 };
        obstacles.sort((a, b) => typeOrder[a.type] - typeOrder[b.type]);

        return obstacles;
      },

      // New obstacle placement that follows dogleg fairway path
      placeObstaclesWithDogleg(template, fairwayPath, canvasWidth, canvasHeight) {
        const obstacles = [];
        const tee = fairwayPath[0];
        const green = fairwayPath[fairwayPath.length - 1];
        const hasDogleg = fairwayPath.length > 2;
        const bend = hasDogleg ? fairwayPath[1] : null;

        // Helper to get point along fairway path at position t (0-1)
        const getPointOnFairway = (t) => {
          if (!hasDogleg) {
            return {
              x: tee.x + (green.x - tee.x) * t,
              y: tee.y + (green.y - tee.y) * t
            };
          }
          // Two segments: tee->bend (0 to 0.5), bend->green (0.5 to 1)
          if (t < 0.5) {
            const segT = t * 2;
            return {
              x: tee.x + (bend.x - tee.x) * segT,
              y: tee.y + (bend.y - tee.y) * segT
            };
          } else {
            const segT = (t - 0.5) * 2;
            return {
              x: bend.x + (green.x - bend.x) * segT,
              y: bend.y + (green.y - bend.y) * segT
            };
          }
        };

        // Helper to get perpendicular direction at point t
        const getPerpAtT = (t) => {
          let dx, dy;
          if (!hasDogleg) {
            dx = green.x - tee.x;
            dy = green.y - tee.y;
          } else if (t < 0.5) {
            dx = bend.x - tee.x;
            dy = bend.y - tee.y;
          } else {
            dx = green.x - bend.x;
            dy = green.y - bend.y;
          }
          const len = Math.sqrt(dx * dx + dy * dy);
          return { x: -dy / len, y: dx / len };
        };

        // Helper to check valid position
        const isValidPosition = (x, y, radius) => {
          const distFromTee = Math.sqrt((x - tee.x) ** 2 + (y - tee.y) ** 2);
          const distFromGreen = Math.sqrt((x - green.x) ** 2 + (y - green.y) ** 2);
          const margin = 40;
          return distFromTee > 70 &&
                 distFromGreen > 90 &&
                 x > margin && x < canvasWidth - margin &&
                 y > margin && y < canvasHeight - margin;
        };

        // Helper to check overlap
        const overlapsExisting = (x, y, radius) => {
          for (const obs of obstacles) {
            const obsRadius = obs.shape === 'rectangle'
              ? Math.max(obs.width, obs.height) / 2 + 10
              : obs.radius + 10;
            const dist = Math.sqrt((x - obs.x) ** 2 + (y - obs.y) ** 2);
            if (dist < radius + obsRadius + 12) return true;
          }
          return false;
        };

        // === STRATEGIC CORNER TREE at dogleg ===
        if (hasDogleg && template.dogleg !== 'none') {
          // Place tree at the inside corner of the dogleg to block shortcuts
          const cornerDir = template.dogleg === 'left' ? 1 : -1; // Inside of turn
          const cornerX = bend.x + cornerDir * 45;
          const cornerY = bend.y;
          if (isValidPosition(cornerX, cornerY, 30)) {
            obstacles.push({
              type: 'tree',
              x: cornerX,
              y: cornerY,
              radius: 28,
              width: 0,
              height: 0,
              shape: 'circle',
              isCornerTree: true // Mark as strategic corner tree
            });
          }
        }

        // Helper to place an obstacle
        const tryPlaceObstacle = (type, tMin, tMax, perpMin, perpMax) => {
          for (let attempt = 0; attempt < 15; attempt++) {
            const t = tMin + this.rng.next() * (tMax - tMin);
            const pt = getPointOnFairway(t);
            const perp = getPerpAtT(t);
            const perpOffset = perpMin + this.rng.next() * (perpMax - perpMin);
            const side = this.rng.next() < 0.5 ? 1 : -1;

            const x = pt.x + perp.x * perpOffset * side;
            const y = pt.y + perp.y * perpOffset * side;

            let radius;
            if (type === 'tree') radius = this.rng.nextInt(22, 30);
            else if (type === 'rock') radius = this.rng.nextInt(14, 22);
            else if (type === 'sand') radius = this.rng.nextInt(40, 60);
            else radius = 50; // water

            if (isValidPosition(x, y, radius) && !overlapsExisting(x, y, radius)) {
              if (type === 'water') {
                obstacles.push({
                  type, x, y: y,
                  radius: Math.max(70, 90) / 2,
                  width: this.rng.nextInt(70, 100),
                  height: this.rng.nextInt(45, 65),
                  shape: 'rectangle'
                });
              } else {
                obstacles.push({ type, x, y, radius, width: 0, height: 0, shape: 'circle' });
              }
              return true;
            }
          }
          return false;
        };

        // === PLACE OBSTACLES ===
        // Trees in rough only (perpOffset 65+ keeps them outside fairway)
        tryPlaceObstacle('tree', 0.2, 0.4, 70, 140);
        tryPlaceObstacle('tree', 0.4, 0.65, 75, 150);
        if (template.length !== 'short') {
          tryPlaceObstacle('tree', 0.55, 0.8, 80, 160);
        }

        // Rocks in rough only (perpOffset 65+ keeps them outside fairway)
        tryPlaceObstacle('rock', 0.25, 0.5, 70, 130);
        tryPlaceObstacle('rock', 0.5, 0.75, 65, 120);

        // Sand bunkers - can be on fairway edge or greenside
        tryPlaceObstacle('sand', 0.75, 0.92, 25, 55); // Greenside
        if (template.length !== 'short') {
          tryPlaceObstacle('sand', 0.4, 0.6, 40, 70); // Fairway bunker (edge of fairway)
        }

        // Water hazard on longer holes - off to the side
        if (template.length === 'long' && this.rng.next() < 0.6) {
          tryPlaceObstacle('water', 0.35, 0.55, 60, 120);
        }

        // Sort for draw order
        const typeOrder = { water: 0, sand: 1, rock: 2, tree: 3 };
        obstacles.sort((a, b) => typeOrder[a.type] - typeOrder[b.type]);

        return obstacles;
      }
    };

    // === ScoreKeeper Module (T022, T033, T057-T063) ===
    const ScoreKeeper = {
      recordStroke(round) {
        round.currentStrokeCount++;
        this.updateUI(round);
      },

      getCurrentStrokes(round) {
        return round.currentStrokeCount;
      },

      completeHole(round, hole) {
        const holeScore = {
          holeNumber: hole.holeNumber,
          strokes: round.currentStrokeCount,
          par: hole.par,
          scoreRelativeToPar: round.currentStrokeCount - hole.par
        };

        round.holeScores.push(holeScore);
        round.totalStrokes += round.currentStrokeCount;
        round.totalPar += hole.par;
        round.scoreRelativeToPar = round.totalStrokes - round.totalPar;

        return holeScore;
      },

      getRoundSummary(round) {
        return {
          totalStrokes: round.totalStrokes,
          totalPar: round.totalPar,
          scoreRelativeToPar: round.scoreRelativeToPar,
          holeScores: round.holeScores,
          completedHoles: round.holeScores.length,
          remainingHoles: 9 - round.holeScores.length
        };
      },

      updateUI(round) {
        document.getElementById('stroke-count').textContent = round.currentStrokeCount;
        document.getElementById('total-score').textContent = this.getScoreDisplay(round.scoreRelativeToPar);
      },

      getScoreDisplay(score) {
        if (score === 0) return 'E';
        if (score > 0) return `+${score}`;
        return `${score}`;
      },

      getScoreColor(scoreRelativeToPar) {
        if (scoreRelativeToPar <= -2) return '#FFD700';
        if (scoreRelativeToPar === -1) return '#4CAF50';
        if (scoreRelativeToPar === 0) return '#2196F3';
        if (scoreRelativeToPar === 1) return '#FF9800';
        return '#F44336';
      },

      getScoreName(scoreRelativeToPar) {
        if (scoreRelativeToPar <= -3) return 'Albatross!';
        if (scoreRelativeToPar === -2) return 'Eagle!';
        if (scoreRelativeToPar === -1) return 'Birdie!';
        if (scoreRelativeToPar === 0) return 'Par';
        if (scoreRelativeToPar === 1) return 'Bogey';
        if (scoreRelativeToPar === 2) return 'Double Bogey';
        return `+${scoreRelativeToPar}`;
      }
    };

    // === ClubSystem Module (T039-T043, T048-T049) ===
    const ClubSystem = {
      clubs: {
        driver: { id: 'driver', name: 'Driver', maxPower: 1.0, arcMultiplier: 1.0, spinMultiplier: 1.0 },
        wood3: { id: 'wood3', name: '3 Wood', maxPower: 0.9, arcMultiplier: 0.95, spinMultiplier: 0.95 },
        wood5: { id: 'wood5', name: '5 Wood', maxPower: 0.85, arcMultiplier: 0.9, spinMultiplier: 0.9 },
        iron4: { id: 'iron4', name: '4 Iron', maxPower: 0.8, arcMultiplier: 0.85, spinMultiplier: 1.1 },
        iron5: { id: 'iron5', name: '5 Iron', maxPower: 0.75, arcMultiplier: 0.8, spinMultiplier: 1.15 },
        iron6: { id: 'iron6', name: '6 Iron', maxPower: 0.7, arcMultiplier: 0.75, spinMultiplier: 1.2 },
        iron7: { id: 'iron7', name: '7 Iron', maxPower: 0.65, arcMultiplier: 0.7, spinMultiplier: 1.25 },
        iron8: { id: 'iron8', name: '8 Iron', maxPower: 0.6, arcMultiplier: 0.65, spinMultiplier: 1.3 },
        iron9: { id: 'iron9', name: '9 Iron', maxPower: 0.55, arcMultiplier: 0.6, spinMultiplier: 1.35 },
        wedge: { id: 'wedge', name: 'Wedge', maxPower: 0.5, arcMultiplier: 0.55, spinMultiplier: 1.5 },
        putter: { id: 'putter', name: 'Putter', maxPower: 0.3, arcMultiplier: 0.0, spinMultiplier: 0.0 }
      },

      getClub(clubId) {
        const baseClub = this.clubs[clubId] || this.clubs.driver;
        // Apply tier multiplier from ShopSystem
        const tierMultiplier = ShopSystem.getTierMultiplier(clubId);
        return {
          ...baseClub,
          maxPower: baseClub.maxPower * tierMultiplier
        };
      },

      // Get base club without tier modifier (for shop display)
      getBaseClub(clubId) {
        return this.clubs[clubId] || this.clubs.driver;
      },

      getAllClubs() {
        return Object.values(this.clubs);
      },

      getAvailableClubs(isFirstStroke) {
        // All clubs available on all shots (including tee shots)
        // On par 3s, players should use irons, not driver
        return this.getAllClubs();
      },

      applyClubToSwing(swingVector, clubId) {
        const club = this.getClub(clubId);
        return {
          power: swingVector.power * club.maxPower,
          angle: swingVector.angle,
          arc: club.arcMultiplier,
          spin: club.spinMultiplier
        };
      },

      getRecommendedClub(ball, holePosition) {
        // Convert pixel distance to yards
        const pixelDistance = PhysicsEngine.distance(ball, holePosition);
        const distanceYards = pixelDistance * PIXELS_TO_YARDS;

        // Get all clubs with their actual current max distances (including upgrades)
        const allClubIds = ['putter', 'wedge', 'iron9', 'iron8', 'iron7', 'iron6', 'iron5', 'iron4', 'wood5', 'wood3', 'driver'];

        // Build array of clubs with their actual distances
        const clubsWithDistances = allClubIds.map(clubId => ({
          id: clubId,
          maxDistance: this.getMaxDistance(clubId)
        }));

        // Sort by actual max distance (shortest first)
        clubsWithDistances.sort((a, b) => a.maxDistance - b.maxDistance);

        // Find the club with the shortest max distance that can still reach the hole
        let bestClub = clubsWithDistances[clubsWithDistances.length - 1].id; // Default to longest club

        for (const club of clubsWithDistances) {
          if (club.maxDistance >= distanceYards) {
            bestClub = club.id;
            break; // Found the shortest club that can reach
          }
        }

        return bestClub;
      },

      // Calculate max distance for a club at 100% power (in yards)
      getMaxDistance(clubId) {
        const club = this.getClub(clubId);

        // Fixed max distance - driver at 100% = 280 yards
        const targetYards = 280;
        const targetPixels = targetYards * ScreenScale.pixelsPerYard;
        // Same velocity calculation as applySwing
        const maxVelocity = targetPixels * 1.2;

        const friction = 0.98;
        const thresholdYards = 2;
        const stopThreshold = thresholdYards * ScreenScale.pixelsPerYard;
        const deltaTime = 1/60; // 60 FPS

        // Simulate ball flight (in pixels)
        let velocityX = maxVelocity * club.maxPower;
        let distancePixels = 0;

        while (Math.abs(velocityX) > stopThreshold) {
          distancePixels += velocityX * deltaTime;
          velocityX *= friction;
        }

        // Convert pixels to yards using ScreenScale
        return Math.round(distancePixels / ScreenScale.pixelsPerYard);
      }
    };

    // === StorageManager Module (T064-T073) ===
    const StorageManager = {
      dbName: 'CartoonGolfDB',
      dbVersion: 1,
      storeName: 'gameStates',
      db: null,

      async init() {
        return new Promise((resolve, reject) => {
          const request = indexedDB.open(this.dbName, this.dbVersion);

          request.onerror = () => {
            console.error('IndexedDB error:', request.error);
            reject(request.error);
          };

          request.onsuccess = () => {
            this.db = request.result;
            resolve(this.db);
          };

          request.onupgradeneeded = (event) => {
            const db = event.target.result;

            if (!db.objectStoreNames.contains(this.storeName)) {
              const objectStore = db.createObjectStore(this.storeName, { keyPath: 'id' });
              objectStore.createIndex('timestamp', 'timestamp', { unique: false });
            }
          };
        });
      },

      async saveGameState(gameState) {
        try {
          if (!this.db) {
            await this.init();
          }

          const stateToSave = {
            id: 'current-game',
            timestamp: Date.now(),
            gameState: {
              currentHole: gameState.currentHole,
              round: gameState.round,
              ball: {
                x: gameState.ball.x,
                y: gameState.ball.y,
                velocityX: gameState.ball.velocityX,
                velocityY: gameState.ball.velocityY,
                spin: gameState.ball.spin,
                isAirborne: gameState.ball.isAirborne,
                isMoving: gameState.ball.isMoving,
                rotation: gameState.ball.rotation,
                groundY: gameState.ball.groundY,
                holePosition: gameState.ball.holePosition,
                distanceFromHole: gameState.ball.distanceFromHole,
                lastSafePosition: gameState.ball.lastSafePosition,
                waterPenalty: gameState.ball.waterPenalty,
                color: gameState.ball.color
              },
              selectedClub: gameState.selectedClub,
              seed: gameState.seed,
              ballColor: gameState.ballColor
            }
          };

          const transaction = this.db.transaction([this.storeName], 'readwrite');
          const objectStore = transaction.objectStore(this.storeName);
          const request = objectStore.put(stateToSave);

          return new Promise((resolve, reject) => {
            request.onsuccess = () => resolve(true);
            request.onerror = () => {
              console.error('Save error:', request.error);
              reject(request.error);
            };
          });
        } catch (error) {
          console.error('Failed to save game state:', error);
          return false;
        }
      },

      async loadGameState() {
        try {
          if (!this.db) {
            await this.init();
          }

          const transaction = this.db.transaction([this.storeName], 'readonly');
          const objectStore = transaction.objectStore(this.storeName);
          const request = objectStore.get('current-game');

          return new Promise((resolve, reject) => {
            request.onsuccess = () => {
              if (request.result) {
                resolve(request.result.gameState);
              } else {
                resolve(null);
              }
            };
            request.onerror = () => {
              console.error('Load error:', request.error);
              reject(request.error);
            };
          });
        } catch (error) {
          console.error('Failed to load game state:', error);
          return null;
        }
      },

      async clearGameState() {
        try {
          if (!this.db) {
            await this.init();
          }

          const transaction = this.db.transaction([this.storeName], 'readwrite');
          const objectStore = transaction.objectStore(this.storeName);
          const request = objectStore.delete('current-game');

          return new Promise((resolve, reject) => {
            request.onsuccess = () => resolve(true);
            request.onerror = () => {
              console.error('Clear error:', request.error);
              reject(request.error);
            };
          });
        } catch (error) {
          console.error('Failed to clear game state:', error);
          return false;
        }
      },

      async hasSavedGame() {
        try {
          const savedState = await this.loadGameState();
          return savedState !== null && !savedState.round.isComplete;
        } catch (error) {
          console.error('Error checking for saved game:', error);
          return false;
        }
      },

      saveSettings(settings) {
        try {
          localStorage.setItem('golf-settings', JSON.stringify(settings));
          return true;
        } catch (error) {
          console.error('Failed to save settings:', error);
          return false;
        }
      },

      loadSettings() {
        try {
          const settings = localStorage.getItem('golf-settings');
          return settings ? JSON.parse(settings) : this.getDefaultSettings();
        } catch (error) {
          console.error('Failed to load settings:', error);
          return this.getDefaultSettings();
        }
      },

      getDefaultSettings() {
        return {
          soundEnabled: true,
          musicEnabled: true,
          trailsEnabled: true,
          eventsEnabled: true,
          debugMode: false,
          tutorialCompleted: false
        };
      },

      // === Leaderboard Methods (T074-T076) ===
      async addLeaderboardEntry(entry) {
        try {
          if (!this.db) {
            await this.init();
          }

          const leaderboard = await this.getLeaderboard();

          // Add new entry
          leaderboard.push({
            scoreRelativeToPar: entry.scoreRelativeToPar,
            totalStrokes: entry.totalStrokes,
            completedAt: entry.completedAt || Date.now(),
            playerInitials: entry.playerInitials || 'YOU'
          });

          // Sort by score (lower is better)
          leaderboard.sort((a, b) => a.scoreRelativeToPar - b.scoreRelativeToPar);

          // Keep only top 10
          const top10 = leaderboard.slice(0, 10);

          // Save to IndexedDB
          const transaction = this.db.transaction([this.storeName], 'readwrite');
          const objectStore = transaction.objectStore(this.storeName);
          const request = objectStore.put({
            id: 'leaderboard',
            entries: top10,
            timestamp: Date.now()
          });

          return new Promise((resolve, reject) => {
            request.onsuccess = () => resolve(top10);
            request.onerror = () => {
              console.error('Leaderboard save error:', request.error);
              reject(request.error);
            };
          });
        } catch (error) {
          console.error('Failed to add leaderboard entry:', error);
          return [];
        }
      },

      async getLeaderboard() {
        try {
          if (!this.db) {
            await this.init();
          }

          const transaction = this.db.transaction([this.storeName], 'readonly');
          const objectStore = transaction.objectStore(this.storeName);
          const request = objectStore.get('leaderboard');

          return new Promise((resolve, reject) => {
            request.onsuccess = () => {
              if (request.result && request.result.entries) {
                resolve(request.result.entries);
              } else {
                resolve([]);
              }
            };
            request.onerror = () => {
              console.error('Leaderboard load error:', request.error);
              reject(request.error);
            };
          });
        } catch (error) {
          console.error('Failed to load leaderboard:', error);
          return [];
        }
      }
    };

    // === AudioManager Module (T073f, T073g) ===
    const AudioManager = {
      context: null,
      sounds: {},
      muted: false,
      musicPlaying: false,
      musicGain: null,
      musicNodes: [],

      init() {
        try {
          this.context = new (window.AudioContext || window.webkitAudioContext)();
          this.muted = StorageManager.loadSettings().soundEnabled === false;
        } catch (error) {
          console.error('Web Audio API not supported:', error);
        }
      },

      unlock() {
        if (!this.context) return;

        if (this.context.state === 'suspended') {
          this.context.resume();
        }

        const buffer = this.context.createBuffer(1, 1, 22050);
        const source = this.context.createBufferSource();
        source.buffer = buffer;
        source.connect(this.context.destination);
        source.start(0);
      },

      // Background music - chill golf course ambience
      startBackgroundMusic() {
        // Check both muted state and musicEnabled setting
        const settings = StorageManager.loadSettings();
        if (this.muted || settings.musicEnabled === false || !this.context || this.musicPlaying) return;

        this.musicPlaying = true;

        // Create master gain for music
        this.musicGain = this.context.createGain();
        this.musicGain.gain.value = 0.08; // Quiet background
        this.musicGain.connect(this.context.destination);

        // Peaceful chord progression (C - Am - F - G)
        const chords = [
          [261.63, 329.63, 392.00], // C major
          [220.00, 261.63, 329.63], // A minor
          [174.61, 220.00, 261.63], // F major
          [196.00, 246.94, 293.66]  // G major
        ];

        let chordIndex = 0;

        const playChord = () => {
          if (!this.musicPlaying || this.muted) return;

          const chord = chords[chordIndex];
          const now = this.context.currentTime;

          chord.forEach((freq, i) => {
            const osc = this.context.createOscillator();
            const gain = this.context.createGain();

            osc.type = 'sine';
            osc.frequency.value = freq;

            gain.gain.setValueAtTime(0, now);
            gain.gain.linearRampToValueAtTime(0.3, now + 0.3);
            gain.gain.linearRampToValueAtTime(0.15, now + 1.5);
            gain.gain.linearRampToValueAtTime(0, now + 2.8);

            osc.connect(gain);
            gain.connect(this.musicGain);

            osc.start(now);
            osc.stop(now + 3);

            this.musicNodes.push(osc);
          });

          chordIndex = (chordIndex + 1) % chords.length;

          // Schedule next chord
          this.musicTimeout = setTimeout(playChord, 3000);
        };

        // Add ambient bird chirps
        const playBird = () => {
          if (!this.musicPlaying || this.muted) return;

          const now = this.context.currentTime;
          const osc = this.context.createOscillator();
          const gain = this.context.createGain();

          osc.type = 'sine';
          const baseFreq = 1800 + Math.random() * 800;

          osc.frequency.setValueAtTime(baseFreq, now);
          osc.frequency.linearRampToValueAtTime(baseFreq * 1.2, now + 0.05);
          osc.frequency.linearRampToValueAtTime(baseFreq * 0.9, now + 0.1);

          gain.gain.setValueAtTime(0, now);
          gain.gain.linearRampToValueAtTime(0.03, now + 0.02);
          gain.gain.linearRampToValueAtTime(0, now + 0.15);

          osc.connect(gain);
          gain.connect(this.musicGain);

          osc.start(now);
          osc.stop(now + 0.2);

          // Random interval for next bird
          this.birdTimeout = setTimeout(playBird, 4000 + Math.random() * 8000);
        };

        playChord();
        setTimeout(playBird, 2000);
      },

      stopBackgroundMusic() {
        this.musicPlaying = false;
        if (this.musicTimeout) clearTimeout(this.musicTimeout);
        if (this.birdTimeout) clearTimeout(this.birdTimeout);
        this.musicNodes.forEach(node => {
          try { node.stop(); } catch (e) {}
        });
        this.musicNodes = [];
      },

      // === T096: Enhanced club hit sounds ===
      playHitSound(power) {
        if (this.muted || !this.context) return;

        const oscillator = this.context.createOscillator();
        const gainNode = this.context.createGain();

        oscillator.connect(gainNode);
        gainNode.connect(this.context.destination);

        // Soft, medium, hard hit sounds based on power
        let frequency, volume, duration;
        if (power < 0.3) {
          frequency = 180;
          volume = 0.08;
          duration = 0.04;
        } else if (power < 0.6) {
          frequency = 280;
          volume = 0.15;
          duration = 0.06;
        } else {
          frequency = 380;
          volume = 0.22;
          duration = 0.08;
        }

        oscillator.frequency.value = frequency;
        oscillator.type = 'sine';

        gainNode.gain.setValueAtTime(volume, this.context.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, this.context.currentTime + duration);

        oscillator.start(this.context.currentTime);
        oscillator.stop(this.context.currentTime + duration);
      },

      // === T097: Landing sounds based on surface ===
      playLandSound(surfaceType = 'grass') {
        if (this.muted || !this.context) return;

        const oscillator = this.context.createOscillator();
        const gainNode = this.context.createGain();

        oscillator.connect(gainNode);
        gainNode.connect(this.context.destination);

        let frequency, duration, volume;
        switch (surfaceType) {
          case 'sand':
            frequency = 120;
            duration = 0.15;
            volume = 0.12;
            break;
          case 'water':
            frequency = 200;
            duration = 0.2;
            volume = 0.18;
            oscillator.type = 'triangle';
            break;
          case 'grass':
          default:
            frequency = 150;
            duration = 0.08;
            volume = 0.1;
            break;
        }

        oscillator.frequency.value = frequency;
        if (surfaceType !== 'water') oscillator.type = 'sine';

        gainNode.gain.setValueAtTime(volume, this.context.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, this.context.currentTime + duration);

        oscillator.start(this.context.currentTime);
        oscillator.stop(this.context.currentTime + duration);
      },

      // === T098: Cheer sound for exceptional shots ===
      playCheerSound() {
        if (this.muted || !this.context) return;

        // Play a rising three-note cheer
        const notes = [523.25, 659.25, 783.99]; // C5, E5, G5
        notes.forEach((freq, i) => {
          setTimeout(() => {
            const osc = this.context.createOscillator();
            const gain = this.context.createGain();
            osc.connect(gain);
            gain.connect(this.context.destination);
            osc.frequency.value = freq;
            osc.type = 'sine';
            gain.gain.setValueAtTime(0.15, this.context.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, this.context.currentTime + 0.3);
            osc.start(this.context.currentTime);
            osc.stop(this.context.currentTime + 0.3);
          }, i * 100);
        });
      },

      // UI click sound for menu buttons
      playClickSound() {
        if (this.muted || !this.context) return;

        const oscillator = this.context.createOscillator();
        const gainNode = this.context.createGain();

        oscillator.connect(gainNode);
        gainNode.connect(this.context.destination);

        // Short, snappy click
        oscillator.frequency.value = 800;
        oscillator.type = 'sine';

        gainNode.gain.setValueAtTime(0.15, this.context.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, this.context.currentTime + 0.05);

        oscillator.start(this.context.currentTime);
        oscillator.stop(this.context.currentTime + 0.05);
      },

      // Achievement unlock sound - triumphant fanfare
      playAchievement() {
        if (this.muted || !this.context) return;

        // Play a triumphant 3-note fanfare
        const notes = [523.25, 659.25, 783.99]; // C5, E5, G5
        const durations = [0.15, 0.15, 0.4];
        let startTime = this.context.currentTime;

        notes.forEach((freq, i) => {
          const osc = this.context.createOscillator();
          const gain = this.context.createGain();

          osc.connect(gain);
          gain.connect(this.context.destination);

          osc.frequency.value = freq;
          osc.type = 'triangle';

          gain.gain.setValueAtTime(0.25, startTime);
          gain.gain.exponentialRampToValueAtTime(0.01, startTime + durations[i]);

          osc.start(startTime);
          osc.stop(startTime + durations[i]);

          startTime += durations[i] * 0.7; // Slight overlap
        });
      },

      // === T099: Hole completion jingle ===
      playHoleSound() {
        if (this.muted || !this.context) return;

        const oscillator = this.context.createOscillator();
        const gainNode = this.context.createGain();

        oscillator.connect(gainNode);
        gainNode.connect(this.context.destination);

        oscillator.frequency.value = 523.25;
        oscillator.type = 'sine';

        gainNode.gain.setValueAtTime(0.2, this.context.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, this.context.currentTime + 0.3);

        oscillator.start(this.context.currentTime);
        oscillator.stop(this.context.currentTime + 0.3);

        setTimeout(() => {
          const osc2 = this.context.createOscillator();
          const gain2 = this.context.createGain();
          osc2.connect(gain2);
          gain2.connect(this.context.destination);
          osc2.frequency.value = 659.25;
          osc2.type = 'sine';
          gain2.gain.setValueAtTime(0.2, this.context.currentTime);
          gain2.gain.exponentialRampToValueAtTime(0.01, this.context.currentTime + 0.3);
          osc2.start(this.context.currentTime);
          osc2.stop(this.context.currentTime + 0.3);
        }, 150);
      },

      playStreakerSound() {
        if (this.muted || !this.context) return;

        // Create a funny "AAAHHHH!" scream sound
        const duration = 1.2;
        const now = this.context.currentTime;

        // Main scream oscillator - starts high, wobbles
        const screamOsc = this.context.createOscillator();
        const screamGain = this.context.createGain();
        const vibrato = this.context.createOscillator();
        const vibratoGain = this.context.createGain();

        // Vibrato for wobbly scream effect
        vibrato.frequency.value = 12; // Fast wobble
        vibratoGain.gain.value = 50; // Amount of pitch wobble
        vibrato.connect(vibratoGain);
        vibratoGain.connect(screamOsc.frequency);

        screamOsc.connect(screamGain);
        screamGain.connect(this.context.destination);

        // Scream starts high and drops slightly
        screamOsc.frequency.setValueAtTime(800, now);
        screamOsc.frequency.linearRampToValueAtTime(600, now + 0.3);
        screamOsc.frequency.linearRampToValueAtTime(700, now + 0.6);
        screamOsc.frequency.linearRampToValueAtTime(500, now + duration);

        screamOsc.type = 'sawtooth'; // Harsh, scream-like

        // Volume envelope - loud start, sustain, fade
        screamGain.gain.setValueAtTime(0, now);
        screamGain.gain.linearRampToValueAtTime(0.15, now + 0.05);
        screamGain.gain.setValueAtTime(0.12, now + 0.3);
        screamGain.gain.linearRampToValueAtTime(0.08, now + 0.8);
        screamGain.gain.exponentialRampToValueAtTime(0.01, now + duration);

        vibrato.start(now);
        screamOsc.start(now);
        vibrato.stop(now + duration);
        screamOsc.stop(now + duration);

        // Add a second higher harmonic for more "voice" quality
        const harmonic = this.context.createOscillator();
        const harmonicGain = this.context.createGain();
        harmonic.connect(harmonicGain);
        harmonicGain.connect(this.context.destination);

        harmonic.frequency.setValueAtTime(1200, now);
        harmonic.frequency.linearRampToValueAtTime(900, now + 0.3);
        harmonic.frequency.linearRampToValueAtTime(1000, now + duration);
        harmonic.type = 'sine';

        harmonicGain.gain.setValueAtTime(0, now);
        harmonicGain.gain.linearRampToValueAtTime(0.05, now + 0.05);
        harmonicGain.gain.exponentialRampToValueAtTime(0.01, now + duration);

        harmonic.start(now);
        harmonic.stop(now + duration);
      },

      // === Crowd ambient noise and reactions ===
      crowdAmbienceGain: null,
      crowdAmbienceNodes: [],
      crowdAmbiencePlaying: false,

      startCrowdAmbience() {
        const settings = StorageManager.loadSettings();
        if (this.muted || settings.musicEnabled === false || !this.context || this.crowdAmbiencePlaying) return;

        this.crowdAmbiencePlaying = true;

        // Create gain node for crowd ambience
        this.crowdAmbienceGain = this.context.createGain();
        this.crowdAmbienceGain.gain.value = 0.015;  // Very quiet background
        this.crowdAmbienceGain.connect(this.context.destination);

        // Generate soft crowd murmur using filtered noise
        const playMurmur = () => {
          if (!this.crowdAmbiencePlaying || this.muted) return;

          // Create noise buffer
          const bufferSize = this.context.sampleRate * 2;
          const noiseBuffer = this.context.createBuffer(1, bufferSize, this.context.sampleRate);
          const output = noiseBuffer.getChannelData(0);

          for (let i = 0; i < bufferSize; i++) {
            output[i] = Math.random() * 2 - 1;
          }

          const noise = this.context.createBufferSource();
          noise.buffer = noiseBuffer;

          // Low-pass filter for muffled crowd sound
          const filter = this.context.createBiquadFilter();
          filter.type = 'lowpass';
          filter.frequency.value = 300;
          filter.Q.value = 1;

          // Gentle volume envelope
          const gain = this.context.createGain();
          const now = this.context.currentTime;
          gain.gain.setValueAtTime(0, now);
          gain.gain.linearRampToValueAtTime(1, now + 0.5);
          gain.gain.setValueAtTime(1, now + 1.5);
          gain.gain.linearRampToValueAtTime(0, now + 2);

          noise.connect(filter);
          filter.connect(gain);
          gain.connect(this.crowdAmbienceGain);

          noise.start(now);
          noise.stop(now + 2);

          this.crowdAmbienceNodes.push(noise);

          // Schedule next murmur
          this.crowdMurmurTimeout = setTimeout(playMurmur, 3000 + Math.random() * 4000);
        };

        // Occasional cough or sneeze sound
        const playRandomSound = () => {
          if (!this.crowdAmbiencePlaying || this.muted) return;

          const now = this.context.currentTime;
          const osc = this.context.createOscillator();
          const gain = this.context.createGain();

          // Random cough-like sound
          osc.type = 'sine';
          osc.frequency.setValueAtTime(200 + Math.random() * 100, now);
          osc.frequency.exponentialRampToValueAtTime(80, now + 0.1);

          gain.gain.setValueAtTime(0, now);
          gain.gain.linearRampToValueAtTime(0.03, now + 0.02);
          gain.gain.exponentialRampToValueAtTime(0.001, now + 0.15);

          osc.connect(gain);
          gain.connect(this.crowdAmbienceGain);

          osc.start(now);
          osc.stop(now + 0.2);

          this.crowdRandomTimeout = setTimeout(playRandomSound, 8000 + Math.random() * 15000);
        };

        playMurmur();
        setTimeout(playRandomSound, 5000);
      },

      stopCrowdAmbience() {
        this.crowdAmbiencePlaying = false;
        if (this.crowdMurmurTimeout) clearTimeout(this.crowdMurmurTimeout);
        if (this.crowdRandomTimeout) clearTimeout(this.crowdRandomTimeout);
        this.crowdAmbienceNodes.forEach(node => {
          try { node.stop(); } catch (e) {}
        });
        this.crowdAmbienceNodes = [];
      },

      // Crowd cheer for great shots
      playCrowdCheer() {
        if (this.muted || !this.context) return;

        const now = this.context.currentTime;

        // Multiple voices cheering
        for (let i = 0; i < 5; i++) {
          const osc = this.context.createOscillator();
          const gain = this.context.createGain();
          const filter = this.context.createBiquadFilter();

          // Randomized cheer frequencies
          const baseFreq = 200 + Math.random() * 150;
          osc.type = 'sawtooth';
          osc.frequency.setValueAtTime(baseFreq, now);
          osc.frequency.linearRampToValueAtTime(baseFreq * 1.3, now + 0.2);
          osc.frequency.linearRampToValueAtTime(baseFreq * 1.1, now + 0.5);

          filter.type = 'lowpass';
          filter.frequency.value = 800;

          gain.gain.setValueAtTime(0, now);
          gain.gain.linearRampToValueAtTime(0.04, now + 0.05);
          gain.gain.setValueAtTime(0.04, now + 0.3);
          gain.gain.exponentialRampToValueAtTime(0.001, now + 0.6);

          osc.connect(filter);
          filter.connect(gain);
          gain.connect(this.context.destination);

          osc.start(now + Math.random() * 0.1);
          osc.stop(now + 0.7);
        }
      },

      // Crowd gasp for bad shots (water, sand)
      playCrowdGasp() {
        if (this.muted || !this.context) return;

        const now = this.context.currentTime;

        // Quick inhale sound
        for (let i = 0; i < 3; i++) {
          const osc = this.context.createOscillator();
          const gain = this.context.createGain();
          const filter = this.context.createBiquadFilter();

          osc.type = 'sine';
          osc.frequency.setValueAtTime(400 + Math.random() * 200, now);
          osc.frequency.linearRampToValueAtTime(250, now + 0.15);

          filter.type = 'lowpass';
          filter.frequency.value = 600;

          gain.gain.setValueAtTime(0, now);
          gain.gain.linearRampToValueAtTime(0.03, now + 0.03);
          gain.gain.exponentialRampToValueAtTime(0.001, now + 0.2);

          osc.connect(filter);
          filter.connect(gain);
          gain.connect(this.context.destination);

          osc.start(now + Math.random() * 0.05);
          osc.stop(now + 0.25);
        }
      },

      // Polite applause for holing out
      playCrowdClap() {
        if (this.muted || !this.context) return;

        const now = this.context.currentTime;

        // Generate clapping sounds
        for (let c = 0; c < 8; c++) {
          const startTime = now + c * 0.12 + Math.random() * 0.05;

          // Each clap is filtered noise burst
          const bufferSize = this.context.sampleRate * 0.05;
          const buffer = this.context.createBuffer(1, bufferSize, this.context.sampleRate);
          const data = buffer.getChannelData(0);
          for (let i = 0; i < bufferSize; i++) {
            data[i] = Math.random() * 2 - 1;
          }

          const source = this.context.createBufferSource();
          source.buffer = buffer;

          const filter = this.context.createBiquadFilter();
          filter.type = 'bandpass';
          filter.frequency.value = 2000 + Math.random() * 1000;
          filter.Q.value = 2;

          const gain = this.context.createGain();
          gain.gain.setValueAtTime(0.08, startTime);
          gain.gain.exponentialRampToValueAtTime(0.001, startTime + 0.05);

          source.connect(filter);
          filter.connect(gain);
          gain.connect(this.context.destination);

          source.start(startTime);
          source.stop(startTime + 0.05);
        }
      },

      // === T094, T100: Mute toggle ===
      setMuted(muted) {
        this.muted = muted;
        const settings = StorageManager.loadSettings();
        settings.soundEnabled = !muted;
        StorageManager.saveSettings(settings);
      }
    };

    // === ConfettiSystem Module (T102-T105: Visual Polish) ===
    const ConfettiSystem = {
      particles: [],

      // Color palettes for different score types
      colors: {
        standard: ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7', '#DDA0DD'],
        birdie: ['#4CAF50', '#8BC34A', '#CDDC39', '#FFD700'],
        eagle: ['#FFD700', '#FFA500', '#FF6347', '#FF69B4', '#9370DB', '#00CED1']
      },

      spawn(x, y, count, colorPalette = 'standard') {
        const palette = this.colors[colorPalette] || this.colors.standard;

        for (let i = 0; i < count; i++) {
          const angle = (Math.PI * 2 * i / count) + (Math.random() - 0.5) * 0.5;
          const speed = 150 + Math.random() * 200;

          this.particles.push({
            x: x,
            y: y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed - 100, // Bias upward
            rotation: Math.random() * Math.PI * 2,
            rotationSpeed: (Math.random() - 0.5) * 10,
            color: palette[Math.floor(Math.random() * palette.length)],
            size: 4 + Math.random() * 6,
            life: 1.0, // 1.0 = full life, 0 = dead
            gravity: 300
          });
        }
      },

      update(deltaTime) {
        for (let i = this.particles.length - 1; i >= 0; i--) {
          const p = this.particles[i];

          // Apply physics
          p.vy += p.gravity * deltaTime;
          p.x += p.vx * deltaTime;
          p.y += p.vy * deltaTime;
          p.rotation += p.rotationSpeed * deltaTime;

          // Apply drag
          p.vx *= 0.99;
          p.vy *= 0.99;

          // Decay life
          p.life -= deltaTime * 0.5;

          // Remove dead particles
          if (p.life <= 0) {
            this.particles.splice(i, 1);
          }
        }
      },

      draw(ctx) {
        for (const p of this.particles) {
          ctx.save();
          ctx.translate(p.x, p.y);
          ctx.rotate(p.rotation);
          ctx.globalAlpha = Math.min(p.life, 1);
          ctx.fillStyle = p.color;
          ctx.fillRect(-p.size / 2, -p.size / 4, p.size, p.size / 2);
          ctx.restore();
        }
      },

      clear() {
        this.particles = [];
      }
    };

    // === RandomEventManager Module (T108-T115: Random Events & Humor) ===
    const RandomEventManager = {
      activeEvent: null,
      cooldownTimer: 0,
      minCooldown: 8,
      triggerChance: 0.25,

      // Event types with their configs
      eventTypes: ['streaker', 'golfCart', 'ufo', 'squirrel'],

      configs: {
        streaker: { speed: 600, size: 40, color: '#FFD6B3', warning: 'STREAKER INCOMING!' },
        golfCart: { speed: 450, size: 60, color: '#FFFFFF', warning: 'RUNAWAY GOLF CART!' },
        ufo: { speed: 200, size: 50, color: '#88FF88', warning: '👽 UFO SIGHTING!' },
        squirrel: { speed: 800, size: 25, color: '#8B4513', warning: 'SQUIRREL ATTACK!' }
      },

      reset() {
        this.activeEvent = null;
        this.cooldownTimer = 0;
      },

      checkTrigger() {
        if (this.cooldownTimer > 0) return false;
        if (this.activeEvent) return false;

        if (Math.random() < this.triggerChance) {
          // Pick random event type
          const eventType = this.eventTypes[Math.floor(Math.random() * this.eventTypes.length)];
          this.spawnEvent(eventType);
          return true;
        }
        return false;
      },

      spawnEvent(type) {
        const canvas = document.getElementById('game-canvas');
        // Use visual dimensions, not scaled pixel dimensions
        const rect = canvas.getBoundingClientRect();
        const height = rect.height;
        const width = rect.width;
        const config = this.configs[type];

        const goingRight = Math.random() > 0.5;
        let yPos = height * 0.5;

        // UFO flies higher, squirrel lower
        if (type === 'ufo') yPos = height * 0.25;
        if (type === 'squirrel') yPos = height * 0.7;

        this.activeEvent = {
          type: type,
          x: goingRight ? -80 : width + 80,
          y: yPos,
          targetX: goingRight ? width + 80 : -80,
          direction: goingRight ? 1 : -1,
          animationPhase: 0,
          trail: [],
          warningTimer: 1.0,
          started: false,
          config: config
        };

        this.cooldownTimer = this.minCooldown + Math.random() * 10;
      },

      update(deltaTime) {
        if (this.cooldownTimer > 0) {
          this.cooldownTimer -= deltaTime;
        }

        if (this.activeEvent) {
          const e = this.activeEvent;

          // Warning phase
          if (e.warningTimer > 0) {
            e.warningTimer -= deltaTime;
            if (e.warningTimer <= 0) {
              e.started = true;
              if (e.type === 'streaker') AudioManager.playStreakerSound();
            }
            return;
          }

          // Move event
          e.x += e.config.speed * e.direction * deltaTime;
          e.animationPhase += deltaTime * 15;

          // Trail
          e.trail.push({ x: e.x, y: e.y, alpha: 1 });
          if (e.trail.length > 8) e.trail.shift();
          for (const t of e.trail) t.alpha *= 0.85;

          // Check exit
          if ((e.direction > 0 && e.x > e.targetX) ||
              (e.direction < 0 && e.x < e.targetX)) {
            this.activeEvent = null;
          }
        }
      },

      draw(ctx) {
        if (!this.activeEvent) return;

        const e = this.activeEvent;
        const canvas = ctx.canvas;
        // Use visual dimensions for positioning
        const rect = canvas.getBoundingClientRect();
        const centerX = rect.width / 2;
        const centerY = rect.height / 2;

        // Warning phase
        if (e.warningTimer > 0) {
          ctx.save();
          const pulse = 1 + Math.sin(e.warningTimer * 15) * 0.1;
          ctx.font = `bold ${50 * pulse}px Arial`;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
          ctx.fillText(e.config.warning, centerX + 3, centerY + 3);
          ctx.fillStyle = '#FF4444';
          ctx.fillText(e.config.warning, centerX, centerY);
          ctx.strokeStyle = '#FFFFFF';
          ctx.lineWidth = 2;
          ctx.strokeText(e.config.warning, centerX, centerY);
          ctx.restore();
          return;
        }

        // Draw trail
        for (const t of e.trail) {
          ctx.save();
          ctx.globalAlpha = t.alpha * 0.4;
          ctx.fillStyle = e.config.color;
          ctx.beginPath();
          ctx.arc(t.x, t.y, e.config.size * 0.3, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        }

        ctx.save();
        const bob = Math.sin(e.animationPhase) * 5;
        ctx.translate(e.x, e.y + (e.type !== 'ufo' ? bob : 0));
        if (e.direction < 0) ctx.scale(-1, 1);

        // Draw based on type
        if (e.type === 'streaker') {
          this.drawStreaker(ctx, e);
        } else if (e.type === 'golfCart') {
          this.drawGolfCart(ctx, e);
        } else if (e.type === 'ufo') {
          this.drawUFO(ctx, e);
        } else if (e.type === 'squirrel') {
          this.drawSquirrel(ctx, e);
        }

        ctx.restore();
      },

      drawStreaker(ctx, e) {
        const size = e.config.size;
        const color = e.config.color;
        const armSwing = Math.sin(e.animationPhase) * 0.5;
        const legSwing = Math.sin(e.animationPhase + Math.PI) * 0.4;

        // Body
        ctx.fillStyle = color;
        ctx.strokeStyle = '#CC9966';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.ellipse(0, 0, size * 0.25, size * 0.4, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();

        // Head
        ctx.beginPath();
        ctx.arc(0, -size * 0.55, size * 0.2, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();

        // Arms & legs
        ctx.lineWidth = 6;
        ctx.lineCap = 'round';
        ctx.strokeStyle = color;

        ctx.save();
        ctx.rotate(armSwing - 0.3);
        ctx.beginPath();
        ctx.moveTo(0, -size * 0.2);
        ctx.lineTo(-size * 0.35, size * 0.1);
        ctx.stroke();
        ctx.restore();

        ctx.save();
        ctx.rotate(-armSwing + 0.3);
        ctx.beginPath();
        ctx.moveTo(0, -size * 0.2);
        ctx.lineTo(size * 0.35, size * 0.1);
        ctx.stroke();
        ctx.restore();

        ctx.save();
        ctx.rotate(legSwing);
        ctx.beginPath();
        ctx.moveTo(0, size * 0.25);
        ctx.lineTo(-size * 0.15, size * 0.6);
        ctx.stroke();
        ctx.restore();

        ctx.save();
        ctx.rotate(-legSwing);
        ctx.beginPath();
        ctx.moveTo(0, size * 0.25);
        ctx.lineTo(size * 0.15, size * 0.6);
        ctx.stroke();
        ctx.restore();

        // Wild hair
        ctx.strokeStyle = '#8B4513';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(-size * 0.1, -size * 0.7);
        ctx.lineTo(-size * 0.2, -size * 0.85);
        ctx.moveTo(0, -size * 0.75);
        ctx.lineTo(0, -size * 0.9);
        ctx.stroke();
      },

      drawGolfCart(ctx, e) {
        const size = e.config.size;

        // Cart body
        ctx.fillStyle = '#FFFFFF';
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 2;

        // Main body
        ctx.fillRect(-size * 0.5, -size * 0.3, size, size * 0.5);
        ctx.strokeRect(-size * 0.5, -size * 0.3, size, size * 0.5);

        // Roof
        ctx.fillStyle = '#4CAF50';
        ctx.fillRect(-size * 0.45, -size * 0.6, size * 0.9, size * 0.3);

        // Wheels (spinning)
        ctx.fillStyle = '#333';
        const wheelSpin = e.animationPhase * 2;
        [-size * 0.35, size * 0.35].forEach(wx => {
          ctx.beginPath();
          ctx.arc(wx, size * 0.2, size * 0.15, 0, Math.PI * 2);
          ctx.fill();
          // Spokes
          ctx.strokeStyle = '#666';
          ctx.lineWidth = 2;
          for (let i = 0; i < 4; i++) {
            const angle = wheelSpin + i * Math.PI / 2;
            ctx.beginPath();
            ctx.moveTo(wx, size * 0.2);
            ctx.lineTo(wx + Math.cos(angle) * size * 0.12, size * 0.2 + Math.sin(angle) * size * 0.12);
            ctx.stroke();
          }
        });

        // Driver (panicked)
        ctx.fillStyle = '#FFD6B3';
        ctx.beginPath();
        ctx.arc(0, -size * 0.15, size * 0.15, 0, Math.PI * 2);
        ctx.fill();

        // Panicked expression
        ctx.fillStyle = '#000';
        ctx.beginPath();
        ctx.arc(-size * 0.05, -size * 0.18, 3, 0, Math.PI * 2);
        ctx.arc(size * 0.05, -size * 0.18, 3, 0, Math.PI * 2);
        ctx.fill();

        // Open mouth (screaming)
        ctx.beginPath();
        ctx.ellipse(0, -size * 0.08, 5, 8, 0, 0, Math.PI * 2);
        ctx.fill();
      },

      drawUFO(ctx, e) {
        const size = e.config.size;
        const hover = Math.sin(e.animationPhase * 0.5) * 3;

        ctx.translate(0, hover);

        // Beam
        ctx.fillStyle = 'rgba(136, 255, 136, 0.2)';
        ctx.beginPath();
        ctx.moveTo(-size * 0.2, size * 0.2);
        ctx.lineTo(size * 0.2, size * 0.2);
        ctx.lineTo(size * 0.5, size * 1.2);
        ctx.lineTo(-size * 0.5, size * 1.2);
        ctx.closePath();
        ctx.fill();

        // Saucer bottom
        ctx.fillStyle = '#666';
        ctx.beginPath();
        ctx.ellipse(0, size * 0.1, size * 0.6, size * 0.15, 0, 0, Math.PI * 2);
        ctx.fill();

        // Saucer top
        ctx.fillStyle = '#88FF88';
        ctx.beginPath();
        ctx.ellipse(0, 0, size * 0.5, size * 0.25, 0, 0, Math.PI * 2);
        ctx.fill();

        // Dome
        ctx.fillStyle = 'rgba(150, 255, 150, 0.7)';
        ctx.beginPath();
        ctx.arc(0, -size * 0.1, size * 0.25, Math.PI, 0);
        ctx.fill();

        // Lights (blinking)
        const blink = Math.sin(e.animationPhase * 3) > 0;
        ctx.fillStyle = blink ? '#FF0' : '#F80';
        [-size * 0.35, 0, size * 0.35].forEach(lx => {
          ctx.beginPath();
          ctx.arc(lx, size * 0.05, 4, 0, Math.PI * 2);
          ctx.fill();
        });

        // Alien eyes
        ctx.fillStyle = '#000';
        ctx.beginPath();
        ctx.ellipse(-size * 0.08, -size * 0.15, 4, 6, 0, 0, Math.PI * 2);
        ctx.ellipse(size * 0.08, -size * 0.15, 4, 6, 0, 0, Math.PI * 2);
        ctx.fill();
      },

      drawSquirrel(ctx, e) {
        const size = e.config.size;
        const legMove = Math.sin(e.animationPhase * 2) * 0.3;

        // Body
        ctx.fillStyle = e.config.color;
        ctx.beginPath();
        ctx.ellipse(0, 0, size * 0.4, size * 0.25, 0, 0, Math.PI * 2);
        ctx.fill();

        // Head
        ctx.beginPath();
        ctx.arc(size * 0.35, -size * 0.1, size * 0.2, 0, Math.PI * 2);
        ctx.fill();

        // Ears
        ctx.beginPath();
        ctx.arc(size * 0.3, -size * 0.3, size * 0.08, 0, Math.PI * 2);
        ctx.arc(size * 0.45, -size * 0.28, size * 0.08, 0, Math.PI * 2);
        ctx.fill();

        // Fluffy tail
        ctx.beginPath();
        ctx.arc(-size * 0.5, -size * 0.3, size * 0.3, 0, Math.PI * 2);
        ctx.fill();

        // Eye
        ctx.fillStyle = '#000';
        ctx.beginPath();
        ctx.arc(size * 0.42, -size * 0.12, 3, 0, Math.PI * 2);
        ctx.fill();

        // Legs (running fast!)
        ctx.strokeStyle = e.config.color;
        ctx.lineWidth = 4;
        ctx.lineCap = 'round';

        // Front legs
        ctx.save();
        ctx.rotate(legMove);
        ctx.beginPath();
        ctx.moveTo(size * 0.2, size * 0.15);
        ctx.lineTo(size * 0.25, size * 0.35);
        ctx.stroke();
        ctx.restore();

        // Back legs
        ctx.save();
        ctx.rotate(-legMove);
        ctx.beginPath();
        ctx.moveTo(-size * 0.2, size * 0.15);
        ctx.lineTo(-size * 0.25, size * 0.35);
        ctx.stroke();
        ctx.restore();

        // Acorn in mouth
        ctx.fillStyle = '#DEB887';
        ctx.beginPath();
        ctx.ellipse(size * 0.55, -size * 0.05, size * 0.1, size * 0.08, 0.3, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#8B4513';
        ctx.fillRect(size * 0.5, -size * 0.15, size * 0.08, size * 0.06);
      },

      isActive() {
        return this.activeEvent !== null;
      }
    };

    // === TutorialManager Module (T082-T089: Tutorial System) ===
    const TutorialManager = {
      steps: [
        {
          title: "Welcome to Howlett Golf Chaos!",
          text: "Let's learn by playing a practice hole! Tap 'Next' to begin.",
          highlight: null,
          action: null,
          waitForAction: false
        },
        {
          title: "Step 1: Choose Your Club",
          text: "The GLOWING club in your bag is recommended for the distance. On short holes like par 3s, use irons instead of driver! You can change clubs anytime.",
          highlight: 'club-selector',
          action: null,
          waitForAction: false
        },
        {
          title: "Step 2: The Tee Shot",
          text: "Now drag BACKWARD from the ball and release to shoot FORWARD! The longer you drag, the more power.",
          highlight: 'game-canvas',
          action: 'swing',
          waitForAction: true
        },
        {
          title: "Nice Shot!",
          text: "Great job! The ball moves opposite to your drag direction. Notice how the recommended club changed based on your new distance.",
          highlight: null,
          action: null,
          waitForAction: false
        },
        {
          title: "Watch the Wind!",
          text: "See the WIND indicator in the top-right? The arrow shows wind direction and speed. Strong winds will push your ball off course - aim to compensate!",
          highlight: 'wind-indicator',
          action: null,
          waitForAction: false
        },
        {
          title: "Step 3: Switch Clubs",
          text: "Tap a different club to select it. Driver hits farthest, Woods/Irons for mid-range, Wedge for short shots, Putter on the green.",
          highlight: 'club-selector',
          action: 'selectClub',
          waitForAction: true
        },
        {
          title: "Step 4: Sink the Ball!",
          text: "Keep hitting until you get the ball in the hole! Watch the distance display and switch clubs as needed.",
          highlight: null,
          action: 'holeComplete',
          waitForAction: true
        },
        {
          title: "Hole Complete!",
          text: "Awesome! Remember: Choose the right club for each shot based on distance. The glowing club is your best choice. Now you're ready for the real game!",
          highlight: null,
          action: null,
          waitForAction: false
        }
      ],

      currentStep: 0,
      isActive: false,
      gameEngine: null,
      waitingForAction: false,

      start(gameEngine) {
        this.gameEngine = gameEngine;
        this.currentStep = 0;
        this.isActive = true;
        this.waitingForAction = false;

        // Start a tutorial practice hole
        this.startPracticeHole();

        this.showStep();
        document.getElementById('tutorial-overlay').classList.remove('hidden');
      },

      startPracticeHole() {
        if (!this.gameEngine) return;

        const canvas = this.gameEngine.canvas;
        const canvasRect = canvas.getBoundingClientRect();

        // Use the real course generator to create a proper hole
        CourseGenerator.init(12345); // Fixed seed for consistent tutorial

        // Generate hole 1 (a short par 3) but clear obstacles for easier practice
        const practiceHole = CourseGenerator.generateHole(1, canvasRect.width, canvasRect.height);
        practiceHole.obstacles = []; // Remove obstacles for tutorial
        practiceHole.holeNumber = 0; // Mark as tutorial hole

        // Use the engine's createBall method for proper ball setup
        const ball = this.gameEngine.createBall(practiceHole, 'white');

        // Get recommended club for the tutorial hole distance
        const recommendedClub = ClubSystem.getRecommendedClub(ball, practiceHole.holePosition);

        this.gameEngine.gameState = {
          currentHole: practiceHole,
          round: {
            roundId: 'tutorial',
            startTime: Date.now(),
            endTime: null,
            currentHoleNumber: 0,
            isComplete: false,
            holeScores: [],
            totalStrokes: 0,
            totalPar: 0,
            scoreRelativeToPar: 0,
            currentStrokeCount: 0
          },
          ball: ball,
          selectedClub: recommendedClub,
          seed: 12345,
          playerName: 'Student',
          isTutorial: true
        };

        this.gameEngine.updateUI();
        this.gameEngine.updateClubSelector();

        // Generate wind for tutorial (moderate wind so it's noticeable)
        WindSystem.generateWind(3); // Use hole 3 params for moderate wind

        // Hide menu, show game
        document.getElementById('menu-overlay').classList.add('hidden');
        document.getElementById('club-selector-container').style.display = 'block';
      },

      showStep() {
        const step = this.steps[this.currentStep];
        document.getElementById('tutorial-title').textContent = step.title;
        document.getElementById('tutorial-text').textContent = step.text;
        document.getElementById('tutorial-progress').textContent =
          `Step ${this.currentStep + 1} of ${this.steps.length}`;

        // Update button visibility based on whether we're waiting for action
        const nextBtn = document.getElementById('tutorial-next-btn');
        const skipBtn = document.getElementById('tutorial-skip-btn');

        if (step.waitForAction) {
          nextBtn.style.display = 'none';
          this.waitingForAction = true;
        } else {
          nextBtn.style.display = 'inline-block';
          nextBtn.textContent = this.currentStep === this.steps.length - 1 ? "Start Game!" : "Next";
          this.waitingForAction = false;
        }

        // Handle highlighting
        this.unhighlightAll();
        if (step.highlight) {
          this.highlightElement(step.highlight);
        }
      },

      // Called by game when player performs an action
      onAction(actionType) {
        if (!this.isActive || !this.waitingForAction) return;

        const step = this.steps[this.currentStep];
        if (step.action === actionType) {
          // Action completed! Move to next step
          setTimeout(() => {
            this.nextStep();
          }, actionType === 'holeComplete' ? 1500 : 500);
        }
      },

      // Check if ball is allowed to go in hole (only on the "Sink the Ball!" step)
      canBallEnterHole() {
        if (!this.isActive) return true; // Not in tutorial, allow
        // Step 6 (index 6) is "Sink the Ball!" step that waits for holeComplete
        return this.currentStep >= 6;
      },

      nextStep() {
        this.unhighlightAll();
        this.currentStep++;

        if (this.currentStep >= this.steps.length) {
          this.complete();
        } else {
          this.showStep();
        }
      },

      skip() {
        this.unhighlightAll();
        this.complete();
      },

      complete() {
        this.isActive = false;
        this.currentStep = 0;
        this.waitingForAction = false;
        document.getElementById('tutorial-overlay').classList.add('hidden');
        document.getElementById('tutorial-next-btn').style.display = 'inline-block';

        // Mark tutorial as completed
        const settings = StorageManager.loadSettings();
        settings.tutorialCompleted = true;
        StorageManager.saveSettings(settings);

        // Return to main menu - hide all game UI first, then show menu
        if (this.gameEngine) {
          // Hide all game UI elements
          document.getElementById('club-selector-container').style.display = 'none';
          document.getElementById('scoreboard').style.display = 'none';
          document.getElementById('ball-state').style.display = 'none';
          document.getElementById('wind-indicator').classList.add('hidden');
          document.getElementById('distance-display').classList.add('hidden');

          // Clear game state
          this.gameEngine.gameState = null;

          // Show menu after a brief delay to prevent flicker
          setTimeout(() => {
            document.getElementById('menu-overlay').classList.remove('hidden');
            // Restore UI element display for next game
            document.getElementById('scoreboard').style.display = '';
            document.getElementById('ball-state').style.display = '';
          }, 100);
        }
      },

      highlightElement(id) {
        const element = document.getElementById(id);
        if (element) {
          element.classList.add('tutorial-highlight');
        }
      },

      unhighlightAll() {
        document.querySelectorAll('.tutorial-highlight').forEach(el => {
          el.classList.remove('tutorial-highlight');
        });
      }
    };

    // === GameEngine Module (T007, T011, T013-T025) ===
    class GameEngine {
      constructor(canvas) {
        this.canvas = canvas;
        this.isRunning = false;
        this.isPaused = false;
        this.lastFrameTime = 0;
        this.fps = 60;
        this.debugMode = false;
        this.holeCompleting = false;
        this.animationTime = 0; // Global animation time for visual effects

        this.gameState = null;

        Renderer.init(canvas);
        InputHandler.init(canvas, this);

        this.checkDebugMode();
      }

      checkDebugMode() {
        const params = new URLSearchParams(window.location.search);
        this.debugMode = params.get('debug') === 'true';
        if (this.debugMode) {
          document.getElementById('debug-info').classList.remove('hidden');
        }
      }

      start() {
        this.isRunning = true;
        this.lastFrameTime = performance.now();
        requestAnimationFrame((t) => this.update(t));
      }

      pause() {
        this.isPaused = true;
      }

      resume() {
        this.isPaused = false;
        this.lastFrameTime = performance.now();
      }

      async startNewRound(seed = null, playerName = 'Player', ballColor = 'white') {
        const usedSeed = seed || Date.now();
        CourseGenerator.init(usedSeed);

        const canvasRect = this.canvas.getBoundingClientRect();
        const hole = CourseGenerator.generateHole(1, canvasRect.width, canvasRect.height);

        const ball = this.createBall(hole, ballColor);

        // Get recommended club for the tee shot based on hole distance
        const recommendedClub = ClubSystem.getRecommendedClub(ball, hole.holePosition);

        this.gameState = {
          currentHole: hole,
          round: {
            roundId: 'round-' + Date.now(),
            startTime: Date.now(),
            endTime: null,
            currentHoleNumber: 1,
            isComplete: false,
            holeScores: [],
            totalStrokes: 0,
            totalPar: 0,
            scoreRelativeToPar: 0,
            currentStrokeCount: 0
          },
          ball: ball,
          selectedClub: recommendedClub,
          seed: usedSeed,
          playerName: playerName,
          ballColor: ballColor
        };

        this.updateUI();
        document.getElementById('menu-overlay').classList.add('hidden');

        // Reset random events for new round
        RandomEventManager.reset();

        // Reset achievement stats for new round
        AchievementManager.resetRoundStats();

        // Generate wind for hole 1
        WindSystem.generateWind(1);

        // Start background music and crowd ambience
        AudioManager.startBackgroundMusic();
        AudioManager.startCrowdAmbience();

        await StorageManager.clearGameState();
      }

      async loadRound() {
        try {
          const savedState = await StorageManager.loadGameState();
          if (!savedState) {
            console.error('No saved game state found');
            return false;
          }

          CourseGenerator.init(savedState.seed);

          const canvasRect = this.canvas.getBoundingClientRect();
          const hole = CourseGenerator.generateHole(
            savedState.round.currentHoleNumber,
            canvasRect.width,
            canvasRect.height
          );

          const ballColor = savedState.ballColor || savedState.ball?.color || 'white';
          this.gameState = {
            currentHole: hole,
            round: savedState.round,
            ball: this.createBall(hole, ballColor),
            selectedClub: savedState.selectedClub,
            seed: savedState.seed,
            ballColor: ballColor
          };

          this.gameState.ball.x = savedState.ball.x;
          this.gameState.ball.y = savedState.ball.y;
          this.gameState.ball.velocityX = savedState.ball.velocityX;
          this.gameState.ball.velocityY = savedState.ball.velocityY;
          this.gameState.ball.isMoving = savedState.ball.isMoving;
          this.gameState.ball.lastSafePosition = savedState.ball.lastSafePosition;

          // Ensure ball is never loaded in a "in hole" state (prevents infinite loop bug)
          this.gameState.ball.inHole = false;
          this.gameState.ball.holeProgress = 0;
          delete this.gameState.ball.holeStartTime;

          this.updateUI();
          this.updateRoundProgress();
          document.getElementById('menu-overlay').classList.add('hidden');

          return true;
        } catch (error) {
          console.error('Failed to load saved game:', error);
          return false;
        }
      }

      createBall(hole, color = 'white') {
        return {
          x: hole.teePosition.x,
          y: hole.teePosition.y,
          velocityX: 0,
          velocityY: 0,
          spin: 0,
          isAirborne: false,
          isMoving: false,
          rotation: 0,
          groundY: hole.teePosition.y,
          holePosition: hole.holePosition,
          distanceFromHole: PhysicsEngine.distance(hole.teePosition, hole.holePosition),
          lastSafePosition: { x: hole.teePosition.x, y: hole.teePosition.y },
          waterPenalty: false,
          color: color
        };
      }

      updateUI() {
        const round = this.gameState.round;
        const hole = this.gameState.currentHole;

        document.getElementById('hole-number').textContent = round.currentHoleNumber;
        document.getElementById('hole-par').textContent = hole.par;
        document.getElementById('stroke-count').textContent = round.currentStrokeCount;
        document.getElementById('total-score').textContent = ScoreKeeper.getScoreDisplay(round.scoreRelativeToPar);

        const club = ClubSystem.getClub(this.gameState.selectedClub);
        document.getElementById('current-club').textContent = club.name;

        // Convert distance from pixels to yards
        const distance = Math.round(this.gameState.ball.distanceFromHole * PIXELS_TO_YARDS);
        document.getElementById('distance-to-hole').textContent = distance;

        // Update real-time distance display in lower right
        const distanceDisplay = document.getElementById('distance-display');
        const distanceValue = document.getElementById('distance-value');
        if (distanceDisplay && distanceValue) {
          distanceValue.textContent = distance;
          distanceDisplay.classList.remove('hidden');
        }

        this.updateClubSelector();
      }

      selectClub(clubId) {
        if (!this.gameState || !this.gameState.ball) return;
        if (this.gameState.ball.isMoving) return;

        this.gameState.selectedClub = clubId;

        const club = ClubSystem.getClub(clubId);
        document.getElementById('current-club').textContent = club.name;

        this.updateClubSelector();

        // Notify tutorial of club selection
        if (TutorialManager.isActive) {
          TutorialManager.onAction('selectClub');
        }
      }

      updateClubSelector() {
        if (!this.gameState) return;

        const isFirstStroke = this.gameState.round.currentStrokeCount === 0;
        const availableClubs = ClubSystem.getAvailableClubs(isFirstStroke);
        const selectedClub = this.gameState.selectedClub;

        const clubSelector = document.getElementById('club-selector');
        clubSelector.innerHTML = '';

        const recommendedClub = ClubSystem.getRecommendedClub(this.gameState.ball, this.gameState.currentHole.holePosition);

        // Helper to get club type for styling
        const getClubType = (clubId) => {
          if (clubId === 'driver') return 'driver';
          if (clubId.includes('wood')) return 'wood';
          if (clubId === 'wedge') return 'wedge';
          if (clubId === 'putter') return 'putter';
          return 'iron';
        };

        // Helper to get short label for club head
        const getClubLabel = (club) => {
          if (club.id === 'driver') return 'D';
          if (club.id === 'wood3') return '3W';
          if (club.id === 'wood5') return '5W';
          if (club.id === 'wedge') return 'W';
          if (club.id === 'putter') return 'P';
          // Irons: extract number
          const match = club.id.match(/iron(\d)/);
          return match ? match[1] : club.name.charAt(0);
        };

        for (const club of availableClubs) {
          const maxDistance = ClubSystem.getMaxDistance(club.id);
          const clubType = getClubType(club.id);
          const label = getClubLabel(club);

          const slot = document.createElement('div');
          slot.className = 'club-slot';
          slot.dataset.club = club.id;

          // Add tier class for styling
          const clubTier = ShopSystem.getOwnedTier(club.id);
          slot.classList.add(`tier-${clubTier}`);

          if (club.id === selectedClub) {
            slot.classList.add('selected');
          }

          if (club.id === recommendedClub) {
            slot.classList.add('recommended');
          }

          slot.innerHTML = `
            <div class="club-head ${clubType}">${label}</div>
            <div class="club-shaft"></div>
            <div class="club-distance">${maxDistance}yd</div>
          `;

          slot.addEventListener('click', () => this.selectClub(club.id));
          clubSelector.appendChild(slot);
        }

        const clubContainer = document.getElementById('club-selector-container');
        clubContainer.style.display = 'block';
      }

      executeSwing(swingVector) {
        if (!this.gameState || !this.gameState.ball) return;
        if (this.gameState.ball.isMoving) return;
        if (this.gameState.round.isComplete) return; // Prevent strokes after round ends

        // Track tee shot position for long drive achievement
        const isTeeShot = this.gameState.round.currentStrokeCount === 0;
        if (isTeeShot) {
          this.gameState.ball.teePosition = { x: this.gameState.ball.x, y: this.gameState.ball.y };
        }

        this.gameState.ball.lastSafePosition = { x: this.gameState.ball.x, y: this.gameState.ball.y };
        this.gameState.ball.waterPenalty = false;

        const modifiedSwing = ClubSystem.applyClubToSwing(swingVector, this.gameState.selectedClub);

        // Apply sand penalty - 50% power reduction when hitting from bunker
        if (this.gameState.ball.inSand) {
          modifiedSwing.power *= 0.5;
          this.gameState.ball.leavingSand = true;  // Flag to allow escape from sand
        }

        PhysicsEngine.applySwing(this.gameState.ball, modifiedSwing);
        ScoreKeeper.recordStroke(this.gameState.round);

        this.gameState.strikeFlash = { active: true, progress: 0, startTime: performance.now() };

        AudioManager.playHitSound(swingVector.power);

        if (this.gameState.ball.waterPenalty) {
          ScoreKeeper.recordStroke(this.gameState.round);
        }

        // Check for random event trigger (streaker) - not during tutorial, only if events enabled
        const eventsEnabled = StorageManager.loadSettings().eventsEnabled !== false;
        if (!this.gameState.isTutorial && eventsEnabled) {
          RandomEventManager.checkTrigger();
        }

        // Notify tutorial of swing
        if (TutorialManager.isActive) {
          TutorialManager.onAction('swing');
        }

        // Only save if ball is not in hole (prevents corrupted state on reload)
        if (!this.gameState.ball.inHole && !this.holeCompleting && !this.gameState.isTutorial) {
          StorageManager.saveGameState(this.gameState);
        }
      }

      update(timestamp) {
        if (!this.isRunning) return;

        // Cap deltaTime to prevent physics jumps on slow devices or when resuming
        const rawDeltaTime = (timestamp - this.lastFrameTime) / 1000;
        const deltaTime = Math.min(rawDeltaTime, 1/30);
        this.lastFrameTime = timestamp;

        if (!this.isPaused && this.gameState) {
          this.updateFPS(deltaTime);

          // Update animation time for visual effects
          this.animationTime += deltaTime;

          if (this.gameState.strikeFlash && this.gameState.strikeFlash.active) {
            const elapsed = timestamp - this.gameState.strikeFlash.startTime;
            this.gameState.strikeFlash.progress = Math.min(elapsed / 300, 1);
            if (this.gameState.strikeFlash.progress >= 1) {
              this.gameState.strikeFlash.active = false;
            }
          }

          if (this.gameState.ball) {
            const obstacles = this.gameState.currentHole.obstacles || [];
            PhysicsEngine.updateBall(this.gameState.ball, deltaTime, obstacles);

            // Check if ball can enter hole (tutorial blocks until "Sink the Ball!" step)
            const canEnterHole = TutorialManager.canBallEnterHole();
            if (PhysicsEngine.isBallInHole(this.gameState.ball) && !this.holeCompleting && canEnterHole) {
              if (!this.gameState.ball.inHole) {
                this.gameState.ball.inHole = true;
                this.gameState.ball.holeProgress = 0;
                this.gameState.ball.holeStartTime = timestamp;
                AudioManager.playHoleSound();
                AudioManager.playCrowdClap();  // Polite applause for holing out
              }
            }

            if (this.gameState.ball.inHole) {
              const elapsed = timestamp - this.gameState.ball.holeStartTime;
              this.gameState.ball.holeProgress = Math.min(elapsed / 800, 1);

              if (this.gameState.ball.holeProgress >= 1 && !this.holeCompleting && !this.gameState.round.isComplete) {
                this.completeHole();
              }
            }

            this.updateBallStateIndicator();
          }

          // Update confetti particles
          ConfettiSystem.update(deltaTime);

          // Update wind gusts
          WindSystem.update(deltaTime);

          // Update random events (streaker)
          RandomEventManager.update(deltaTime);

          Renderer.renderFrame(this.gameState, this.animationTime);
        }

        requestAnimationFrame((t) => this.update(t));
      }

      updateBallStateIndicator() {
        const ball = this.gameState.ball;
        const stateElement = document.getElementById('ball-state');
        if (!stateElement) return;

        const wasMoving = this.ballWasMoving || false;
        this.ballWasMoving = ball.isMoving;

        // Update distance display in real-time
        const distance = Math.round(ball.distanceFromHole * PIXELS_TO_YARDS); // Convert to yards
        const distanceValue = document.getElementById('distance-value');
        if (distanceValue) {
          distanceValue.textContent = distance;
        }

        if (ball.isMoving) {
          const speed = Math.sqrt(ball.velocityX * ball.velocityX + ball.velocityY * ball.velocityY);
          if (speed > 100) {
            stateElement.textContent = '🏌️ Flying';
            stateElement.style.color = '#FF6B35';
          } else {
            stateElement.textContent = '⛳ Rolling';
            stateElement.style.color = '#4ECDC4';
          }
        } else if (ball.inSand) {
          stateElement.textContent = '🏖️ In Bunker (50% power)';
          stateElement.style.color = '#D4A574';
        } else {
          stateElement.textContent = '🔴 Ready';
          stateElement.style.color = '#2E8B57';

          if (wasMoving && !ball.isMoving) {
            this.updateClubSelector();

            // Check for long drive achievement (after tee shot)
            if (ball.teePosition && this.gameState.round.currentStrokeCount === 1) {
              const dx = ball.x - ball.teePosition.x;
              const dy = ball.y - ball.teePosition.y;
              const distancePixels = Math.sqrt(dx * dx + dy * dy);
              const distanceYards = Math.round(distancePixels * PIXELS_TO_YARDS);
              AchievementManager.onDriveHit(distanceYards);
              ball.teePosition = null; // Clear after checking
            }
          }
        }
      }

      completeHole() {
        const round = this.gameState.round;
        const hole = this.gameState.currentHole;

        // Prevent completing hole without hitting the ball
        if (round.currentStrokeCount === 0) {
          return;
        }

        // Prevent multiple simultaneous completions
        if (this.holeCompleting) {
          return;
        }

        this.holeCompleting = true;

        // Notify tutorial of hole completion
        if (TutorialManager.isActive) {
          TutorialManager.onAction('holeComplete');
          // Skip the normal hole complete flow for tutorial
          this.holeCompleting = false;
          return;
        }

        const holeScore = ScoreKeeper.completeHole(round, hole);

        this.updateRoundProgress();

        const scoreName = ScoreKeeper.getScoreName(holeScore.scoreRelativeToPar);

        // Notify achievement system
        AchievementManager.onHoleComplete(
          hole.holeNumber,
          holeScore.strokes,
          hole.par,
          AchievementManager.stats.hadWater,
          AchievementManager.stats.hadSand,
          0 // putts not tracked
        );

        // Reset hazard tracking for next hole
        AchievementManager.stats.hadWater = false;
        AchievementManager.stats.hadSand = false;

        // Spawn confetti at hole position for any completion
        const holeX = hole.holePosition.x;
        const holeY = hole.holePosition.y;
        ConfettiSystem.spawn(holeX, holeY, 25, 'standard');

        if (holeScore.scoreRelativeToPar <= -1 || holeScore.strokes === 1) {
          this.celebrateGoodScore(holeScore.scoreRelativeToPar, holeX, holeY, holeScore.strokes);
        }

        setTimeout(() => {
          this.showHoleCompleteModal(hole, round, holeScore, scoreName);
        }, 500);
      }

      showHoleCompleteModal(hole, round, holeScore, scoreName) {
        // Update modal content
        document.getElementById('hole-complete-number').textContent = hole.holeNumber;
        document.getElementById('hole-complete-strokes').textContent = holeScore.strokes;
        document.getElementById('hole-complete-par').textContent = hole.par;
        document.getElementById('hole-complete-total').textContent = ScoreKeeper.getScoreDisplay(round.scoreRelativeToPar);

        // Set score name and color class
        const scoreNameEl = document.getElementById('hole-complete-score-name');
        scoreNameEl.textContent = scoreName;
        scoreNameEl.className = 'hole-complete-score-name';

        if (holeScore.scoreRelativeToPar <= -2) {
          scoreNameEl.classList.add('eagle');
        } else if (holeScore.scoreRelativeToPar === -1) {
          scoreNameEl.classList.add('birdie');
        } else if (holeScore.scoreRelativeToPar === 0) {
          scoreNameEl.classList.add('par');
        } else if (holeScore.scoreRelativeToPar === 1) {
          scoreNameEl.classList.add('bogey');
        } else {
          scoreNameEl.classList.add('double-bogey');
        }

        // Update button text based on whether this is the last hole
        const btn = document.getElementById('hole-complete-btn');
        const isLastHole = round.currentHoleNumber >= 9;
        btn.textContent = isLastHole ? 'View Scorecard' : 'Next Hole';

        // Show modal
        document.getElementById('hole-complete-overlay').classList.remove('hidden');

        // Set up button handler (remove old listener first)
        const newBtn = btn.cloneNode(true);
        btn.parentNode.replaceChild(newBtn, btn);

        newBtn.addEventListener('click', () => {
          document.getElementById('hole-complete-overlay').classList.add('hidden');

          if (isLastHole) {
            round.isComplete = true;
            round.endTime = Date.now();
            // Notify achievement system of round completion
            AchievementManager.onRoundComplete(round.scoreRelativeToPar);

            // Award Golf Bucks for completing round
            let roundReward = 100; // Base reward
            if (round.scoreRelativeToPar < 0) {
              // Bonus for under par: 50 GB per stroke under
              roundReward += Math.abs(round.scoreRelativeToPar) * 50;
              ShopSystem.addBucks(roundReward, 'Round Complete (Under Par!)');
            } else {
              ShopSystem.addBucks(roundReward, 'Round Complete');
            }

            this.showRoundSummary();
          } else {
            this.advanceToNextHole();
          }
        });
      }

      // === T098: Play cheer for exceptional shots ===
      celebrateGoodScore(scoreRelativeToPar, holeX, holeY, strokes) {
        if (strokes === 1) {
          // Hole in one!
          console.log('🎯 HOLE IN ONE! 🎯');
          AudioManager.playCheerSound();
          AudioManager.playCrowdCheer();  // Crowd goes wild!
          ConfettiSystem.spawn(holeX, holeY, 80, 'eagle');
          ShopSystem.addBucks(500, 'Hole in One!');
        } else if (scoreRelativeToPar <= -2) {
          console.log('🎉 EAGLE OR BETTER! 🎉');
          AudioManager.playCheerSound();
          AudioManager.playCrowdCheer();  // Crowd cheers for eagle
          // Extra confetti burst for eagle or better
          ConfettiSystem.spawn(holeX, holeY, 60, 'eagle');
          ShopSystem.addBucks(150, 'Eagle!');
        } else if (scoreRelativeToPar === -1) {
          console.log('🎊 BIRDIE! 🎊');
          AudioManager.playCheerSound();
          AudioManager.playCrowdCheer();  // Crowd cheers for birdie
          // Extra confetti for birdie
          ConfettiSystem.spawn(holeX, holeY, 40, 'birdie');
          ShopSystem.addBucks(50, 'Birdie!');
        }
      }

      updateRoundProgress() {
        const summary = ScoreKeeper.getRoundSummary(this.gameState.round);
        const progressElement = document.getElementById('round-progress');
        const progressText = document.getElementById('progress-text');

        if (progressElement && progressText) {
          progressText.textContent = `${summary.completedHoles}/9 holes`;
          progressElement.classList.remove('hidden');
        }
      }

      advanceToNextHole() {
        const round = this.gameState.round;
        round.currentHoleNumber++;
        round.currentStrokeCount = 0;

        const canvasRect = this.canvas.getBoundingClientRect();
        const hole = CourseGenerator.generateHole(round.currentHoleNumber, canvasRect.width, canvasRect.height);

        this.gameState.currentHole = hole;
        this.gameState.ball = this.createBall(hole, this.gameState.ballColor || 'white');

        // Auto-select recommended club for the new hole's tee shot based on distance
        const recommendedClub = ClubSystem.getRecommendedClub(this.gameState.ball, hole.holePosition);
        this.gameState.selectedClub = recommendedClub;

        // Generate new wind for this hole
        WindSystem.generateWind(round.currentHoleNumber);

        this.updateUI();
        this.updateClubSelector();

        // Reset flag to allow next hole completion
        this.holeCompleting = false;

        StorageManager.saveGameState(this.gameState);
      }

      async showRoundSummary() {
        const round = this.gameState.round;
        const summary = ScoreKeeper.getRoundSummary(round);

        let tableHTML = '<table class="scorecard-table">';
        tableHTML += '<tr><th>Hole</th><th>Par</th><th>Strokes</th><th>Score</th></tr>';

        for (const holeScore of round.holeScores) {
          const scoreClass = this.getScoreClass(holeScore.scoreRelativeToPar);
          const scoreDisplay = ScoreKeeper.getScoreDisplay(holeScore.scoreRelativeToPar);

          tableHTML += `<tr>`;
          tableHTML += `<td>${holeScore.holeNumber}</td>`;
          tableHTML += `<td>${holeScore.par}</td>`;
          tableHTML += `<td>${holeScore.strokes}</td>`;
          tableHTML += `<td class="${scoreClass}">${scoreDisplay}</td>`;
          tableHTML += `</tr>`;
        }

        tableHTML += '</table>';
        tableHTML += `<div style="margin-top: 20px; font-size: 18px;">`;
        tableHTML += `<strong>Total Strokes:</strong> ${summary.totalStrokes}<br>`;
        tableHTML += `<strong>Total Par:</strong> ${summary.totalPar}<br>`;
        tableHTML += `<strong>Final Score:</strong> <span style="color: ${ScoreKeeper.getScoreColor(summary.scoreRelativeToPar)}; font-weight: bold; font-size: 24px;">${ScoreKeeper.getScoreDisplay(summary.scoreRelativeToPar)}</span>`;
        tableHTML += `</div>`;

        document.getElementById('scorecard-content').innerHTML = tableHTML;
        document.getElementById('scorecard-overlay').classList.remove('hidden');
        document.getElementById('menu-overlay').classList.remove('hidden');

        // === T078: Save to leaderboard ===
        await this.saveToLeaderboard(summary);

        // Reset flag for next round
        this.holeCompleting = false;

        StorageManager.clearGameState();
      }

      // === T078, T080: Save round to leaderboard (global API) ===
      async saveToLeaderboard(summary) {
        const playerName = this.gameState?.playerName || 'Player';

        try {
          // Try to save to global leaderboard API
          const response = await fetch('/api/leaderboard', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              playerName: playerName,
              scoreRelativeToPar: summary.scoreRelativeToPar,
              totalStrokes: summary.totalStrokes
            })
          });

          if (response.ok) {
            const result = await response.json();
            console.log('Score saved to global leaderboard');

            // Check if made top 3
            if (result.rank && result.rank <= 3) {
              const medals = ['🥇', '🥈', '🥉'];
              console.log(`${medals[result.rank - 1]} NEW TOP SCORE! Rank #${result.rank}`);
            }
          } else {
            throw new Error('API response not ok');
          }
        } catch (error) {
          console.error('Failed to save to global leaderboard, saving locally:', error);
          // Fallback to local storage if API fails
          try {
            const entry = {
              scoreRelativeToPar: summary.scoreRelativeToPar,
              totalStrokes: summary.totalStrokes,
              completedAt: Date.now(),
              playerName: playerName
            };
            await StorageManager.addLeaderboardEntry(entry);
          } catch (localError) {
            console.error('Failed to save locally too:', localError);
          }
        }
      }

      // === T077, T081: Display leaderboard (global API with local fallback) ===
      static async showLeaderboard() {
        const content = document.getElementById('leaderboard-content');
        content.innerHTML = '<div class="leaderboard-empty">Loading...</div>';
        document.getElementById('leaderboard-overlay').classList.remove('hidden');

        let leaderboard = [];

        try {
          // Try to fetch from global API first
          const response = await fetch('/api/leaderboard');
          if (response.ok) {
            leaderboard = await response.json();
          } else {
            throw new Error('API response not ok');
          }
        } catch (error) {
          console.error('Failed to fetch global leaderboard, trying local:', error);
          // Fallback to local storage
          try {
            leaderboard = await StorageManager.getLeaderboard();
          } catch (localError) {
            console.error('Failed to load local leaderboard:', localError);
          }
        }

        if (!leaderboard || leaderboard.length === 0) {
          content.innerHTML = '<div class="leaderboard-empty">No scores yet. Complete a round to get on the leaderboard!</div>';
        } else {
          let tableHTML = '<table class="leaderboard-table">';
          tableHTML += '<tr><th>Rank</th><th>Player</th><th>Score</th><th>Strokes</th><th>Date</th></tr>';

          leaderboard.forEach((entry, index) => {
            const rank = index + 1;
            const rankClass = rank <= 3 ? `leaderboard-rank-${rank}` : '';
            let scoreClass = 'leaderboard-score-par';
            if (entry.scoreRelativeToPar < 0) scoreClass = 'leaderboard-score-under';
            else if (entry.scoreRelativeToPar > 0) scoreClass = 'leaderboard-score-over';

            const scoreDisplay = ScoreKeeper.getScoreDisplay(entry.scoreRelativeToPar);
            const date = new Date(entry.completedAt).toLocaleDateString();
            // Support both playerName (new) and playerInitials (old local data)
            const playerName = entry.playerName || entry.playerInitials || 'Unknown';

            tableHTML += `<tr>`;
            tableHTML += `<td class="leaderboard-rank ${rankClass}">#${rank}</td>`;
            tableHTML += `<td>${playerName}</td>`;
            tableHTML += `<td class="${scoreClass}">${scoreDisplay}</td>`;
            tableHTML += `<td>${entry.totalStrokes}</td>`;
            tableHTML += `<td>${date}</td>`;
            tableHTML += `</tr>`;
          });

          tableHTML += '</table>';
          content.innerHTML = tableHTML;
        }
      }

      getScoreClass(scoreRelativeToPar) {
        if (scoreRelativeToPar <= -2) return 'score-eagle';
        if (scoreRelativeToPar === -1) return 'score-birdie';
        if (scoreRelativeToPar === 0) return 'score-par';
        if (scoreRelativeToPar === 1) return 'score-bogey';
        return 'score-double';
      }

      updateFPS(deltaTime) {
        this.fps = Math.round(1 / deltaTime);
        if (this.debugMode) {
          const debugDiv = document.getElementById('debug-info');
          debugDiv.innerHTML = `FPS: ${this.fps}<br>Ball: (${Math.round(this.gameState.ball.x)}, ${Math.round(this.gameState.ball.y)})<br>Velocity: (${Math.round(this.gameState.ball.velocityX)}, ${Math.round(this.gameState.ball.velocityY)})<br>Moving: ${this.gameState.ball.isMoving}`;
        }
      }
    }

    // === Initialize Game (T005, T011, T012) ===
    window.addEventListener('DOMContentLoaded', async () => {
      console.log('DOM Content Loaded');

      const canvas = document.getElementById('game-canvas');
      if (!canvas) {
        console.error('Canvas element not found!');
        return;
      }

      console.log('Canvas found, initializing game engine...');

      let gameEngine;
      try {
        gameEngine = new GameEngine(canvas);
        window.gameEngine = gameEngine; // Expose for testing
        console.log('Game engine initialized successfully');
      } catch (error) {
        console.error('Error initializing game engine:', error);
        alert('Error initializing game: ' + error.message);
        return;
      }

      const newGameBtn = document.getElementById('new-game-btn');
      const resumeGameBtn = document.getElementById('resume-game-btn');

      if (!newGameBtn) {
        console.error('New game button not found!');
        return;
      }

      AudioManager.init();
      AchievementManager.init();
      ShopSystem.init();
      ShopSystem.updateBalanceDisplay();

      // Set up shop click handlers using event delegation (handles dynamically created buttons)
      const shopOverlayEl = document.getElementById('shop-overlay');

      document.getElementById('shop-clubs-grid').addEventListener('click', function(e) {
        if (e.target.classList.contains('shop-buy-btn') && !e.target.disabled) {
          const clubId = e.target.dataset.club;
          e.target.disabled = true;
          e.target.textContent = '...';

          if (ShopSystem.purchaseClub(clubId)) {
            // Literally close and reopen shop to force refresh
            shopOverlayEl.classList.add('hidden');
            ShopSystem.renderShop();
            shopOverlayEl.classList.remove('hidden');
          } else {
            e.target.disabled = false;
            e.target.textContent = 'Upgrade';
          }
        }
      });

      document.getElementById('shop-balls-grid').addEventListener('click', function(e) {
        if (e.target.classList.contains('shop-buy-btn') && !e.target.disabled) {
          const skinId = e.target.dataset.skin;
          e.target.disabled = true;
          e.target.textContent = '...';

          if (ShopSystem.purchaseBallSkin(skinId)) {
            // Literally close and reopen shop to force refresh
            shopOverlayEl.classList.add('hidden');
            ShopSystem.renderShop();
            shopOverlayEl.classList.remove('hidden');
          } else {
            e.target.disabled = false;
            e.target.textContent = 'Buy';
          }
        }
      });

      // Add click sound to all menu buttons and start music on first interaction
      document.addEventListener('click', (e) => {
        if (e.target.classList.contains('menu-button')) {
          AudioManager.unlock(); // Ensure audio is unlocked
          AudioManager.playClickSound();
          // Start background music on first menu interaction (will be ignored if already playing)
          AudioManager.startBackgroundMusic();
        }
      });

      try {
        await StorageManager.init();
        const hasSavedGame = await StorageManager.hasSavedGame();

        if (hasSavedGame) {
          resumeGameBtn.classList.remove('hidden');
        } else {
          resumeGameBtn.classList.add('hidden');
        }
      } catch (error) {
        console.error('Error checking for saved game:', error);
        resumeGameBtn.classList.add('hidden');
      }

      // Name entry modal elements
      const nameEntryOverlay = document.getElementById('name-entry-overlay');
      const playerNameInput = document.getElementById('player-name-input');
      const startWithNameBtn = document.getElementById('start-with-name-btn');
      const cancelNameEntryBtn = document.getElementById('cancel-name-entry-btn');
      const ballColorOptions = document.getElementById('ball-color-options');

      // Load last used name and ball color from localStorage
      const lastPlayerName = localStorage.getItem('golf-player-name') || '';
      let lastBallColor = localStorage.getItem('golf-ball-color') || 'white';
      playerNameInput.value = lastPlayerName;

      // Set up ball color selection
      let selectedBallColor = lastBallColor;

      // Function to dynamically render ball color options based on owned skins
      function renderBallColorPicker() {
        ballColorOptions.innerHTML = '';
        const ownedSkins = ShopSystem.ownedBallSkins;

        // If selected color is not owned, reset to white
        if (!ownedSkins.includes(selectedBallColor)) {
          selectedBallColor = 'white';
          lastBallColor = 'white';
        }

        for (const skinId of ownedSkins) {
          const colors = BallColors[skinId] || PremiumBallColors[skinId] || BallColors.white;
          const isAnimated = PremiumBallColors[skinId]?.animated;

          const option = document.createElement('div');
          option.className = 'ball-color-option' + (skinId === selectedBallColor ? ' selected' : '');
          if (isAnimated) option.classList.add('animated-ball');
          option.dataset.color = skinId;
          option.style.background = `linear-gradient(135deg, ${colors.highlight} 0%, ${colors.base} 100%)`;

          ballColorOptions.appendChild(option);
        }
      }

      // Initial render
      renderBallColorPicker();

      // Ball color click handlers (using event delegation)
      ballColorOptions.addEventListener('click', (e) => {
        const colorOption = e.target.closest('.ball-color-option');
        if (!colorOption) return;

        // Update selection
        ballColorOptions.querySelectorAll('.ball-color-option').forEach(btn => btn.classList.remove('selected'));
        colorOption.classList.add('selected');
        selectedBallColor = colorOption.dataset.color;
      });

      newGameBtn.addEventListener('click', () => {
        console.log('New Game button clicked');
        AudioManager.unlock();
        // Re-render ball picker to show any newly purchased skins
        renderBallColorPicker();
        // Show name entry modal instead of starting immediately
        nameEntryOverlay.classList.remove('hidden');
        playerNameInput.focus();
        playerNameInput.select();
      });

      // Handle starting game with name
      const startGameWithName = async () => {
        const playerName = playerNameInput.value.trim() || 'Player';
        console.log('Starting game with player:', playerName, 'ball color:', selectedBallColor);

        // Save name and ball color for next time
        localStorage.setItem('golf-player-name', playerName);
        localStorage.setItem('golf-ball-color', selectedBallColor);

        // Hide name entry modal
        nameEntryOverlay.classList.add('hidden');

        try {
          await gameEngine.startNewRound(null, playerName, selectedBallColor);
          gameEngine.start();
          resumeGameBtn.classList.add('hidden');
          console.log('Game started successfully');
        } catch (error) {
          console.error('Error starting game:', error);
          alert('Error starting game: ' + error.message);
        }
      };

      startWithNameBtn.addEventListener('click', startGameWithName);

      // Allow Enter key to start game
      playerNameInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
          startGameWithName();
        }
      });

      // Cancel button
      cancelNameEntryBtn.addEventListener('click', () => {
        nameEntryOverlay.classList.add('hidden');
      });

      resumeGameBtn.addEventListener('click', async () => {
        console.log('Resume Game button clicked');
        AudioManager.unlock();
        try {
          const loaded = await gameEngine.loadRound();
          if (loaded) {
            gameEngine.start();
            console.log('Game resumed successfully');
          } else {
            alert('Failed to load saved game');
            resumeGameBtn.classList.add('hidden');
          }
        } catch (error) {
          console.error('Error resuming game:', error);
          alert('Error resuming game: ' + error.message);
        }
      });

      // === T081: Leaderboard button handler ===
      const leaderboardBtn = document.getElementById('leaderboard-btn');
      if (leaderboardBtn) {
        leaderboardBtn.addEventListener('click', async () => {
          console.log('Leaderboard button clicked');
          await GameEngine.showLeaderboard();
        });
      }

      // === Music prompt button handler ===
      const musicPromptBtn = document.getElementById('music-prompt-btn');
      if (musicPromptBtn) {
        // Check if music is already playing (from settings)
        const settings = StorageManager.loadSettings();
        if (AudioManager.musicPlaying) {
          musicPromptBtn.innerHTML = '🎵 Music Playing';
          musicPromptBtn.classList.add('playing');
        }

        musicPromptBtn.addEventListener('click', () => {
          AudioManager.unlock();
          const settings = StorageManager.loadSettings();

          if (AudioManager.musicPlaying) {
            // Stop music
            AudioManager.stopBackgroundMusic();
            musicPromptBtn.innerHTML = '🎵 Tap for Music';
            musicPromptBtn.classList.remove('playing');
          } else {
            // Start music (if enabled in settings)
            if (settings.musicEnabled !== false) {
              AudioManager.startBackgroundMusic();
              musicPromptBtn.innerHTML = '🎵 Music Playing';
              musicPromptBtn.classList.add('playing');
            }
          }
          AudioManager.playClickSound();
        });
      }

      // === Settings button handler ===
      const settingsBtn = document.getElementById('settings-btn');
      const settingsOverlay = document.getElementById('settings-overlay');
      const closeSettingsBtn = document.getElementById('close-settings-btn');
      const resetTutorialBtn = document.getElementById('reset-tutorial-btn');

      // Settings toggles
      const settingSound = document.getElementById('setting-sound');
      const settingMusic = document.getElementById('setting-music');
      const settingTrails = document.getElementById('setting-trails');
      const settingEvents = document.getElementById('setting-events');

      // Load current settings into toggles
      function loadSettingsIntoUI() {
        const settings = StorageManager.loadSettings();
        settingSound.checked = settings.soundEnabled !== false;
        settingMusic.checked = settings.musicEnabled !== false;
        settingTrails.checked = settings.trailsEnabled !== false;
        settingEvents.checked = settings.eventsEnabled !== false;
      }

      if (settingsBtn) {
        settingsBtn.addEventListener('click', () => {
          loadSettingsIntoUI();
          settingsOverlay.classList.remove('hidden');
          AudioManager.playClickSound();
        });
      }

      // In-game settings button (accessible during gameplay)
      const ingameSettingsBtn = document.getElementById('ingame-settings-btn');
      if (ingameSettingsBtn) {
        ingameSettingsBtn.addEventListener('click', () => {
          loadSettingsIntoUI();
          settingsOverlay.classList.remove('hidden');
          AudioManager.playClickSound();
        });
      }

      if (closeSettingsBtn) {
        closeSettingsBtn.addEventListener('click', () => {
          settingsOverlay.classList.add('hidden');
          AudioManager.playClickSound();
        });
      }

      // Sound toggle
      if (settingSound) {
        settingSound.addEventListener('change', () => {
          const settings = StorageManager.loadSettings();
          settings.soundEnabled = settingSound.checked;
          StorageManager.saveSettings(settings);
          AudioManager.setMuted(!settingSound.checked);
        });
      }

      // Music toggle
      if (settingMusic) {
        settingMusic.addEventListener('change', () => {
          const settings = StorageManager.loadSettings();
          settings.musicEnabled = settingMusic.checked;
          StorageManager.saveSettings(settings);
          if (settingMusic.checked) {
            AudioManager.startBackgroundMusic();
            if (musicPromptBtn) {
              musicPromptBtn.innerHTML = '🎵 Music Playing';
              musicPromptBtn.classList.add('playing');
            }
          } else {
            AudioManager.stopBackgroundMusic();
            if (musicPromptBtn) {
              musicPromptBtn.innerHTML = '🎵 Tap for Music';
              musicPromptBtn.classList.remove('playing');
            }
          }
        });
      }

      // Trails toggle
      if (settingTrails) {
        settingTrails.addEventListener('change', () => {
          const settings = StorageManager.loadSettings();
          settings.trailsEnabled = settingTrails.checked;
          StorageManager.saveSettings(settings);
        });
      }

      // Events toggle
      if (settingEvents) {
        settingEvents.addEventListener('change', () => {
          const settings = StorageManager.loadSettings();
          settings.eventsEnabled = settingEvents.checked;
          StorageManager.saveSettings(settings);
        });
      }

      // Reset tutorial button
      if (resetTutorialBtn) {
        resetTutorialBtn.addEventListener('click', () => {
          const settings = StorageManager.loadSettings();
          settings.tutorialCompleted = false;
          StorageManager.saveSettings(settings);
          resetTutorialBtn.textContent = 'Done!';
          setTimeout(() => {
            resetTutorialBtn.textContent = 'Reset';
          }, 1500);
          AudioManager.playClickSound();
        });
      }

      // === Achievements button handler ===
      const achievementsBtn = document.getElementById('achievements-btn');
      const achievementsOverlay = document.getElementById('achievements-overlay');
      const closeAchievementsBtn = document.getElementById('close-achievements-btn');
      const achievementsGrid = document.getElementById('achievements-grid');
      const achievementsProgress = document.getElementById('achievements-progress');

      function populateAchievements() {
        const achievements = AchievementManager.achievements;
        const ids = Object.keys(achievements);
        const unlocked = ids.filter(id => achievements[id].unlocked).length;

        achievementsProgress.textContent = `${unlocked} / ${ids.length} unlocked`;

        achievementsGrid.innerHTML = '';
        ids.forEach(id => {
          const a = achievements[id];
          const card = document.createElement('div');
          card.className = `achievement-card ${a.unlocked ? 'unlocked' : 'locked'}`;
          card.innerHTML = `
            <div class="icon">${a.icon}</div>
            <div class="name">${a.name}</div>
            <div class="desc">${a.desc}</div>
          `;
          achievementsGrid.appendChild(card);
        });
      }

      if (achievementsBtn) {
        achievementsBtn.addEventListener('click', () => {
          populateAchievements();
          achievementsOverlay.classList.remove('hidden');
          AudioManager.playClickSound();
        });
      }

      if (closeAchievementsBtn) {
        closeAchievementsBtn.addEventListener('click', () => {
          achievementsOverlay.classList.add('hidden');
          AudioManager.playClickSound();
        });
      }

      // === Shop button handler ===
      const shopBtn = document.getElementById('shop-btn');
      const shopOverlay = document.getElementById('shop-overlay');
      const shopCloseBtn = document.getElementById('shop-close-btn');
      const menuBalance = document.getElementById('menu-balance');

      function openShop() {
        ShopSystem.renderShop();
        shopOverlay.classList.remove('hidden');
        AudioManager.playClickSound();
      }

      if (shopBtn) {
        shopBtn.addEventListener('click', openShop);
      }

      // Clicking balance also opens shop
      if (menuBalance) {
        menuBalance.addEventListener('click', openShop);
      }

      if (shopCloseBtn) {
        shopCloseBtn.addEventListener('click', () => {
          shopOverlay.classList.add('hidden');
          AudioManager.playClickSound();
        });
      }

      // === T082-T089: Tutorial handlers ===
      const tutorialBtn = document.getElementById('tutorial-btn');
      const tutorialNextBtn = document.getElementById('tutorial-next-btn');
      const tutorialSkipBtn = document.getElementById('tutorial-skip-btn');
      const tutorialYesBtn = document.getElementById('tutorial-yes-btn');
      const tutorialNoBtn = document.getElementById('tutorial-no-btn');
      const tutorialPromptOverlay = document.getElementById('tutorial-prompt-overlay');

      // Tutorial button in menu (manual replay)
      if (tutorialBtn) {
        tutorialBtn.addEventListener('click', () => {
          console.log('Tutorial button clicked');
          gameEngine.start(); // Make sure game engine is running
          TutorialManager.start(gameEngine);
        });
      }

      // Tutorial navigation buttons
      if (tutorialNextBtn) {
        tutorialNextBtn.addEventListener('click', () => {
          TutorialManager.nextStep();
        });
      }

      if (tutorialSkipBtn) {
        tutorialSkipBtn.addEventListener('click', () => {
          TutorialManager.skip();
        });
      }

      // First-time tutorial prompt handlers
      if (tutorialYesBtn) {
        tutorialYesBtn.addEventListener('click', () => {
          tutorialPromptOverlay.classList.add('hidden');
          gameEngine.start(); // Make sure game engine is running
          TutorialManager.start(gameEngine);
        });
      }

      if (tutorialNoBtn) {
        tutorialNoBtn.addEventListener('click', () => {
          tutorialPromptOverlay.classList.add('hidden');
          // Mark as completed so we don't ask again
          const settings = StorageManager.loadSettings();
          settings.tutorialCompleted = true;
          StorageManager.saveSettings(settings);
        });
      }

      // Check if first-time user and show tutorial prompt
      const settings = StorageManager.loadSettings();
      if (!settings.tutorialCompleted) {
        tutorialPromptOverlay.classList.remove('hidden');
      }

      // Club selector toggle button handler
      const clubToggleBtn = document.getElementById('club-toggle-btn');
      const clubSelector = document.getElementById('club-selector');
      if (clubToggleBtn && clubSelector) {
        clubToggleBtn.addEventListener('click', () => {
          clubSelector.classList.toggle('minimized');
          clubToggleBtn.textContent = clubSelector.classList.contains('minimized') ? 'Show Clubs' : 'Hide Clubs';
        });
      }

      console.log('Howlett Golf Chaos - Ready!');
    });
  </script>
</body>
</html>
