<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-fullscreen">
  <title>Howlett Golf Chaos</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      user-select: none;
    }

    body {
      width: 100vw;
      height: 100vh;
      overflow: hidden;
      background: #87CEEB;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
      touch-action: none;
    }

    #game-canvas {
      display: block;
      width: 100%;
      height: 100%;
      touch-action: none;
    }

    #ui-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }

    #ui-overlay > * {
      pointer-events: auto;
    }

    #scoreboard {
      position: absolute;
      top: 20px;
      left: 20px;
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.98), rgba(248, 255, 248, 0.95));
      padding: 12px 16px;
      border-radius: 16px;
      font-size: 13px;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.15);
      border: 2px solid rgba(76, 175, 80, 0.3);
      min-width: 140px;
    }

    #scoreboard .score-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding-bottom: 8px;
      margin-bottom: 8px;
      border-bottom: 1px solid rgba(0, 0, 0, 0.1);
    }

    #scoreboard .hole-info {
      font-size: 18px;
      font-weight: bold;
      color: #2E7D32;
    }

    #scoreboard .par-info {
      font-size: 12px;
      color: #666;
      background: rgba(0, 0, 0, 0.05);
      padding: 2px 8px;
      border-radius: 10px;
    }

    .ingame-settings-btn {
      background: rgba(0, 0, 0, 0.1);
      border: none;
      border-radius: 50%;
      width: 28px;
      height: 28px;
      font-size: 14px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background 0.2s;
      margin-left: 8px;
    }

    .ingame-settings-btn:hover {
      background: rgba(0, 0, 0, 0.2);
    }

    #scoreboard .score-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin: 4px 0;
    }

    #scoreboard .score-label {
      color: #666;
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    #scoreboard .score-value {
      font-weight: bold;
      color: #333;
      font-size: 14px;
    }

    #scoreboard .score-value.score-good { color: #4CAF50; }
    #scoreboard .score-value.score-bad { color: #f44336; }

    #scoreboard .club-info {
      margin-top: 8px;
      padding-top: 8px;
      border-top: 1px solid rgba(0, 0, 0, 0.1);
      text-align: center;
    }

    #scoreboard .club-name {
      font-weight: bold;
      color: #1976D2;
      font-size: 14px;
    }

    #scoreboard .distance-info {
      font-size: 11px;
      color: #666;
      margin-top: 2px;
    }

    #ball-state {
      position: absolute;
      top: 20px;
      right: 20px;
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.98), rgba(245, 245, 245, 0.95));
      padding: 8px 16px;
      border-radius: 20px;
      font-size: 14px;
      font-weight: bold;
      box-shadow: 0 3px 10px rgba(0, 0, 0, 0.15);
      border: 2px solid rgba(255, 255, 255, 0.8);
    }

    #powerups-display {
      position: absolute;
      bottom: 120px;
      left: 20px;
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.95), rgba(255, 250, 230, 0.95));
      padding: 8px 12px;
      border-radius: 10px;
      box-shadow: 0 3px 10px rgba(0, 0, 0, 0.15);
      border: 2px solid rgba(255, 215, 0, 0.5);
    }

    #powerups-display .powerups-label {
      font-size: 10px;
      color: #666;
      margin-bottom: 4px;
      text-transform: uppercase;
    }

    #powerups-display .powerups-list {
      display: flex;
      gap: 8px;
    }

    #powerups-display .powerup-item {
      display: flex;
      align-items: center;
      gap: 4px;
      background: rgba(255, 255, 255, 0.8);
      padding: 4px 8px;
      border-radius: 6px;
      font-size: 12px;
    }

    #powerups-display .powerup-icon {
      font-size: 16px;
    }

    #career-player-view {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 100;
      opacity: 0;
      transition: opacity 0.15s ease;
    }
    #career-player-view.visible {
      opacity: 1;
    }
    #career-player-view.hidden {
      opacity: 0;
      pointer-events: none;
    }

    #wind-indicator {
      position: absolute;
      top: 65px;
      right: 20px;
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.98), rgba(240, 248, 255, 0.95));
      padding: 10px 14px;
      border-radius: 12px;
      box-shadow: 0 3px 10px rgba(0, 0, 0, 0.15);
      text-align: center;
      min-width: 70px;
      border: 2px solid rgba(135, 206, 250, 0.5);
    }

    #wind-indicator .wind-label {
      font-size: 10px;
      color: #666;
      margin-bottom: 2px;
      font-weight: bold;
      letter-spacing: 1px;
    }

    #wind-indicator .wind-arrow {
      font-size: 24px;
      line-height: 1;
      transition: transform 0.3s ease;
    }

    #wind-indicator .wind-speed {
      font-size: 12px;
      font-weight: bold;
      color: #333;
      margin-top: 2px;
    }

    #wind-indicator.wind-calm .wind-arrow { color: #4CAF50; }
    #wind-indicator.wind-light .wind-arrow { color: #8BC34A; }
    #wind-indicator.wind-moderate .wind-arrow { color: #FFC107; }
    #wind-indicator.wind-strong .wind-arrow { color: #FF9800; }
    #wind-indicator.wind-extreme .wind-arrow { color: #f44336; }

    /* Achievement notification popup */
    #achievement-popup {
      position: fixed;
      top: -200px;
      left: 50%;
      transform: translateX(-50%);
      background: linear-gradient(135deg, #FFD700, #FFA500);
      padding: 15px 30px;
      border-radius: 12px;
      box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
      z-index: 2000;
      transition: top 0.5s ease-out, visibility 0s 0.5s;
      text-align: center;
      min-width: 250px;
      visibility: hidden;
    }

    #achievement-popup.show {
      top: 20px;
      visibility: visible;
      transition: top 0.5s ease-out, visibility 0s 0s;
    }

    #achievement-popup .achievement-icon {
      font-size: 40px;
      margin-bottom: 5px;
    }

    #achievement-popup .achievement-title {
      font-size: 14px;
      color: #333;
      font-weight: bold;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    #achievement-popup .achievement-name {
      font-size: 20px;
      font-weight: bold;
      color: #000;
      margin: 5px 0;
    }

    #achievement-popup .achievement-desc {
      font-size: 12px;
      color: #555;
    }

    /* Golf Bucks earnings popup */
    .golf-bucks-popup {
      position: fixed;
      top: 80px;
      right: -200px;
      background: linear-gradient(135deg, #4CAF50, #2E7D32);
      color: white;
      padding: 12px 20px;
      border-radius: 8px;
      font-weight: bold;
      font-size: 18px;
      z-index: 2001;
      transition: right 0.4s ease-out;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    }
    .golf-bucks-popup.show {
      right: 20px;
    }
    .golf-bucks-popup small {
      font-size: 12px;
      font-weight: normal;
      opacity: 0.9;
    }

    /* Upgrade popup */
    .upgrade-popup {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) scale(0.8);
      background: linear-gradient(135deg, #FFD700, #FF8F00);
      color: #1a1a1a;
      padding: 20px 35px;
      border-radius: 15px;
      font-size: 18px;
      z-index: 2002;
      opacity: 0;
      transition: all 0.3s ease-out;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.4), 0 0 30px rgba(255, 215, 0, 0.5);
      text-align: center;
    }
    .upgrade-popup.show {
      opacity: 1;
      transform: translate(-50%, -50%) scale(1);
    }
    .upgrade-popup span {
      font-size: 24px;
      margin-right: 8px;
    }
    .upgrade-popup strong {
      color: #1B5E20;
    }

    /* Shop overlay */
    #shop-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.92);
      z-index: 1500;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 15px;
      box-sizing: border-box;
      backdrop-filter: blur(5px);
    }
    #shop-overlay.hidden {
      display: none;
    }

    #shop-modal {
      background: linear-gradient(180deg, #1a1a2e 0%, #0f0f1a 100%);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 16px;
      padding: 0;
      max-width: 500px;
      width: 100%;
      max-height: 85vh;
      overflow: hidden;
      box-shadow: 0 25px 80px rgba(0, 0, 0, 0.6);
    }

    #shop-header {
      background: linear-gradient(135deg, #1B5E20, #0d3810);
      padding: 16px 20px;
      display: flex;
      align-items: center;
      gap: 15px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }
    #shop-header h2 {
      margin: 0;
      color: #fff;
      font-size: 20px;
      flex: 1;
      font-weight: 600;
    }
    #shop-balance-display {
      background: linear-gradient(135deg, #FFD700, #FF9500);
      padding: 8px 16px;
      border-radius: 20px;
      color: #1a1a1a;
      font-weight: 700;
      font-size: 14px;
      box-shadow: 0 2px 10px rgba(255, 215, 0, 0.3);
    }
    .shop-close-x {
      background: rgba(255, 255, 255, 0.1);
      border: none;
      color: #fff;
      font-size: 24px;
      width: 36px;
      height: 36px;
      border-radius: 50%;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
      line-height: 1;
    }
    .shop-close-x:hover {
      background: rgba(255, 100, 100, 0.3);
    }

    /* Shop Tabs */
    #shop-tabs {
      display: flex;
      background: rgba(0, 0, 0, 0.3);
      padding: 0;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }
    .shop-tab {
      flex: 1;
      background: none;
      border: none;
      color: rgba(255, 255, 255, 0.5);
      padding: 14px 8px;
      font-size: 12px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      border-bottom: 3px solid transparent;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    .shop-tab:hover {
      color: rgba(255, 255, 255, 0.8);
      background: rgba(255, 255, 255, 0.05);
    }
    .shop-tab.active {
      color: #4CAF50;
      border-bottom-color: #4CAF50;
      background: rgba(76, 175, 80, 0.1);
    }

    /* Tab Content */
    .shop-tab-content {
      display: none;
    }
    .shop-tab-content.active {
      display: block;
    }
    .shop-tab-header {
      text-align: center;
      margin-bottom: 20px;
      padding-bottom: 15px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }
    .shop-tab-header h3 {
      color: #fff;
      font-size: 18px;
      margin: 0 0 6px 0;
      font-weight: 600;
    }
    .shop-tab-header p {
      color: rgba(255, 255, 255, 0.5);
      font-size: 12px;
      margin: 0;
    }

    #shop-content {
      padding: 20px;
      max-height: calc(85vh - 120px);
      overflow-y: auto;
    }
    #shop-content::-webkit-scrollbar {
      width: 6px;
    }
    #shop-content::-webkit-scrollbar-track {
      background: rgba(255, 255, 255, 0.05);
    }
    #shop-content::-webkit-scrollbar-thumb {
      background: rgba(255, 255, 255, 0.2);
      border-radius: 3px;
    }

    /* Info section */
    #shop-info {
      background: transparent;
      border-radius: 12px;
      padding: 0;
    }
    #shop-info .earn-list {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 8px;
    }
    #shop-info .earn-item {
      background: rgba(255, 255, 255, 0.05);
      padding: 12px 14px;
      border-radius: 10px;
      font-size: 13px;
      color: rgba(255, 255, 255, 0.8);
      display: flex;
      justify-content: space-between;
      border: 1px solid rgba(255, 255, 255, 0.08);
    }
    #shop-info .earn-item span:last-child {
      color: #4CAF50;
      font-weight: bold;
    }
    .shop-tips {
      margin-top: 20px;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 12px;
      padding: 16px;
      border: 1px solid rgba(255, 255, 255, 0.08);
    }
    .shop-tips h4 {
      color: #FFD700;
      margin: 0 0 12px 0;
      font-size: 14px;
    }
    .shop-tips ul {
      margin: 0;
      padding-left: 20px;
      color: rgba(255, 255, 255, 0.7);
      font-size: 12px;
      line-height: 1.8;
    }

    /* Tier legend */
    #shop-tier-legend {
      display: flex;
      justify-content: center;
      gap: 20px;
      margin-bottom: 16px;
      padding: 12px;
      background: rgba(255, 255, 255, 0.03);
      border-radius: 10px;
      border: 1px solid rgba(255, 255, 255, 0.05);
    }
    .tier-item {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 11px;
      color: rgba(255, 255, 255, 0.6);
    }
    .tier-item .tier-stars {
      font-size: 10px;
    }
    .tier-item.basic .tier-stars { color: #888; }
    .tier-item.standard .tier-stars { color: #64B5F6; }
    .tier-item.pro .tier-stars { color: #FFD700; }

    #shop-clubs-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
      gap: 10px;
      margin-bottom: 15px;
    }

    .shop-club-card {
      background: rgba(255, 255, 255, 0.05);
      border: 2px solid rgba(255, 255, 255, 0.15);
      border-radius: 12px;
      padding: 12px 8px;
      text-align: center;
      transition: all 0.2s ease;
      cursor: pointer;
    }
    .shop-club-card:hover {
      transform: translateY(-4px);
      border-color: #4CAF50;
      background: rgba(76, 175, 80, 0.15);
      box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
    }
    .shop-club-card.maxed {
      border-color: #FFD700;
      background: linear-gradient(135deg, rgba(255, 215, 0, 0.15), rgba(255, 160, 0, 0.1));
    }
    .shop-club-card.maxed:hover {
      border-color: #FFD700;
      box-shadow: 0 8px 20px rgba(255, 215, 0, 0.2);
    }

    .shop-club-icon {
      width: 42px;
      height: 42px;
      background: linear-gradient(135deg, #555, #333);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      margin: 0 auto 6px;
      font-weight: bold;
      font-size: 14px;
      color: white;
      border: 2px solid rgba(255, 255, 255, 0.2);
    }
    .shop-club-card.tier-2 .shop-club-icon {
      background: linear-gradient(135deg, #42A5F5, #1976D2);
      border-color: #64B5F6;
    }
    .shop-club-card.maxed .shop-club-icon {
      background: linear-gradient(135deg, #FFD700, #FF8F00);
      color: #1a1a1a;
      border-color: #FFE082;
    }

    .shop-club-name {
      color: #fff;
      font-size: 11px;
      font-weight: bold;
      margin-bottom: 3px;
    }

    .shop-club-tier {
      color: #FFD700;
      font-size: 12px;
      margin-bottom: 3px;
      letter-spacing: 1px;
    }

    .shop-club-distance {
      color: rgba(255, 255, 255, 0.5);
      font-size: 10px;
      margin-bottom: 5px;
    }

    /* Club stat bars */
    .shop-club-stats {
      width: 100%;
      margin-bottom: 6px;
    }
    .stat-bar {
      display: flex;
      align-items: center;
      margin-bottom: 3px;
      height: 12px;
    }
    .stat-label {
      font-size: 8px;
      color: rgba(255, 255, 255, 0.7);
      width: 28px;
      text-align: left;
    }
    .stat-bar-bg {
      flex: 1;
      height: 8px;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 4px;
      margin-left: 4px;
      overflow: hidden;
    }
    .stat-fill {
      height: 100%;
      background: linear-gradient(90deg, #4CAF50, #8BC34A);
      border-radius: 4px;
      transition: width 0.3s ease;
    }
    .stat-value {
      font-size: 8px;
      color: rgba(255, 255, 255, 0.8);
      width: 24px;
      text-align: right;
      margin-left: 4px;
    }

    .shop-club-price {
      color: #81C784;
      font-size: 11px;
      font-weight: bold;
      margin-bottom: 6px;
    }
    .shop-club-card.maxed .shop-club-price {
      color: #FFD700;
      font-size: 10px;
    }

    .shop-buy-btn {
      background: linear-gradient(135deg, #4CAF50, #2E7D32);
      border: none;
      color: white;
      padding: 6px 12px;
      border-radius: 12px;
      font-size: 10px;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.2s;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    .shop-buy-btn:hover:not(.disabled) {
      transform: scale(1.08);
      box-shadow: 0 4px 12px rgba(76, 175, 80, 0.4);
    }
    .shop-buy-btn.disabled {
      background: linear-gradient(135deg, #555, #333);
      cursor: not-allowed;
      opacity: 0.7;
    }

    .shop-club-card.just-upgraded {
      animation: card-upgrade 0.6s ease-out;
    }
    @keyframes card-upgrade {
      0% { transform: scale(1); }
      30% { transform: scale(1.15); box-shadow: 0 0 30px rgba(255, 215, 0, 0.8); }
      100% { transform: scale(1); }
    }

    /* Ball skins grid */
    #shop-balls-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(75px, 1fr));
      gap: 10px;
      margin-bottom: 15px;
    }
    .shop-ball-card {
      background: rgba(255, 255, 255, 0.05);
      border: 2px solid rgba(255, 255, 255, 0.15);
      border-radius: 12px;
      padding: 10px 6px;
      text-align: center;
      transition: all 0.2s ease;
      cursor: pointer;
    }
    .shop-ball-card:hover {
      transform: translateY(-4px);
      border-color: #4CAF50;
      background: rgba(76, 175, 80, 0.15);
    }
    .shop-ball-card.owned {
      border-color: #4CAF50;
      background: rgba(76, 175, 80, 0.1);
    }
    .shop-ball-card.animated {
      border-color: #9B59B6;
    }
    .shop-ball-card.animated:hover {
      border-color: #E91E63;
      box-shadow: 0 0 15px rgba(233, 30, 99, 0.3);
    }
    .shop-ball-preview {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      margin: 0 auto 8px;
      box-shadow: inset -3px -3px 6px rgba(0, 0, 0, 0.3), 0 2px 4px rgba(0, 0, 0, 0.3);
      position: relative;
    }
    .shop-ball-preview::after {
      content: '';
      position: absolute;
      top: 4px;
      left: 8px;
      width: 12px;
      height: 8px;
      background: radial-gradient(ellipse at center, rgba(255,255,255,0.7) 0%, rgba(255,255,255,0) 70%);
      border-radius: 50%;
    }
    .animated-indicator {
      position: absolute;
      bottom: -4px;
      right: -4px;
      font-size: 12px;
    }
    .shop-ball-name {
      color: #fff;
      font-size: 10px;
      font-weight: bold;
      margin-bottom: 3px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .shop-ball-price {
      color: #81C784;
      font-size: 10px;
      font-weight: bold;
      margin-bottom: 5px;
    }
    .shop-ball-card.owned .shop-ball-price {
      color: #4CAF50;
    }
    .shop-ball-card .shop-buy-btn {
      font-size: 10px;
      padding: 4px 8px;
    }

    /* Club Skins Section */
    .shop-section-desc {
      color: #aaa;
      font-size: 12px;
      margin: -10px 0 15px 0;
      text-align: center;
    }
    #shop-club-skins-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(90px, 1fr));
      gap: 10px;
      margin-bottom: 15px;
    }
    .shop-club-skin-card {
      background: rgba(255, 255, 255, 0.05);
      border: 2px solid rgba(255, 255, 255, 0.15);
      border-radius: 12px;
      padding: 10px 6px;
      text-align: center;
      transition: all 0.2s ease;
      cursor: pointer;
    }
    .shop-club-skin-card:hover {
      transform: translateY(-4px);
      border-color: #4CAF50;
      background: rgba(76, 175, 80, 0.15);
    }
    .shop-club-skin-card.owned {
      border-color: #64B5F6;
      background: rgba(100, 181, 246, 0.1);
    }
    .shop-club-skin-card.selected {
      border-color: #4CAF50;
      background: rgba(76, 175, 80, 0.15);
      box-shadow: 0 0 10px rgba(76, 175, 80, 0.3);
    }
    .shop-club-skin-card.animated {
      border-color: #9B59B6;
    }
    .shop-club-skin-card.animated:hover {
      border-color: #E91E63;
      box-shadow: 0 0 15px rgba(233, 30, 99, 0.3);
    }
    .shop-club-skin-preview {
      width: 50px;
      height: 50px;
      border-radius: 50%;
      margin: 0 auto 8px;
      box-shadow: inset -3px -3px 6px rgba(0, 0, 0, 0.3), 0 2px 4px rgba(0, 0, 0, 0.3);
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .club-skin-shaft-preview {
      width: 6px;
      height: 30px;
      border-radius: 3px;
      position: absolute;
      bottom: -12px;
    }
    .shop-club-skin-name {
      color: #fff;
      font-size: 11px;
      font-weight: bold;
      margin-bottom: 3px;
      margin-top: 10px;
    }
    .skin-animated-badge {
      display: block;
      color: #E91E63;
      font-size: 9px;
      margin-bottom: 3px;
    }
    .shop-club-skin-price {
      color: #81C784;
      font-size: 10px;
      font-weight: bold;
      margin-bottom: 5px;
    }
    .shop-club-skin-card.selected .shop-club-skin-price {
      color: #4CAF50;
    }
    .shop-club-skin-card .shop-buy-btn,
    .shop-club-skin-card .shop-equip-btn {
      font-size: 10px;
      padding: 4px 8px;
    }
    .shop-equip-btn {
      background: #64B5F6;
      color: white;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      transition: background 0.2s;
    }
    .shop-equip-btn:hover {
      background: #42A5F5;
    }

    /* Animated club skin previews */
    .shop-club-skin-preview.anim-fire {
      animation: preview-fire 0.5s ease-in-out infinite;
    }
    @keyframes preview-fire {
      0%, 100% { box-shadow: 0 0 10px #ff4500, 0 0 20px #ff6600; }
      50% { box-shadow: 0 0 20px #ff6600, 0 0 35px #ff8c00; }
    }
    .shop-club-skin-preview.anim-ice {
      animation: preview-ice 2s ease-in-out infinite;
    }
    @keyframes preview-ice {
      0%, 100% { box-shadow: 0 0 10px #87ceeb, 0 0 20px #b0e0e6; }
      50% { box-shadow: 0 0 15px #e0ffff, 0 0 30px #ffffff; }
    }
    .shop-club-skin-preview.anim-lightning {
      animation: preview-lightning 0.3s ease-in-out infinite;
    }
    @keyframes preview-lightning {
      0%, 90% { box-shadow: 0 0 8px #ffd700; }
      95% { box-shadow: 0 0 30px #ffff00, 0 0 50px #ffffff; }
    }
    .shop-club-skin-preview.anim-galaxy {
      animation: preview-galaxy 3s linear infinite;
    }
    @keyframes preview-galaxy {
      0% { box-shadow: 0 0 15px #4b0082, 0 0 25px #8a2be2; filter: hue-rotate(0deg); }
      50% { box-shadow: 0 0 20px #9400d3, 0 0 35px #ff69b4; }
      100% { box-shadow: 0 0 15px #4b0082, 0 0 25px #8a2be2; filter: hue-rotate(360deg); }
    }

    /* Course Themes Section */
    #shop-themes-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(130px, 1fr));
      gap: 12px;
      margin-bottom: 15px;
    }
    .shop-theme-card {
      background: rgba(255, 255, 255, 0.05);
      border: 2px solid rgba(255, 255, 255, 0.15);
      border-radius: 12px;
      padding: 12px 8px;
      text-align: center;
      transition: all 0.2s ease;
      cursor: pointer;
    }
    .shop-theme-card:hover {
      transform: translateY(-4px);
      border-color: #4CAF50;
      background: rgba(76, 175, 80, 0.15);
    }
    .shop-theme-card.owned {
      border-color: #64B5F6;
      background: rgba(100, 181, 246, 0.1);
    }
    .shop-theme-card.selected {
      border-color: #4CAF50;
      background: rgba(76, 175, 80, 0.15);
      box-shadow: 0 0 10px rgba(76, 175, 80, 0.3);
    }
    .shop-theme-preview {
      width: 100%;
      height: 60px;
      border-radius: 8px;
      margin-bottom: 8px;
      position: relative;
      overflow: hidden;
    }
    .theme-preview-rough {
      position: absolute;
      inset: 0;
    }
    .theme-preview-fairway {
      position: absolute;
      bottom: 10px;
      left: 10%;
      width: 80%;
      height: 25px;
      border-radius: 12px;
    }
    .theme-preview-green {
      position: absolute;
      bottom: 8px;
      right: 15%;
      width: 25px;
      height: 20px;
      border-radius: 50%;
    }
    .shop-theme-name {
      color: #fff;
      font-size: 12px;
      font-weight: bold;
      margin-bottom: 4px;
    }
    .shop-theme-physics {
      color: #aaa;
      font-size: 9px;
      margin-bottom: 6px;
    }
    .shop-theme-price {
      color: #81C784;
      font-size: 11px;
      font-weight: bold;
      margin-bottom: 6px;
    }
    .shop-theme-card.selected .shop-theme-price {
      color: #4CAF50;
    }
    .shop-theme-card .shop-buy-btn,
    .shop-theme-card .shop-equip-btn {
      font-size: 10px;
      padding: 5px 10px;
    }

    /* Caddie Shop */
    .caddie-shop {
      padding: 10px 0;
    }
    .caddie-shop h3 {
      color: #fff;
      text-align: center;
      margin: 0 0 8px 0;
      font-size: 18px;
    }
    .caddie-desc {
      color: rgba(255, 255, 255, 0.6);
      text-align: center;
      font-size: 12px;
      margin: 0 0 20px 0;
    }
    .caddie-item {
      display: flex;
      align-items: center;
      background: rgba(255, 255, 255, 0.05);
      border: 2px solid rgba(255, 255, 255, 0.15);
      border-radius: 12px;
      padding: 15px;
      margin-bottom: 12px;
      transition: all 0.2s;
    }
    .caddie-item:hover {
      background: rgba(255, 255, 255, 0.08);
    }
    .caddie-item.owned {
      border-color: #4CAF50;
      background: rgba(76, 175, 80, 0.1);
    }
    .caddie-item.locked {
      opacity: 0.5;
    }
    .caddie-item.cant-afford {
      opacity: 0.7;
    }
    .caddie-icon {
      font-size: 36px;
      margin-right: 15px;
    }
    .caddie-info {
      flex: 1;
    }
    .caddie-name {
      color: #fff;
      font-size: 16px;
      font-weight: bold;
      margin-bottom: 4px;
    }
    .caddie-tier-desc {
      color: rgba(255, 255, 255, 0.6);
      font-size: 12px;
    }
    .caddie-status {
      color: #4CAF50;
      font-weight: bold;
      font-size: 14px;
    }
    .caddie-status.locked {
      color: rgba(255, 255, 255, 0.4);
      font-size: 11px;
    }
    .caddie-buy-btn {
      background: linear-gradient(135deg, #FFD700, #FFA500);
      border: none;
      color: #1a1a1a;
      padding: 8px 16px;
      border-radius: 20px;
      font-weight: bold;
      font-size: 13px;
      cursor: pointer;
      transition: all 0.2s;
    }
    .caddie-buy-btn:hover {
      transform: scale(1.05);
      box-shadow: 0 4px 15px rgba(255, 215, 0, 0.4);
    }
    .caddie-item.cant-afford .caddie-buy-btn {
      background: #666;
      cursor: not-allowed;
    }

    /* Daily Challenges */
    .daily-challenge-popup {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) scale(0.8);
      z-index: 10000;
      opacity: 0;
      transition: all 0.3s ease;
      pointer-events: none;
    }
    .daily-challenge-popup.show {
      opacity: 1;
      transform: translate(-50%, -50%) scale(1);
    }
    .daily-challenge-popup-content {
      background: linear-gradient(135deg, #1a1a2e, #16213e);
      border: 3px solid #FFD700;
      border-radius: 20px;
      padding: 30px 40px;
      text-align: center;
      box-shadow: 0 0 40px rgba(255, 215, 0, 0.4);
    }
    .daily-icon {
      font-size: 48px;
      margin-bottom: 10px;
    }
    .daily-text {
      color: #FFD700;
      font-size: 16px;
      font-weight: bold;
      margin-bottom: 5px;
    }
    .daily-name {
      color: #fff;
      font-size: 22px;
      font-weight: bold;
      margin-bottom: 10px;
    }
    .daily-reward {
      color: #4CAF50;
      font-size: 24px;
      font-weight: bold;
    }
    #daily-challenges-panel {
      position: absolute;
      left: 15px;
      top: 50%;
      transform: translateY(-50%);
      background: linear-gradient(135deg, rgba(20, 20, 40, 0.98), rgba(10, 10, 30, 0.98));
      border: 2px solid rgba(255, 215, 0, 0.5);
      border-radius: 16px;
      padding: 15px 18px;
      width: 280px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5), 0 0 20px rgba(255, 215, 0, 0.1);
      z-index: 5;
    }
    .daily-challenges-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
      color: #FFD700;
      font-weight: bold;
      font-size: 14px;
    }
    .daily-challenge-item {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 8px;
      margin-bottom: 8px;
      transition: all 0.2s ease;
    }
    .daily-challenge-item:last-child {
      margin-bottom: 0;
    }
    .daily-challenge-item.completed {
      background: rgba(76, 175, 80, 0.2);
      border: 1px solid rgba(76, 175, 80, 0.3);
    }
    .daily-challenge-icon {
      font-size: 24px;
    }
    .daily-challenge-info {
      flex: 1;
    }
    .daily-challenge-name {
      color: #fff;
      font-weight: bold;
      font-size: 12px;
    }
    .daily-challenge-desc {
      color: #aaa;
      font-size: 10px;
    }
    .daily-challenge-reward {
      color: #81C784;
      font-weight: bold;
      font-size: 14px;
    }
    .daily-challenge-item.completed .daily-challenge-reward {
      color: #4CAF50;
    }

    /* Tournament System Styles */
    #tournament-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.85);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }
    #tournament-overlay.hidden { display: none; }

    #tournament-modal {
      background: linear-gradient(180deg, #1a1a2e 0%, #0f0f1a 100%);
      border: 2px solid rgba(255, 215, 0, 0.3);
      border-radius: 20px;
      padding: 30px;
      max-width: 450px;
      width: 90%;
      max-height: 85vh;
      overflow-y: auto;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
    }

    #tournament-modal h2 {
      color: #FFD700;
      text-align: center;
      margin: 0 0 20px 0;
      font-size: 24px;
    }

    .tournament-card {
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      padding: 16px;
      margin-bottom: 12px;
      cursor: pointer;
      transition: all 0.2s;
    }
    .tournament-card:hover {
      background: rgba(255, 255, 255, 0.1);
      border-color: rgba(255, 215, 0, 0.5);
      transform: translateY(-2px);
    }
    .tournament-card.locked {
      opacity: 0.6;
      cursor: not-allowed;
    }

    .tournament-name {
      color: #fff;
      font-size: 18px;
      font-weight: bold;
      margin-bottom: 8px;
    }
    .tournament-details {
      display: flex;
      justify-content: space-between;
      color: rgba(255, 255, 255, 0.7);
      font-size: 13px;
    }
    .tournament-prizes {
      color: #4CAF50;
      font-size: 12px;
      margin-top: 8px;
    }
    .tournament-entry {
      color: #FFD700;
      font-weight: bold;
    }

    .tournament-progress {
      background: rgba(255, 215, 0, 0.1);
      border: 1px solid rgba(255, 215, 0, 0.3);
      border-radius: 12px;
      padding: 16px;
      margin-bottom: 16px;
    }
    .tournament-progress h3 {
      color: #FFD700;
      margin: 0 0 10px 0;
      font-size: 16px;
    }
    .tournament-round-info {
      color: #fff;
      font-size: 14px;
      margin-bottom: 8px;
    }
    .tournament-score-display {
      color: #4CAF50;
      font-size: 20px;
      font-weight: bold;
    }

    .tournament-results {
      text-align: center;
      padding: 20px;
    }
    .tournament-results h3 {
      color: #FFD700;
      font-size: 22px;
      margin-bottom: 10px;
    }
    .tournament-position {
      font-size: 48px;
      font-weight: bold;
      color: #fff;
      margin: 10px 0;
    }
    .tournament-position.gold { color: #FFD700; }
    .tournament-position.silver { color: #C0C0C0; }
    .tournament-position.bronze { color: #CD7F32; }
    .tournament-prize {
      color: #4CAF50;
      font-size: 24px;
      font-weight: bold;
      margin: 10px 0;
    }

    .tournament-leaderboard {
      background: rgba(0, 0, 0, 0.3);
      border-radius: 10px;
      padding: 12px;
      margin-top: 16px;
    }
    .tournament-leaderboard h4 {
      color: #FFD700;
      margin: 0 0 10px 0;
      font-size: 14px;
    }
    .leaderboard-entry {
      display: flex;
      justify-content: space-between;
      padding: 6px 8px;
      color: rgba(255, 255, 255, 0.8);
      font-size: 13px;
      border-radius: 4px;
    }
    .leaderboard-entry.player {
      background: rgba(255, 215, 0, 0.2);
      color: #FFD700;
      font-weight: bold;
    }
    .leaderboard-entry:nth-child(odd) {
      background: rgba(255, 255, 255, 0.03);
    }

    .tournament-btn {
      width: 100%;
      padding: 14px;
      margin-top: 10px;
      border: none;
      border-radius: 10px;
      font-size: 16px;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.2s;
    }
    .tournament-btn.primary {
      background: linear-gradient(135deg, #4CAF50, #2E7D32);
      color: white;
    }
    .tournament-btn.secondary {
      background: rgba(255, 255, 255, 0.1);
      color: white;
    }
    .tournament-btn.danger {
      background: rgba(244, 67, 54, 0.3);
      color: #ff6b6b;
    }
    .tournament-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    }

    /* Tournament indicator in game */
    #tournament-indicator {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: linear-gradient(135deg, rgba(255, 215, 0, 0.9), rgba(255, 165, 0, 0.9));
      padding: 8px 20px;
      border-radius: 20px;
      color: #1a1a1a;
      font-weight: bold;
      font-size: 14px;
      z-index: 50;
      box-shadow: 0 4px 12px rgba(255, 215, 0, 0.3);
    }
    #tournament-indicator.hidden { display: none; }

    /* Tournament scorecard elements */
    .tournament-round-complete,
    .tournament-complete-banner {
      background: linear-gradient(135deg, rgba(255, 215, 0, 0.15), rgba(255, 165, 0, 0.15));
      border: 2px solid rgba(255, 215, 0, 0.4);
      border-radius: 12px;
      padding: 20px;
      margin-top: 20px;
      text-align: center;
    }
    .tournament-round-complete h3,
    .tournament-complete-banner h3 {
      color: #FFD700;
      margin: 0 0 10px 0;
    }
    .tournament-cumulative {
      font-size: 24px;
      font-weight: bold;
      color: #fff;
      margin: 10px 0;
    }
    .tournament-next-round-btn {
      background: linear-gradient(135deg, #FFD700, #FFA000) !important;
      color: #1a1a1a !important;
      font-weight: bold;
      margin-top: 15px;
    }
    .tournament-final-position {
      font-size: 36px;
      font-weight: bold;
      color: #FFD700;
    }
    .tournament-final-details {
      color: rgba(255, 255, 255, 0.7);
      margin-bottom: 10px;
    }
    .tournament-prize-won {
      font-size: 24px;
      color: #4CAF50;
      font-weight: bold;
      margin-top: 10px;
    }
    .tournament-lost-entry {
      font-size: 16px;
      color: #ff6b6b;
      margin-top: 10px;
    }
    .view-leaderboard-btn {
      margin-top: 15px;
      background: linear-gradient(135deg, #4169E1, #1E3A8A) !important;
    }

    /* Queue UI Styles */
    .tournament-queue {
      text-align: center;
      padding: 20px;
    }
    .tournament-queue h3 {
      color: #FFD700;
      margin-bottom: 5px;
    }
    .queue-course {
      color: rgba(255, 255, 255, 0.7);
      font-size: 14px;
      margin-bottom: 20px;
    }
    .queue-animation {
      margin: 25px 0;
    }
    .queue-spinner {
      width: 60px;
      height: 60px;
      border: 4px solid rgba(255, 215, 0, 0.2);
      border-top-color: #FFD700;
      border-radius: 50%;
      margin: 0 auto;
      animation: spin 1s linear infinite;
    }
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    .queue-status {
      font-size: 28px;
      font-weight: bold;
      color: #fff;
      margin: 15px 0;
    }
    .queue-status span {
      color: #FFD700;
    }
    .queue-message {
      color: rgba(255, 255, 255, 0.8);
      font-size: 14px;
      margin-bottom: 10px;
    }
    .queue-entry-info {
      color: rgba(255, 255, 255, 0.5);
      font-size: 12px;
    }

    /* Tournament Ready Screen */
    .tournament-ready {
      text-align: center;
      padding: 20px;
    }
    .ready-icon {
      font-size: 48px;
      margin-bottom: 10px;
    }
    .tournament-ready h3 {
      color: #FFD700;
      margin-bottom: 5px;
    }
    .ready-message {
      color: #4CAF50;
      font-size: 20px;
      font-weight: bold;
      margin: 10px 0;
    }
    .ready-details {
      color: rgba(255, 255, 255, 0.8);
      font-size: 14px;
      margin: 15px 0;
    }
    .ready-details div {
      margin: 5px 0;
    }
    .ready-prizes {
      color: #FFD700;
      font-size: 14px;
      font-weight: bold;
    }

    /* Tournament Info Banner */
    .tournament-info-banner {
      background: linear-gradient(135deg, rgba(255, 215, 0, 0.2), rgba(255, 165, 0, 0.2));
      border: 1px solid rgba(255, 215, 0, 0.4);
      border-radius: 8px;
      padding: 10px 15px;
      margin-bottom: 15px;
      color: #FFD700;
      font-size: 13px;
      font-weight: bold;
      text-align: center;
    }
    .tournament-pool {
      color: #4CAF50;
      font-size: 14px;
      font-weight: bold;
      margin: 5px 0;
    }
    .tournament-prizes-mini {
      color: rgba(255, 255, 255, 0.6);
      font-size: 11px;
      margin: 3px 0;
    }
    .tournament-warning {
      color: rgba(255, 100, 100, 0.8);
      font-size: 10px;
      margin-top: 5px;
    }
    .tournament-card:first-of-type .tournament-warning {
      color: rgba(100, 255, 100, 0.8);
    }
    .tournament-course-theme {
      color: rgba(255, 255, 255, 0.7);
      font-size: 14px;
      margin: 5px 0;
    }
    .tournament-players-info {
      color: rgba(255, 215, 0, 0.8);
      font-size: 14px;
      margin: 5px 0;
    }
    .tournament-info-text {
      color: rgba(255, 255, 255, 0.6);
      font-size: 13px;
      margin-top: 10px;
    }

    /* Leaderboard Scroll */
    .leaderboard-scroll {
      max-height: 300px;
      overflow-y: auto;
      padding-right: 5px;
    }
    .leaderboard-scroll::-webkit-scrollbar {
      width: 6px;
    }
    .leaderboard-scroll::-webkit-scrollbar-track {
      background: rgba(255, 255, 255, 0.1);
      border-radius: 3px;
    }
    .leaderboard-scroll::-webkit-scrollbar-thumb {
      background: rgba(255, 215, 0, 0.5);
      border-radius: 3px;
    }
    .leaderboard-entry {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 10px;
      border-radius: 4px;
      margin-bottom: 2px;
      font-size: 13px;
    }
    .leaderboard-entry.in-money {
      background: rgba(76, 175, 80, 0.15);
    }
    .leaderboard-entry.out-money {
      background: rgba(255, 255, 255, 0.03);
      color: rgba(255, 255, 255, 0.5);
    }
    .leaderboard-entry.player {
      background: rgba(255, 215, 0, 0.3) !important;
      color: #FFD700 !important;
      font-weight: bold;
    }
    .lb-rank { width: 30px; }
    .lb-name { flex: 1; }
    .lb-score { width: 50px; text-align: center; }
    .lb-prize { width: 60px; text-align: right; color: #4CAF50; font-size: 12px; }
    .leaderboard-entry.out-money .lb-prize { color: rgba(255, 255, 255, 0.3); }

    .tournament-lost {
      color: #ff6b6b;
      font-size: 14px;
      margin-top: 10px;
    }

    /* Embedded leaderboard in scorecard */
    .tournament-leaderboard-embed {
      margin-top: 15px;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 8px;
      padding: 10px;
    }
    .tournament-leaderboard-embed h4 {
      color: #FFD700;
      margin: 0 0 10px 0;
      font-size: 14px;
    }
    .tournament-leaderboard-embed .leaderboard-scroll {
      max-height: 200px;
    }

    /* Tournament cooldown */
    .tournament-cooldown {
      text-align: center;
      padding: 20px;
      color: rgba(255, 255, 255, 0.7);
    }
    .cooldown-timer {
      font-size: 48px;
      font-weight: bold;
      color: #FFD700;
      margin: 20px 0;
    }
    .cooldown-message {
      font-size: 14px;
      color: rgba(255, 255, 255, 0.5);
    }

    /* Menu balance display */
    #menu-balance {
      position: absolute;
      top: 15px;
      right: 15px;
      background: linear-gradient(135deg, #FFD700, #FFA000);
      padding: 8px 16px;
      border-radius: 20px;
      color: #1a1a1a;
      font-weight: bold;
      font-size: 14px;
      z-index: 10;
      box-shadow: 0 4px 12px rgba(255, 215, 0, 0.3);
      cursor: pointer;
    }
    #menu-balance:hover {
      transform: scale(1.05);
    }

    #version-footer {
      position: absolute;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
      color: rgba(255, 255, 255, 0.5);
      font-size: 11px;
      font-family: monospace;
    }

    #distance-display {
      position: absolute;
      bottom: 20px;
      right: 20px;
      background: rgba(255, 255, 255, 0.95);
      padding: 15px 25px;
      border-radius: 12px;
      font-size: 24px;
      font-weight: bold;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      color: #2196F3;
    }

    #distance-display .label {
      font-size: 12px;
      color: #666;
      font-weight: normal;
      display: block;
      margin-bottom: 5px;
    }

    #club-selector-container {
      position: absolute;
      bottom: 15px;
      left: 50%;
      transform: translateX(-50%);
      display: none;
    }

    #caddie-tip {
      background: linear-gradient(135deg, rgba(76, 175, 80, 0.95), rgba(56, 142, 60, 0.95));
      color: white;
      padding: 8px 16px;
      border-radius: 20px;
      font-size: 14px;
      text-align: center;
      margin-bottom: 8px;
      box-shadow: 0 3px 10px rgba(0,0,0,0.3);
      border: 2px solid rgba(255,255,255,0.2);
    }
    #caddie-tip.hidden { display: none; }
    #caddie-tip .caddie-icon {
      margin-right: 6px;
    }
    #caddie-tip strong {
      color: #FFD700;
    }

    #club-selector {
      display: flex;
      align-items: flex-end;
      justify-content: center;
      gap: 4px;
      padding: 15px 20px 10px 20px;
      background: linear-gradient(to bottom, #8B4513 0%, #654321 50%, #3d2817 100%);
      border-radius: 20px 20px 8px 8px;
      box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4), inset 0 2px 4px rgba(255,255,255,0.1);
      border: 3px solid #2d1810;
      position: relative;
    }

    #club-selector::before {
      content: '';
      position: absolute;
      top: 5px;
      left: 15px;
      right: 15px;
      height: 4px;
      background: linear-gradient(to right, transparent, rgba(255,215,0,0.3), transparent);
      border-radius: 2px;
    }

    #club-selector.minimized {
      display: none;
    }

    .club-slot {
      display: flex;
      flex-direction: column;
      align-items: center;
      cursor: pointer;
      transition: transform 0.15s ease;
      padding: 5px;
      border-radius: 8px;
    }

    .club-slot:hover {
      transform: translateY(-5px);
    }

    .club-slot.selected {
      transform: translateY(-12px);
    }

    .club-slot.selected .club-head {
      box-shadow: 0 0 15px rgba(255, 215, 0, 0.8), 0 4px 8px rgba(0,0,0,0.3);
    }

    .club-shaft {
      width: 4px;
      height: 35px;
      background: linear-gradient(to right, #888, #ccc, #888);
      border-radius: 2px;
      box-shadow: 1px 0 2px rgba(0,0,0,0.3);
    }

    .club-head {
      width: 44px;
      height: 44px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      font-size: 11px;
      color: white;
      text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
      box-shadow: 0 3px 6px rgba(0,0,0,0.3);
      border: 2px solid rgba(255,255,255,0.3);
      transition: box-shadow 0.15s ease;
    }

    .club-head.driver {
      background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
    }

    .club-head.wood {
      background: linear-gradient(135deg, #e67e22 0%, #d35400 100%);
    }

    .club-head.iron {
      background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
    }

    .club-head.wedge {
      background: linear-gradient(135deg, #f1c40f 0%, #f39c12 100%);
      color: #333;
      text-shadow: none;
    }

    .club-head.putter {
      background: linear-gradient(135deg, #2ecc71 0%, #27ae60 100%);
    }

    .club-distance {
      font-size: 9px;
      color: rgba(255,255,255,0.8);
      margin-top: 3px;
      text-align: center;
      text-shadow: 1px 1px 1px rgba(0,0,0,0.5);
    }

    /* Recommended club - green pulsing outline */
    .club-slot.recommended .club-head {
      outline: 3px solid #4CAF50;
      outline-offset: 2px;
      animation: rec-outline-pulse 1.2s ease-in-out infinite;
    }
    @keyframes rec-outline-pulse {
      0%, 100% { outline-color: #4CAF50; outline-offset: 2px; }
      50% { outline-color: #81C784; outline-offset: 4px; }
    }

    /* Tier-based club styling */
    .club-slot {
      position: relative;
    }

    /* Tier 1 - Basic: gray color */
    .club-slot.tier-1 .club-head {
      border-color: rgba(255, 255, 255, 0.2);
      background: linear-gradient(135deg, #6b6b6b 0%, #4a4a4a 50%, #3a3a3a 100%) !important;
    }
    .club-slot.tier-1 .club-shaft {
      background: linear-gradient(to right, #5a5a5a, #888, #5a5a5a);
    }

    /* Tier 2 - Standard: blue glow with pulsing animation */
    .club-slot.tier-2 .club-head {
      border: 3px solid #64B5F6;
      animation: tier2-pulse 2s ease-in-out infinite;
      background: linear-gradient(135deg, #5a9fd4 0%, #3a7cb8 50%, #2a5c8a 100%) !important;
    }
    @keyframes tier2-pulse {
      0%, 100% { box-shadow: 0 0 10px rgba(100, 181, 246, 0.6), 0 0 20px rgba(100, 181, 246, 0.3), 0 3px 6px rgba(0,0,0,0.3); }
      50% { box-shadow: 0 0 15px rgba(100, 181, 246, 0.9), 0 0 30px rgba(100, 181, 246, 0.5), 0 3px 6px rgba(0,0,0,0.3); }
    }
    .club-slot.tier-2 .club-distance {
      color: #90CAF9;
      font-weight: bold;
    }
    .club-slot.tier-2::after {
      content: 'â˜…';
      position: absolute;
      top: -8px;
      right: -8px;
      font-size: 14px;
      color: #fff;
      background: linear-gradient(135deg, #64B5F6, #1976D2);
      border-radius: 50%;
      width: 22px;
      height: 22px;
      line-height: 22px;
      text-align: center;
      text-shadow: 0 1px 2px rgba(0,0,0,0.5);
      box-shadow: 0 2px 4px rgba(0,0,0,0.3);
      border: 2px solid #fff;
    }
    .club-slot.tier-2 .club-shaft {
      background: linear-gradient(to right, #5a8bc7, #8ab8e8, #5a8bc7);
    }

    /* Tier 3 - Pro: gold glow with intense pulsing + sparkle */
    .club-slot.tier-3 .club-head {
      border: 3px solid #FFD700;
      animation: tier3-pulse 1.5s ease-in-out infinite;
      background: linear-gradient(135deg, #e6b800 0%, #cc9900 50%, #a67c00 100%) !important;
    }
    @keyframes tier3-pulse {
      0%, 100% { box-shadow: 0 0 15px rgba(255, 215, 0, 0.7), 0 0 30px rgba(255, 165, 0, 0.4), 0 3px 6px rgba(0,0,0,0.3); }
      50% { box-shadow: 0 0 25px rgba(255, 215, 0, 1), 0 0 45px rgba(255, 165, 0, 0.6), 0 3px 6px rgba(0,0,0,0.3); }
    }
    .club-slot.tier-3 .club-distance {
      color: #FFD700;
      font-weight: bold;
      text-shadow: 0 0 4px rgba(255, 215, 0, 0.5);
    }
    .club-slot.tier-3::after {
      content: 'â˜…â˜…';
      position: absolute;
      top: -10px;
      right: -10px;
      font-size: 12px;
      letter-spacing: -3px;
      color: #fff;
      background: linear-gradient(135deg, #FFD700, #FFA500, #FF8C00);
      border-radius: 50%;
      width: 28px;
      height: 28px;
      line-height: 28px;
      text-align: center;
      text-shadow: 0 1px 2px rgba(0,0,0,0.5);
      box-shadow: 0 0 8px rgba(255, 215, 0, 0.6), 0 2px 4px rgba(0,0,0,0.3);
      border: 2px solid #fff;
      animation: tier3-badge-pulse 1.5s ease-in-out infinite;
    }
    @keyframes tier3-badge-pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.1); }
    }
    .club-slot.tier-3 .club-shaft {
      background: linear-gradient(to right, #B8860B, #FFD700, #B8860B);
    }

    /* Club Skin Animations */
    .club-slot.skin-fire .club-head {
      animation: club-fire 0.5s ease-in-out infinite;
    }
    @keyframes club-fire {
      0%, 100% { box-shadow: 0 0 10px #ff4500, 0 0 20px #ff6600, 0 3px 6px rgba(0,0,0,0.3); }
      50% { box-shadow: 0 0 20px #ff6600, 0 0 35px #ff8c00, 0 3px 6px rgba(0,0,0,0.3); }
    }

    .club-slot.skin-ice .club-head {
      animation: club-ice 2s ease-in-out infinite;
    }
    @keyframes club-ice {
      0%, 100% { box-shadow: 0 0 10px #87ceeb, 0 0 20px #b0e0e6, 0 3px 6px rgba(0,0,0,0.3); }
      50% { box-shadow: 0 0 15px #e0ffff, 0 0 30px #ffffff, 0 3px 6px rgba(0,0,0,0.3); }
    }

    .club-slot.skin-lightning .club-head {
      animation: club-lightning 0.3s ease-in-out infinite;
    }
    @keyframes club-lightning {
      0%, 90% { box-shadow: 0 0 8px #ffd700, 0 3px 6px rgba(0,0,0,0.3); }
      95% { box-shadow: 0 0 30px #ffff00, 0 0 50px #ffffff, 0 3px 6px rgba(0,0,0,0.3); }
      100% { box-shadow: 0 0 8px #ffd700, 0 3px 6px rgba(0,0,0,0.3); }
    }

    .club-slot.skin-galaxy .club-head {
      animation: club-galaxy 3s linear infinite;
    }
    @keyframes club-galaxy {
      0% { box-shadow: 0 0 15px #4b0082, 0 0 25px #8a2be2, 0 3px 6px rgba(0,0,0,0.3); filter: hue-rotate(0deg); }
      50% { box-shadow: 0 0 20px #9400d3, 0 0 35px #ff69b4, 0 3px 6px rgba(0,0,0,0.3); }
      100% { box-shadow: 0 0 15px #4b0082, 0 0 25px #8a2be2, 0 3px 6px rgba(0,0,0,0.3); filter: hue-rotate(360deg); }
    }

    #club-toggle-btn {
      background: linear-gradient(to bottom, #5a3d2b, #3d2817);
      border: 2px solid #2d1810;
      border-radius: 8px;
      padding: 8px 20px;
      font-size: 14px;
      font-weight: bold;
      color: #f4e4bc;
      cursor: pointer;
      box-shadow: 0 3px 6px rgba(0, 0, 0, 0.3);
      margin-top: 8px;
      width: 100%;
      text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
    }

    #club-toggle-btn:active {
      background: linear-gradient(to bottom, #4a3020, #2d1810);
    }

    .button {
      padding: 12px 24px;
      margin: 5px;
      background: #4CAF50;
      color: white;
      border: none;
      border-radius: 8px;
      font-size: 16px;
      cursor: pointer;
      font-weight: 600;
      transition: background 0.2s;
    }

    .button:active {
      background: #45a049;
    }

    .button.selected {
      background: #2196F3;
    }

    #debug-info {
      position: absolute;
      top: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 10px;
      border-radius: 8px;
      font-size: 14px;
      font-family: monospace;
    }

    #menu-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      /* Golf course background image */
      background: url('menu-background.png') center center / cover no-repeat;
      display: flex;
      justify-content: center;
      align-items: center;
      flex-direction: column;
    }

    /* Slight darkening overlay for better text readability */
    #menu-overlay::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.15);
      pointer-events: none;
    }

    #menu-overlay h1 {
      color: white;
      font-size: 48px;
      margin-bottom: 40px;
      text-shadow: 2px 2px 8px rgba(0,0,0,0.5);
    }

    .menu-button {
      padding: 18px 52px;
      margin: 10px;
      background: linear-gradient(to bottom, #4CAF50, #3d8b40);
      color: white;
      border: 3px solid #2d6b30;
      border-radius: 12px;
      font-size: 26px;
      cursor: pointer;
      font-weight: 800;
      transition: all 0.2s;
      box-shadow: 0 4px 12px rgba(0,0,0,0.4), inset 0 1px 0 rgba(255,255,255,0.3);
      text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
    }

    .menu-button:active {
      background: linear-gradient(to bottom, #3d8b40, #2d6b30);
      transform: translateY(2px);
      box-shadow: 0 2px 6px rgba(0,0,0,0.4);
    }

    .hidden {
      display: none !important;
    }

    #scorecard-overlay {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(255, 255, 255, 0.98);
      padding: 30px;
      border-radius: 16px;
      box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
      max-width: 500px;
      max-height: 80vh;
      overflow-y: auto;
      z-index: 1100;
    }

    #scorecard-overlay h2 {
      margin-bottom: 20px;
      color: #333;
    }

    .scorecard-table {
      width: 100%;
      border-collapse: collapse;
      margin: 20px 0;
    }

    .scorecard-table th, .scorecard-table td {
      padding: 10px;
      text-align: center;
      border-bottom: 1px solid #ddd;
    }

    .scorecard-table th {
      background: #f5f5f5;
      font-weight: bold;
    }

    .score-birdie { color: #4CAF50; font-weight: bold; }
    .score-eagle { color: #FFD700; font-weight: bold; }
    .score-par { color: #2196F3; }
    .score-bogey { color: #FF9800; }
    .score-double { color: #F44336; }

    #round-progress {
      position: absolute;
      bottom: 80px;
      left: 20px;
      background: rgba(255, 255, 255, 0.95);
      padding: 10px 15px;
      border-radius: 8px;
      font-size: 14px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    }

    #reset-shot-btn {
      position: absolute;
      bottom: 100px;
      right: 20px;
      padding: 8px 16px;
      background: rgba(244, 67, 54, 0.9);
      color: white;
      border: none;
      border-radius: 8px;
      font-size: 14px;
      font-weight: bold;
      cursor: pointer;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
      z-index: 1000;
      transition: background 0.2s;
    }

    #reset-shot-btn:active {
      background: rgba(211, 47, 47, 0.95);
    }

    /* Pro Swing Timing Meter */
    #timing-meter-overlay {
      position: absolute;
      bottom: 150px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 1001;
      pointer-events: auto;
    }

    .timing-meter-container {
      background: rgba(0, 0, 0, 0.9);
      padding: 15px 25px;
      border-radius: 15px;
      text-align: center;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
      border: 2px solid #FFD700;
    }

    .timing-meter-label {
      color: #FFD700;
      font-size: 16px;
      font-weight: bold;
      margin-bottom: 10px;
      text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
      animation: pulse-text 0.5s ease-in-out infinite;
    }

    @keyframes pulse-text {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }

    .timing-meter-bar {
      width: 280px;
      height: 30px;
      background: linear-gradient(to right,
        #ff4444 0%,
        #ff8844 15%,
        #ffcc44 30%,
        #44ff44 45%,
        #44ff44 55%,
        #ffcc44 70%,
        #ff8844 85%,
        #ff4444 100%
      );
      border-radius: 15px;
      position: relative;
      overflow: hidden;
      box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
    }

    .timing-meter-sweet-spot {
      position: absolute;
      left: 50%;
      top: 0;
      transform: translateX(-50%);
      width: 40px;
      height: 100%;
      border: 3px solid #fff;
      border-radius: 8px;
      box-shadow: 0 0 10px rgba(255, 255, 255, 0.8);
      pointer-events: none;
    }

    .timing-meter-marker {
      position: absolute;
      top: 50%;
      transform: translate(-50%, -50%);
      width: 8px;
      height: 40px;
      background: #fff;
      border-radius: 4px;
      box-shadow: 0 0 10px rgba(255, 255, 255, 0.9), 0 0 20px rgba(255, 255, 255, 0.5);
      left: 0%;
    }

    .timing-meter-hint {
      color: #aaa;
      font-size: 11px;
      margin-top: 8px;
    }

    .club-power-info {
      font-size: 12px;
      color: #666;
      margin-top: 2px;
    }

    /* === Leaderboard Styles (T077) === */
    #leaderboard-overlay {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(255, 255, 255, 0.98);
      padding: 30px;
      border-radius: 16px;
      box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
      max-width: 600px;
      max-height: 80vh;
      overflow-y: auto;
      z-index: 1000;
    }

    #leaderboard-overlay h2 {
      margin-bottom: 20px;
      color: #333;
      text-align: center;
    }

    .leaderboard-table {
      width: 100%;
      border-collapse: collapse;
      margin: 20px 0;
    }

    .leaderboard-table th,
    .leaderboard-table td {
      padding: 12px;
      text-align: center;
      border-bottom: 1px solid #ddd;
    }

    .leaderboard-table th {
      background: #f5f5f5;
      font-weight: bold;
      position: sticky;
      top: 0;
    }

    .leaderboard-table tr:hover {
      background: #f9f9f9;
    }

    .leaderboard-rank {
      font-weight: bold;
      color: #666;
    }

    .leaderboard-rank-1 { color: #FFD700; }
    .leaderboard-rank-2 { color: #C0C0C0; }
    .leaderboard-rank-3 { color: #CD7F32; }

    .leaderboard-score-under { color: #4CAF50; font-weight: bold; }
    .leaderboard-score-par { color: #2196F3; }
    .leaderboard-score-over { color: #F44336; }

    .leaderboard-empty {
      text-align: center;
      padding: 40px 20px;
      color: #999;
      font-style: italic;
    }

    .new-best-indicator {
      background: #FFD700;
      color: #333;
      padding: 10px 20px;
      border-radius: 8px;
      margin-bottom: 20px;
      text-align: center;
      font-weight: bold;
      animation: pulse 1s ease-in-out;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }

    /* === Menu Bottom Buttons (Settings/Achievements) === */
    .menu-bottom-buttons {
      position: absolute;
      bottom: 20px;
      right: 20px;
      display: flex;
      gap: 10px;
    }

    .menu-icon-btn {
      position: relative;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      border: 3px solid rgba(255, 255, 255, 0.4);
      background: rgba(0, 0, 0, 0.3);
      color: white;
      font-size: 24px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
    }

    .menu-icon-btn:hover {
      background: rgba(0, 0, 0, 0.5);
      transform: scale(1.1);
    }

    /* Music prompt button */
    #music-prompt-btn {
      position: absolute;
      bottom: 20px;
      left: 20px;
      padding: 12px 20px;
      background: linear-gradient(135deg, #9C27B0, #7B1FA2);
      border: 3px solid rgba(255, 255, 255, 0.4);
      border-radius: 25px;
      color: white;
      font-size: 16px;
      font-weight: bold;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 8px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      transition: all 0.2s;
      animation: musicPulse 2s ease-in-out infinite;
    }

    #music-prompt-btn:hover {
      transform: scale(1.05);
      box-shadow: 0 6px 16px rgba(0, 0, 0, 0.4);
    }

    #music-prompt-btn.playing {
      background: linear-gradient(135deg, #4CAF50, #388E3C);
      animation: none;
    }

    @keyframes musicPulse {
      0%, 100% { box-shadow: 0 4px 12px rgba(156, 39, 176, 0.4); }
      50% { box-shadow: 0 4px 20px rgba(156, 39, 176, 0.7); }
    }

    .menu-icon-btn:active {
      transform: scale(0.95);
    }

    /* === Settings Overlay === */
    #settings-overlay {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: linear-gradient(145deg, #ffffff 0%, #f5f5f5 100%);
      padding: 30px;
      border-radius: 20px;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.4);
      max-width: 400px;
      width: 90%;
      z-index: 1001;
    }

    #settings-overlay h2 {
      margin: 0 0 25px 0;
      color: #333;
      text-align: center;
      font-size: 28px;
    }

    .settings-group {
      margin-bottom: 20px;
    }

    .settings-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 0;
      border-bottom: 1px solid #eee;
    }

    .settings-row:last-child {
      border-bottom: none;
    }

    .settings-label {
      font-size: 16px;
      color: #333;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .settings-label .icon {
      font-size: 20px;
    }

    /* Toggle switch */
    .toggle-switch {
      position: relative;
      width: 52px;
      height: 28px;
    }

    .toggle-switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }

    .toggle-slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: #ccc;
      transition: 0.3s;
      border-radius: 28px;
    }

    .toggle-slider:before {
      position: absolute;
      content: "";
      height: 22px;
      width: 22px;
      left: 3px;
      bottom: 3px;
      background-color: white;
      transition: 0.3s;
      border-radius: 50%;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }

    .toggle-switch input:checked + .toggle-slider {
      background-color: #4CAF50;
    }

    .toggle-switch input:checked + .toggle-slider:before {
      transform: translateX(24px);
    }

    .settings-buttons {
      display: flex;
      justify-content: center;
      margin-top: 25px;
    }

    /* Swing Mode Selector */
    .swing-mode-selector {
      display: flex;
      gap: 10px;
      width: 100%;
    }

    .swing-mode-btn {
      flex: 1;
      padding: 12px 8px;
      border: 2px solid #ddd;
      border-radius: 10px;
      background: #f5f5f5;
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 4px;
    }

    .swing-mode-btn:hover {
      border-color: #aaa;
      background: #eee;
    }

    .swing-mode-btn.active {
      border-color: #4CAF50;
      background: linear-gradient(135deg, #e8f5e9, #c8e6c9);
      box-shadow: 0 2px 8px rgba(76, 175, 80, 0.3);
    }

    .swing-mode-btn .mode-name {
      font-size: 16px;
      font-weight: bold;
      color: #333;
    }

    .swing-mode-btn .mode-desc {
      font-size: 11px;
      color: #666;
    }

    .swing-mode-btn.active .mode-name {
      color: #2E7D32;
    }

    .swing-mode-btn.active .mode-desc {
      color: #388E3C;
    }

    /* === Achievements Overlay === */
    #achievements-overlay {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: linear-gradient(145deg, #ffffff 0%, #f5f5f5 100%);
      padding: 30px;
      border-radius: 20px;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.4);
      max-width: 500px;
      width: 90%;
      max-height: 80vh;
      overflow-y: auto;
      z-index: 1001;
    }

    #achievements-overlay h2 {
      margin: 0 0 20px 0;
      color: #333;
      text-align: center;
      font-size: 28px;
    }

    .achievements-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
      gap: 12px;
      margin-bottom: 20px;
    }

    .achievement-card {
      background: #f9f9f9;
      border-radius: 12px;
      padding: 15px 10px;
      text-align: center;
      border: 2px solid #e0e0e0;
      transition: all 0.2s;
    }

    .achievement-card.unlocked {
      background: linear-gradient(145deg, #fff9e6 0%, #fff3cd 100%);
      border-color: #FFD700;
    }

    .achievement-card.locked {
      opacity: 0.5;
      filter: grayscale(100%);
    }

    .achievement-card .icon {
      font-size: 32px;
      margin-bottom: 8px;
    }

    .achievement-card .name {
      font-size: 12px;
      font-weight: bold;
      color: #333;
      margin-bottom: 4px;
    }

    .achievement-card .desc {
      font-size: 10px;
      color: #666;
    }

    .achievements-progress {
      text-align: center;
      color: #666;
      font-size: 14px;
      margin-bottom: 15px;
      padding: 10px;
      background: rgba(76, 175, 80, 0.1);
      border-radius: 8px;
    }

    .achievements-buttons {
      display: flex;
      justify-content: center;
    }

    /* === Hole Complete Modal Styles === */
    #hole-complete-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.75);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1002;
      animation: fadeIn 0.3s ease-out;
    }

    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    @keyframes slideUp {
      from { transform: translate(-50%, -40%); opacity: 0; }
      to { transform: translate(-50%, -50%); opacity: 1; }
    }

    @keyframes scorePop {
      0% { transform: scale(0.5); opacity: 0; }
      70% { transform: scale(1.1); }
      100% { transform: scale(1); opacity: 1; }
    }

    .hole-complete-modal {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: linear-gradient(145deg, #ffffff 0%, #f0f0f0 100%);
      padding: 30px 40px;
      border-radius: 20px;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.4);
      text-align: center;
      min-width: 280px;
      max-width: 90%;
      animation: slideUp 0.4s ease-out;
    }

    .hole-complete-header {
      font-size: 16px;
      color: #666;
      text-transform: uppercase;
      letter-spacing: 2px;
      margin-bottom: 5px;
    }

    .hole-complete-number {
      font-size: 48px;
      font-weight: 800;
      color: #333;
      margin-bottom: 15px;
    }

    .hole-complete-score-name {
      font-size: 32px;
      font-weight: 700;
      margin-bottom: 10px;
      animation: scorePop 0.5s ease-out 0.2s both;
    }

    .hole-complete-score-name.eagle { color: #FFD700; text-shadow: 0 2px 10px rgba(255, 215, 0, 0.5); }
    .hole-complete-score-name.birdie { color: #4CAF50; }
    .hole-complete-score-name.par { color: #2196F3; }
    .hole-complete-score-name.bogey { color: #FF9800; }
    .hole-complete-score-name.double-bogey { color: #F44336; }

    .hole-complete-details {
      display: flex;
      justify-content: center;
      gap: 30px;
      margin: 20px 0;
      padding: 15px 0;
      border-top: 1px solid #e0e0e0;
      border-bottom: 1px solid #e0e0e0;
    }

    .hole-complete-stat {
      text-align: center;
    }

    .hole-complete-stat-value {
      font-size: 28px;
      font-weight: 700;
      color: #333;
    }

    .hole-complete-stat-label {
      font-size: 12px;
      color: #888;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .hole-complete-total {
      font-size: 18px;
      color: #555;
      margin-bottom: 25px;
    }

    .hole-complete-total span {
      font-weight: 700;
    }

    .hole-complete-btn {
      padding: 14px 40px;
      background: linear-gradient(145deg, #4CAF50 0%, #45a049 100%);
      color: white;
      border: none;
      border-radius: 30px;
      font-size: 18px;
      font-weight: 700;
      cursor: pointer;
      box-shadow: 0 4px 15px rgba(76, 175, 80, 0.4);
      transition: transform 0.2s, box-shadow 0.2s;
    }

    .hole-complete-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(76, 175, 80, 0.5);
    }

    .hole-complete-btn:active {
      transform: translateY(0);
    }

    /* === Name Entry Modal Styles === */
    #name-entry-overlay {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(255, 255, 255, 0.98);
      padding: 30px;
      border-radius: 16px;
      box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
      max-width: 400px;
      width: 90%;
      z-index: 1001;
      text-align: center;
    }

    #name-entry-overlay h2 {
      margin-bottom: 10px;
      color: #333;
    }

    #name-entry-overlay p {
      color: #666;
      margin-bottom: 20px;
      font-size: 14px;
    }

    #player-name-input {
      width: 100%;
      padding: 15px;
      font-size: 18px;
      border: 2px solid #ddd;
      border-radius: 8px;
      margin-bottom: 20px;
      text-align: center;
      outline: none;
      transition: border-color 0.2s;
    }

    #player-name-input:focus {
      border-color: #4CAF50;
    }

    .name-entry-buttons {
      display: flex;
      gap: 10px;
      justify-content: center;
    }

    .name-entry-buttons .button {
      flex: 1;
      max-width: 150px;
    }

    .name-entry-buttons .cancel-btn {
      background: #999;
    }

    .name-entry-buttons .cancel-btn:active {
      background: #777;
    }

    /* === Tutorial Styles === */
    #tutorial-prompt-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1002;
    }

    #tutorial-overlay {
      position: fixed;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 1002;
      pointer-events: none; /* Allow clicks to pass through to game */
    }

    #tutorial-overlay .tutorial-modal {
      pointer-events: auto; /* Modal itself is clickable */
    }

    .tutorial-modal {
      background: rgba(255, 255, 255, 0.95);
      padding: 15px 25px;
      border-radius: 12px;
      box-shadow: 0 6px 24px rgba(0, 0, 0, 0.4);
      max-width: 380px;
      width: 90vw;
      text-align: center;
      border: 3px solid #4CAF50;
    }

    .tutorial-modal h2 {
      color: #333;
      margin: 0 0 8px 0;
      font-size: 20px;
    }

    .tutorial-modal p {
      color: #555;
      font-size: 15px;
      line-height: 1.4;
      margin: 0 0 12px 0;
    }

    .tutorial-buttons {
      display: flex;
      gap: 10px;
      justify-content: center;
      flex-wrap: wrap;
    }

    .tutorial-buttons .menu-button {
      padding: 8px 20px;
      font-size: 14px;
    }

    #tutorial-progress {
      margin-top: 10px;
      color: #888;
      font-size: 12px;
    }

    .tutorial-highlight {
      position: relative;
      box-shadow: 0 0 0 4px rgba(255, 165, 0, 0.8), 0 0 20px rgba(255, 165, 0, 0.5) !important;
      animation: tutorialPulse 1.5s ease-in-out infinite;
      z-index: 100;
    }

    @keyframes tutorialPulse {
      0%, 100% { box-shadow: 0 0 0 4px rgba(255, 165, 0, 0.8), 0 0 20px rgba(255, 165, 0, 0.5); }
      50% { box-shadow: 0 0 0 6px rgba(255, 165, 0, 1), 0 0 30px rgba(255, 165, 0, 0.7); }
    }

    /* === Ball Color Selector Styles === */
    .ball-color-section {
      margin: 20px 0;
    }

    .ball-color-section label {
      display: block;
      color: #333;
      font-weight: 600;
      margin-bottom: 12px;
    }

    .ball-color-options {
      display: flex;
      justify-content: center;
      gap: 12px;
      flex-wrap: wrap;
    }

    .ball-color-option {
      width: 44px;
      height: 44px;
      border-radius: 50%;
      border: 3px solid transparent;
      cursor: pointer;
      transition: transform 0.2s, border-color 0.2s, box-shadow 0.2s;
      position: relative;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }

    .ball-color-option:hover {
      transform: scale(1.1);
    }

    .ball-color-option.selected {
      border-color: #4CAF50;
      box-shadow: 0 0 0 3px rgba(76, 175, 80, 0.3), 0 2px 4px rgba(0, 0, 0, 0.2);
    }

    .ball-color-option.animated-ball {
      animation: rainbow-border 2s linear infinite;
    }

    .ball-color-option.animated-ball.selected {
      animation: rainbow-border-selected 2s linear infinite;
    }

    @keyframes rainbow-border {
      0% { box-shadow: 0 0 8px #ff0000, 0 2px 4px rgba(0, 0, 0, 0.2); }
      16% { box-shadow: 0 0 8px #ff8800, 0 2px 4px rgba(0, 0, 0, 0.2); }
      33% { box-shadow: 0 0 8px #ffff00, 0 2px 4px rgba(0, 0, 0, 0.2); }
      50% { box-shadow: 0 0 8px #00ff00, 0 2px 4px rgba(0, 0, 0, 0.2); }
      66% { box-shadow: 0 0 8px #0088ff, 0 2px 4px rgba(0, 0, 0, 0.2); }
      83% { box-shadow: 0 0 8px #8800ff, 0 2px 4px rgba(0, 0, 0, 0.2); }
      100% { box-shadow: 0 0 8px #ff0000, 0 2px 4px rgba(0, 0, 0, 0.2); }
    }

    @keyframes rainbow-border-selected {
      0% { box-shadow: 0 0 12px #ff0000, 0 0 0 3px rgba(76, 175, 80, 0.3); border-color: #4CAF50; }
      16% { box-shadow: 0 0 12px #ff8800, 0 0 0 3px rgba(76, 175, 80, 0.3); border-color: #4CAF50; }
      33% { box-shadow: 0 0 12px #ffff00, 0 0 0 3px rgba(76, 175, 80, 0.3); border-color: #4CAF50; }
      50% { box-shadow: 0 0 12px #00ff00, 0 0 0 3px rgba(76, 175, 80, 0.3); border-color: #4CAF50; }
      66% { box-shadow: 0 0 12px #0088ff, 0 0 0 3px rgba(76, 175, 80, 0.3); border-color: #4CAF50; }
      83% { box-shadow: 0 0 12px #8800ff, 0 0 0 3px rgba(76, 175, 80, 0.3); border-color: #4CAF50; }
      100% { box-shadow: 0 0 12px #ff0000, 0 0 0 3px rgba(76, 175, 80, 0.3); border-color: #4CAF50; }
    }

    .ball-color-option::after {
      content: '';
      position: absolute;
      top: 4px;
      left: 8px;
      width: 12px;
      height: 8px;
      background: radial-gradient(ellipse at center, rgba(255,255,255,0.8) 0%, rgba(255,255,255,0) 70%);
      border-radius: 50%;
    }

    /* Mobile phone optimizations */
    @media (max-width: 480px) {
      #scoreboard {
        top: 10px;
        left: 10px;
        padding: 8px 12px;
        font-size: 14px;
        border-radius: 8px;
      }

      #scoreboard div {
        margin: 3px 0;
      }

      #ball-state {
        top: 10px;
        right: 10px;
        padding: 6px 12px;
        font-size: 13px;
        border-radius: 8px;
      }

      #distance-display {
        bottom: 10px;
        right: 10px;
        padding: 10px 15px;
        font-size: 18px;
        border-radius: 8px;
      }

      #distance-display .label {
        font-size: 10px;
      }

      #club-selector-container {
        bottom: 8px;
        max-width: calc(100% - 16px);
      }

      #club-selector {
        padding: 10px 12px 8px 12px;
        gap: 2px;
        overflow-x: auto;
        -webkit-overflow-scrolling: touch;
        border-radius: 15px 15px 6px 6px;
      }

      .club-slot {
        padding: 3px;
      }

      .club-head {
        width: 38px;
        height: 38px;
        font-size: 10px;
      }

      .club-shaft {
        height: 25px;
        width: 3px;
      }

      .club-distance {
        font-size: 8px;
      }

      #club-toggle-btn {
        padding: 6px 14px;
        font-size: 12px;
        margin-top: 5px;
      }

      .button {
        padding: 8px 16px;
        margin: 3px;
        font-size: 13px;
        border-radius: 6px;
      }

      #menu-container {
        padding: 20px 15px;
      }

      #menu-container h1 {
        font-size: 32px;
      }

      #round-progress {
        top: auto;
        bottom: 120px;
        left: 10px;
        font-size: 12px;
        padding: 6px 12px;
      }

      .overlay-panel {
        padding: 20px 15px;
        max-width: 95%;
      }

      .overlay-panel h2 {
        font-size: 22px;
      }

      .scorecard-table, .leaderboard-table {
        font-size: 13px;
      }

      .scorecard-table th,
      .scorecard-table td,
      .leaderboard-table th,
      .leaderboard-table td {
        padding: 6px 8px;
      }
    }

    /* Small tablets and large phones */
    @media (min-width: 481px) and (max-width: 768px) {
      #scoreboard {
        top: 15px;
        left: 15px;
        padding: 12px 16px;
        font-size: 16px;
      }

      #ball-state {
        top: 15px;
        right: 15px;
        padding: 8px 16px;
        font-size: 14px;
      }

      #distance-display {
        bottom: 15px;
        right: 15px;
        padding: 12px 20px;
        font-size: 20px;
      }

      #club-selector-container {
        bottom: 12px;
        max-width: calc(100% - 24px);
      }

      #club-selector {
        padding: 12px 16px 8px 16px;
        gap: 3px;
        overflow-x: auto;
        -webkit-overflow-scrolling: touch;
      }

      .club-head {
        width: 42px;
        height: 42px;
        font-size: 11px;
      }

      .club-shaft {
        height: 30px;
      }

      .button {
        padding: 10px 20px;
        margin: 4px;
        font-size: 15px;
      }
    }

    /* Mailbox System */
    .mailbox-badge {
      position: absolute;
      top: -5px;
      right: -5px;
      background: #f44336;
      color: white;
      border-radius: 50%;
      min-width: 16px;
      height: 16px;
      font-size: 10px;
      font-weight: bold;
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: none;
    }
    .mailbox-badge.hidden { display: none; }
    .ingame-settings-btn { position: relative; }

    #mailbox-overlay {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.92);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      padding: 20px;
      z-index: 1500;
      overflow-y: auto;
    }
    #mailbox-overlay.hidden { display: none; }
    #mailbox-overlay h2 { color: #fff; margin-bottom: 15px; }

    .mailbox-actions {
      margin-bottom: 15px;
      display: flex;
      gap: 10px;
    }

    #mailbox-content {
      width: 100%;
      max-width: 500px;
      max-height: 60vh;
      overflow-y: auto;
    }

    .notification-item {
      background: rgba(255,255,255,0.08);
      border-radius: 10px;
      padding: 14px;
      margin-bottom: 10px;
      cursor: pointer;
      border-left: 3px solid transparent;
      transition: all 0.2s;
    }
    .notification-item:hover {
      background: rgba(255,255,255,0.12);
    }
    .notification-item.unread {
      border-left-color: #4CAF50;
      background: rgba(76, 175, 80, 0.15);
    }
    .notification-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 6px;
    }
    .notification-type {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      color: rgba(255,255,255,0.5);
    }
    .notification-timestamp {
      font-size: 11px;
      color: rgba(255,255,255,0.4);
    }
    .notification-title {
      font-weight: bold;
      color: #fff;
      font-size: 15px;
      margin-bottom: 4px;
    }
    .notification-message {
      color: rgba(255,255,255,0.7);
      font-size: 13px;
    }
    .notification-leaderboard {
      margin-top: 10px;
      max-height: 200px;
      overflow-y: auto;
      background: rgba(0,0,0,0.3);
      border-radius: 8px;
      padding: 8px;
    }
    .notification-leaderboard .lb-entry {
      display: flex;
      justify-content: space-between;
      padding: 4px 8px;
      font-size: 12px;
      color: rgba(255,255,255,0.8);
    }
    .notification-leaderboard .lb-entry.player {
      background: rgba(76, 175, 80, 0.3);
      border-radius: 4px;
      font-weight: bold;
    }
    .notification-empty {
      text-align: center;
      color: rgba(255,255,255,0.5);
      padding: 40px 20px;
      font-size: 14px;
    }
    .mailbox-view-btn {
      margin-top: 10px;
      padding: 8px 16px;
      background: linear-gradient(135deg, #4CAF50, #45a049);
      color: white;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 13px;
      font-weight: bold;
      transition: all 0.2s;
    }
    .mailbox-view-btn:hover {
      background: linear-gradient(135deg, #45a049, #3d8b40);
      transform: scale(1.02);
    }
    .mailbox-view-btn:active {
      transform: scale(0.98);
    }

    /* Game Mode Selection */
    #game-mode-overlay {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: linear-gradient(135deg, rgba(15, 32, 39, 0.97), rgba(32, 58, 67, 0.97), rgba(44, 83, 100, 0.97));
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1500;
    }
    #game-mode-overlay.hidden { display: none; }

    .game-mode-modal {
      background: linear-gradient(145deg, #1e3a4c, #0d1f2d);
      border-radius: 24px;
      padding: 35px 30px;
      max-width: 420px;
      width: 92%;
      text-align: center;
      border: 2px solid rgba(76, 175, 80, 0.3);
      box-shadow: 0 20px 60px rgba(0,0,0,0.5), 0 0 40px rgba(76, 175, 80, 0.1);
    }
    .game-mode-header {
      margin-bottom: 28px;
    }
    .game-mode-header .header-icon {
      font-size: 48px;
      display: block;
      margin-bottom: 12px;
      filter: drop-shadow(0 4px 8px rgba(0,0,0,0.3));
    }
    .game-mode-modal h2 {
      color: #fff;
      margin: 0;
      font-size: 26px;
      text-shadow: 0 2px 4px rgba(0,0,0,0.3);
      letter-spacing: 1px;
    }
    .game-mode-options {
      display: flex;
      flex-direction: column;
      gap: 14px;
      margin-bottom: 24px;
    }
    .game-mode-btn {
      background: linear-gradient(135deg, rgba(255,255,255,0.1), rgba(255,255,255,0.03));
      border: 2px solid rgba(255,255,255,0.12);
      border-radius: 16px;
      padding: 18px 20px;
      cursor: pointer;
      transition: all 0.25s ease;
      text-align: left;
      position: relative;
      display: flex;
      align-items: center;
      gap: 16px;
      overflow: hidden;
    }
    .game-mode-btn::before {
      content: '';
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      background: linear-gradient(135deg, transparent, rgba(255,255,255,0.05));
      opacity: 0;
      transition: opacity 0.25s;
    }
    .game-mode-btn:hover::before {
      opacity: 1;
    }
    .game-mode-btn:hover {
      transform: translateX(6px);
      border-color: rgba(76, 175, 80, 0.6);
      box-shadow: 0 8px 25px rgba(0,0,0,0.3), 0 0 20px rgba(76, 175, 80, 0.15);
    }
    .game-mode-btn:active {
      transform: translateX(3px) scale(0.98);
    }
    .game-mode-btn .mode-icon-wrap {
      width: 56px;
      height: 56px;
      border-radius: 14px;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
    }
    #quick-play-btn .mode-icon-wrap {
      background: linear-gradient(135deg, #4CAF50, #2E7D32);
      box-shadow: 0 4px 15px rgba(76, 175, 80, 0.4);
    }
    #tournament-play-btn .mode-icon-wrap {
      background: linear-gradient(135deg, #FFD700, #FFA000);
      box-shadow: 0 4px 15px rgba(255, 215, 0, 0.4);
    }
    #minigame-play-btn .mode-icon-wrap {
      background: linear-gradient(135deg, #E91E63, #AD1457);
      box-shadow: 0 4px 15px rgba(233, 30, 99, 0.4);
    }
    .game-mode-btn .mode-icon {
      font-size: 28px;
      filter: drop-shadow(0 2px 3px rgba(0,0,0,0.3));
    }
    .game-mode-btn .mode-text {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    .game-mode-btn .mode-title {
      font-size: 18px;
      font-weight: bold;
      color: #fff;
      text-shadow: 0 1px 2px rgba(0,0,0,0.2);
    }
    .game-mode-btn .mode-subtitle {
      font-size: 13px;
      color: rgba(255,255,255,0.55);
    }
    .game-mode-btn .mode-arrow {
      margin-left: auto;
      color: rgba(255,255,255,0.3);
      font-size: 20px;
      transition: all 0.25s;
    }
    .game-mode-btn:hover .mode-arrow {
      color: #4CAF50;
      transform: translateX(4px);
    }
    .game-mode-btn.daily-highlight {
      border-color: rgba(255, 215, 0, 0.5);
      background: linear-gradient(135deg, rgba(255, 215, 0, 0.15), rgba(255, 215, 0, 0.05));
    }
    .game-mode-btn.daily-highlight .mode-icon-wrap {
      animation: pulse-glow 2s ease-in-out infinite;
    }
    @keyframes pulse-glow {
      0%, 100% { box-shadow: 0 4px 15px rgba(233, 30, 99, 0.4); }
      50% { box-shadow: 0 4px 25px rgba(233, 30, 99, 0.7), 0 0 30px rgba(255, 215, 0, 0.3); }
    }
    .game-mode-btn.daily-highlight::after {
      content: "NEW";
      position: absolute;
      top: 8px;
      right: 12px;
      background: linear-gradient(135deg, #FFD700, #FFA000);
      color: #000;
      font-size: 9px;
      font-weight: bold;
      padding: 3px 8px;
      border-radius: 10px;
      letter-spacing: 0.5px;
    }
    #cancel-mode-btn {
      background: transparent;
      border: 1px solid rgba(255,255,255,0.2);
      color: rgba(255,255,255,0.6);
      padding: 12px 30px;
      border-radius: 10px;
      font-size: 14px;
      cursor: pointer;
      transition: all 0.2s;
    }
    #cancel-mode-btn:hover {
      background: rgba(255,255,255,0.08);
      border-color: rgba(255,255,255,0.3);
      color: #fff;
    }

    /* Career Mode Button Highlight - Purple Theme */
    .career-mode-btn {
      background: linear-gradient(135deg, rgba(139, 92, 246, 0.2), rgba(124, 58, 237, 0.15)) !important;
      border-color: rgba(139, 92, 246, 0.4) !important;
    }
    .career-mode-btn:hover {
      background: linear-gradient(135deg, rgba(139, 92, 246, 0.3), rgba(124, 58, 237, 0.2)) !important;
      border-color: rgba(139, 92, 246, 0.6) !important;
    }
    .career-mode-btn .mode-icon-wrap {
      background: linear-gradient(135deg, #8B5CF6, #7C3AED) !important;
      box-shadow: 0 4px 15px rgba(139, 92, 246, 0.5) !important;
      position: relative;
    }
    .new-badge {
      position: absolute;
      top: -8px;
      right: -8px;
      background: linear-gradient(135deg, #EF4444, #DC2626);
      color: #fff;
      font-size: 9px;
      font-weight: bold;
      padding: 3px 6px;
      border-radius: 8px;
      letter-spacing: 0.5px;
      box-shadow: 0 2px 8px rgba(239, 68, 68, 0.5);
      animation: badge-pulse 2s ease-in-out infinite;
    }
    @keyframes badge-pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.1); }
    }

    /* Career Mode Entry Overlay */
    #career-entry-overlay {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: linear-gradient(135deg, #1a1040 0%, #2d1b69 50%, #1a1040 100%);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1600;
    }
    #career-entry-overlay.hidden { display: none; }

    .career-entry-modal {
      background: linear-gradient(145deg, #1e2a4c, #0d1525);
      border-radius: 24px;
      padding: 35px 30px;
      max-width: 450px;
      width: 92%;
      text-align: center;
      border: 2px solid rgba(139, 92, 246, 0.4);
      box-shadow: 0 20px 60px rgba(0,0,0,0.5), 0 0 40px rgba(139, 92, 246, 0.15);
    }
    .career-entry-header {
      margin-bottom: 20px;
    }
    .career-entry-header .header-icon {
      font-size: 48px;
      display: block;
      margin-bottom: 12px;
    }
    .career-entry-header h2 {
      color: #A78BFA;
      margin: 0;
      font-size: 28px;
      text-shadow: 0 2px 8px rgba(139, 92, 246, 0.4);
    }
    .career-intro {
      color: rgba(255,255,255,0.8);
      font-size: 14px;
      margin-bottom: 20px;
      line-height: 1.5;
    }
    .career-slots {
      display: flex;
      flex-direction: column;
      gap: 12px;
      margin-bottom: 20px;
    }
    .career-slot {
      background: rgba(255,255,255,0.05);
      border: 2px solid rgba(255,255,255,0.1);
      border-radius: 12px;
      padding: 15px;
      cursor: pointer;
      transition: all 0.2s;
      text-align: left;
      display: flex;
      align-items: center;
      gap: 15px;
    }
    .career-slot:hover {
      background: rgba(255,255,255,0.1);
      border-color: rgba(139, 92, 246, 0.5);
    }
    .career-slot.empty {
      justify-content: center;
      color: rgba(255,255,255,0.5);
    }
    .career-slot-avatar {
      width: 50px;
      height: 65px;
      background: rgba(0,0,0,0.3);
      border-radius: 8px;
    }
    .career-slot-info {
      flex: 1;
    }
    .career-slot-name {
      color: #fff;
      font-size: 16px;
      font-weight: bold;
    }
    .career-slot-details {
      color: rgba(255,255,255,0.6);
      font-size: 12px;
      margin-top: 4px;
    }
    .career-slot-delete {
      background: rgba(239, 68, 68, 0.2);
      border: 1px solid rgba(239, 68, 68, 0.4);
      color: #ef4444;
      width: 28px;
      height: 28px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s;
      flex-shrink: 0;
    }
    .career-slot-delete:hover {
      background: rgba(239, 68, 68, 0.4);
      border-color: #ef4444;
    }
    .career-entry-buttons {
      display: flex;
      gap: 12px;
      justify-content: center;
    }
    .career-btn {
      padding: 12px 24px;
      border-radius: 12px;
      font-size: 14px;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.2s;
      border: none;
    }
    .career-btn.primary {
      background: linear-gradient(135deg, #8B5CF6, #7C3AED);
      color: #fff;
    }
    .career-btn.primary:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 15px rgba(139, 92, 246, 0.5);
    }
    .career-btn.secondary {
      background: rgba(255,255,255,0.1);
      color: #fff;
      border: 1px solid rgba(255,255,255,0.2);
    }
    .career-btn.secondary:hover {
      background: rgba(255,255,255,0.15);
    }

    /* Character Creator */
    /* ===== CHARACTER CREATOR - Premium Redesign ===== */
    #character-creator-overlay {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: radial-gradient(ellipse at 50% 30%, #1a2a4a 0%, #0a1628 50%, #050d18 100%);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1650;
      overflow: hidden;
    }
    #character-creator-overlay::before {
      content: '';
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      background:
        radial-gradient(circle at 20% 80%, rgba(120, 200, 255, 0.03) 0%, transparent 50%),
        radial-gradient(circle at 80% 20%, rgba(200, 120, 255, 0.03) 0%, transparent 50%);
      pointer-events: none;
    }
    #character-creator-overlay.hidden { display: none; }

    .character-creator-modal {
      display: flex;
      flex-direction: column;
      width: 95%;
      max-width: 950px;
      height: 92vh;
      max-height: 750px;
      animation: creatorSlideIn 0.4s ease-out;
    }
    @keyframes creatorSlideIn {
      from { opacity: 0; transform: translateY(30px) scale(0.95); }
      to { opacity: 1; transform: translateY(0) scale(1); }
    }

    .creator-header {
      text-align: center;
      padding: 8px 0 12px;
      position: relative;
    }
    .creator-header h2 {
      color: #fff;
      margin: 0;
      font-size: 22px;
      font-weight: 300;
      letter-spacing: 2px;
      text-transform: uppercase;
      text-shadow: 0 0 30px rgba(100, 180, 255, 0.4);
    }
    .creator-header h2 span {
      color: #64B5F6;
      font-weight: 600;
    }
    .creator-subtitle {
      display: none;
    }

    .creator-main {
      display: flex;
      gap: 30px;
      flex: 1;
      min-height: 0;
      overflow: hidden;
    }

    /* Left side - Character Stage */
    .creator-stage {
      flex: 0 0 260px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }
    .creator-preview {
      position: relative;
      width: 220px;
      height: 300px;
      display: flex;
      align-items: flex-end;
      justify-content: center;
      padding-bottom: 15px;
    }
    .creator-preview::before {
      content: '';
      position: absolute;
      bottom: 0;
      left: 50%;
      transform: translateX(-50%);
      width: 200px;
      height: 100px;
      background: radial-gradient(ellipse at center, rgba(100, 180, 255, 0.15) 0%, transparent 70%);
      filter: blur(10px);
    }
    .creator-preview::after {
      content: '';
      position: absolute;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
      width: 180px;
      height: 30px;
      background: radial-gradient(ellipse at center, rgba(0,0,0,0.4) 0%, transparent 70%);
      border-radius: 50%;
    }
    #character-preview-canvas {
      display: block;
      position: relative;
      z-index: 1;
      filter: drop-shadow(0 10px 30px rgba(0,0,0,0.5));
    }
    .stage-platform {
      position: absolute;
      bottom: 0;
      left: 50%;
      transform: translateX(-50%);
      width: 220px;
      height: 20px;
      background: linear-gradient(180deg, #2a3a5a 0%, #1a2a4a 100%);
      border-radius: 50%;
      border: 1px solid rgba(100, 180, 255, 0.2);
    }
    .creator-name-display {
      margin-top: 15px;
      padding: 8px 24px;
      background: rgba(0,0,0,0.3);
      border-radius: 20px;
      border: 1px solid rgba(100, 180, 255, 0.2);
    }
    .creator-name-display input {
      background: transparent;
      border: none;
      color: #fff;
      font-size: 18px;
      text-align: center;
      width: 150px;
      outline: none;
      font-weight: 500;
      letter-spacing: 1px;
    }
    .creator-name-display input::placeholder {
      color: rgba(255,255,255,0.3);
    }

    /* Right side - Options Panel */
    .creator-options {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 14px;
      overflow-y: auto;
      padding-right: 10px;
    }
    .creator-options::-webkit-scrollbar {
      width: 6px;
    }
    .creator-options::-webkit-scrollbar-track {
      background: rgba(255,255,255,0.05);
      border-radius: 3px;
    }
    .creator-options::-webkit-scrollbar-thumb {
      background: rgba(100, 180, 255, 0.3);
      border-radius: 3px;
    }

    .creator-section {
      background: linear-gradient(135deg, rgba(30, 50, 80, 0.6) 0%, rgba(20, 35, 60, 0.6) 100%);
      border-radius: 12px;
      padding: 12px 16px;
      border: 1px solid rgba(100, 180, 255, 0.1);
      transition: all 0.3s ease;
    }
    .creator-section:hover {
      border-color: rgba(100, 180, 255, 0.25);
      background: linear-gradient(135deg, rgba(35, 55, 90, 0.7) 0%, rgba(25, 40, 70, 0.7) 100%);
    }
    .creator-section label {
      display: block;
      color: rgba(255,255,255,0.6);
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 1.5px;
      margin-bottom: 10px;
      font-weight: 500;
    }

    /* Gender Toggle */
    .gender-toggle {
      display: flex;
      gap: 10px;
    }
    .gender-btn {
      flex: 1;
      padding: 10px;
      border-radius: 10px;
      border: 2px solid rgba(255,255,255,0.1);
      background: rgba(255,255,255,0.03);
      color: rgba(255,255,255,0.6);
      font-size: 13px;
      cursor: pointer;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
    }
    .gender-btn .gender-icon {
      font-size: 18px;
      font-weight: bold;
      opacity: 0.7;
    }
    .gender-btn:hover {
      border-color: rgba(100, 180, 255, 0.3);
      background: rgba(100, 180, 255, 0.05);
    }
    .gender-btn.selected {
      border-color: #64B5F6;
      background: linear-gradient(135deg, rgba(100, 180, 255, 0.15) 0%, rgba(100, 150, 255, 0.1) 100%);
      color: #fff;
      box-shadow: 0 0 15px rgba(100, 180, 255, 0.2);
    }
    .gender-btn.selected .gender-icon {
      opacity: 1;
    }

    /* Color Swatches */
    .color-options {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
    }
    .color-option {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      border: 2px solid transparent;
      cursor: pointer;
      transition: all 0.2s ease;
      position: relative;
      box-shadow: 0 2px 6px rgba(0,0,0,0.3), inset 0 1px 2px rgba(255,255,255,0.1);
    }
    .color-option:hover {
      transform: scale(1.15);
      z-index: 1;
    }
    .color-option.selected {
      border-color: #64B5F6;
      transform: scale(1.1);
      box-shadow: 0 0 0 2px rgba(100, 180, 255, 0.3), 0 3px 12px rgba(100, 180, 255, 0.4);
    }
    .color-option.selected::after {
      content: '';
      position: absolute;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      width: 10px; height: 10px;
      background: #fff;
      border-radius: 50%;
      box-shadow: 0 0 8px #fff;
    }

    /* Style Options (Hairstyles) */
    .style-options {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }
    .style-option {
      width: 56px;
      height: 56px;
      border-radius: 12px;
      border: 2px solid rgba(255,255,255,0.1);
      background: linear-gradient(135deg, rgba(40, 60, 100, 0.5) 0%, rgba(30, 45, 80, 0.5) 100%);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
      padding: 4px;
      transition: all 0.2s ease;
    }
    .style-option:hover {
      border-color: rgba(100, 180, 255, 0.4);
      transform: translateY(-2px);
      box-shadow: 0 6px 15px rgba(0,0,0,0.3);
    }
    .style-option img {
      width: 100%;
      height: 100%;
      object-fit: contain;
      border-radius: 6px;
    }
    .style-option.selected {
      border-color: #64B5F6;
      background: linear-gradient(135deg, rgba(100, 180, 255, 0.2) 0%, rgba(80, 140, 220, 0.15) 100%);
      box-shadow: 0 0 15px rgba(100, 180, 255, 0.3);
      transform: translateY(-2px);
    }

    /* Bottom Buttons */
    .creator-buttons {
      display: flex;
      gap: 12px;
      justify-content: center;
      padding: 12px 0 8px;
      flex-shrink: 0;
    }
    .creator-btn {
      padding: 12px 32px;
      border-radius: 25px;
      font-size: 14px;
      font-weight: 600;
      letter-spacing: 1.5px;
      text-transform: uppercase;
      cursor: pointer;
      transition: all 0.3s ease;
      border: none;
    }
    .creator-btn.primary {
      background: linear-gradient(135deg, #4CAF50 0%, #2E7D32 100%);
      color: #fff;
      box-shadow: 0 4px 20px rgba(76, 175, 80, 0.4);
    }
    .creator-btn.primary:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 30px rgba(76, 175, 80, 0.6);
    }
    .creator-btn.secondary {
      background: transparent;
      color: rgba(255,255,255,0.6);
      border: 1px solid rgba(255,255,255,0.2);
    }
    .creator-btn.secondary:hover {
      background: rgba(255,255,255,0.05);
      color: #fff;
      border-color: rgba(255,255,255,0.4);
    }

    /* Responsive adjustments */
    @media (max-width: 800px) {
      .creator-main {
        flex-direction: column;
        gap: 20px;
      }
      .creator-stage {
        flex: none;
      }
      .creator-preview {
        width: 200px;
        height: 280px;
      }
      .creator-options {
        max-height: none;
      }
    }

    /* Career Hub */
    #career-hub-overlay {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: linear-gradient(135deg, rgba(15, 32, 39, 0.98), rgba(32, 58, 67, 0.98));
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1600;
    }
    #career-hub-overlay.hidden { display: none; }

    .career-hub-modal {
      background: transparent;
      border-radius: 0;
      padding: 20px;
      width: 100%;
      height: 100%;
      border: none;
      box-shadow: none;
      display: flex;
      flex-direction: column;
      gap: 15px;
      overflow-y: auto;
    }
    #career-hub-overlay {
      background: linear-gradient(135deg, #1a1040 0%, #2d1b69 50%, #1a1040 100%);
      overflow-y: auto;
    }
    .hub-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding-bottom: 15px;
      border-bottom: 1px solid rgba(139, 92, 246, 0.3);
    }
    .hub-player-info {
      display: flex;
      align-items: center;
      gap: 15px;
    }
    #hub-avatar-canvas {
      border-radius: 50%;
      background: transparent;
    }
    .hub-player-details {
      display: flex;
      flex-direction: column;
    }
    .hub-player-name {
      color: #fff;
      font-size: 20px;
      font-weight: bold;
    }
    .hub-tour-name {
      color: #A78BFA;
      font-size: 14px;
    }
    .hub-ranking-badge {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      background: linear-gradient(135deg, rgba(139, 92, 246, 0.3), rgba(124, 58, 237, 0.2));
      padding: 6px 12px;
      border-radius: 12px;
      border: 1px solid rgba(139, 92, 246, 0.4);
      margin-top: 8px;
    }
    .hub-ranking-badge span {
      color: #A78BFA;
      font-weight: bold;
      font-size: 14px;
    }
    .hub-currencies {
      display: flex;
      flex-direction: column;
      gap: 8px;
      align-items: flex-end;
    }
    .currency-display {
      display: flex;
      align-items: center;
      gap: 8px;
      background: rgba(0,0,0,0.3);
      padding: 8px 14px;
      border-radius: 20px;
    }
    .currency-display.premium {
      background: linear-gradient(135deg, rgba(139, 92, 246, 0.2), rgba(124, 58, 237, 0.1));
      border: 1px solid rgba(139, 92, 246, 0.4);
    }
    .currency-display span {
      color: #fff;
      font-size: 15px;
      font-weight: bold;
    }
    .hub-news-ticker {
      background: linear-gradient(90deg, rgba(139, 92, 246, 0.15), rgba(124, 58, 237, 0.2), rgba(139, 92, 246, 0.15));
      border: 1px solid rgba(139, 92, 246, 0.3);
      border-radius: 12px;
      padding: 12px 16px;
      overflow: hidden;
      display: flex;
      align-items: center;
      min-height: 48px;
    }
    .news-ticker-content {
      color: #FFA500;
      font-size: 14px;
      font-weight: 400;
      font-style: italic;
      white-space: nowrap;
      animation: scrollHeadlineHub 20s linear infinite;
      line-height: 1.4;
      display: inline-block;
      padding-left: 100%;
    }
    @keyframes scrollHeadlineHub {
      0% { transform: translateX(0); }
      100% { transform: translateX(-100%); }
    }
    .hub-next-tournament {
      background: linear-gradient(135deg, rgba(139, 92, 246, 0.15), rgba(124, 58, 237, 0.1));
      border: 1px solid rgba(139, 92, 246, 0.3);
      border-radius: 16px;
      padding: 20px;
    }
    .next-tournament-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
    }
    .next-label {
      color: #A78BFA;
      font-size: 12px;
      font-weight: bold;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    .season-week {
      color: rgba(255,255,255,0.6);
      font-size: 13px;
    }
    .next-tournament-info .tournament-name {
      color: #fff;
      font-size: 20px;
      font-weight: bold;
      display: block;
      margin-bottom: 10px;
    }
    .tournament-details {
      display: flex;
      gap: 20px;
      color: rgba(255,255,255,0.7);
      font-size: 14px;
    }
    .hub-stats-panel {
      background: rgba(0,0,0,0.2);
      border-radius: 16px;
      padding: 20px;
    }
    .hub-stats-panel h3 {
      color: rgba(255,255,255,0.7);
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 1px;
      margin: 0 0 15px 0;
    }
    .hub-stat {
      display: flex;
      justify-content: space-between;
      padding: 10px 0;
      border-bottom: 1px solid rgba(255,255,255,0.08);
    }
    .hub-stat span:first-child {
      color: rgba(255,255,255,0.6);
      font-size: 14px;
    }
    .hub-stat span:last-child {
      color: #fff;
      font-weight: bold;
      font-size: 16px;
    }
    .hub-progress-bar {
      background: rgba(0,0,0,0.3);
      border-radius: 10px;
      height: 24px;
      position: relative;
      margin-top: 12px;
      overflow: hidden;
    }
    .hub-progress-bar .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, #8B5CF6, #7C3AED);
      border-radius: 10px;
      transition: width 0.3s;
    }
    .hub-progress-bar .progress-label {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #fff;
      font-size: 11px;
      font-weight: bold;
      text-shadow: 0 1px 2px rgba(0,0,0,0.5);
    }
    .hub-actions {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
      margin-top: auto;
    }
    .hub-btn {
      background: rgba(255,255,255,0.08);
      border: 1px solid rgba(255,255,255,0.15);
      border-radius: 12px;
      padding: 16px 14px;
      color: #fff;
      font-size: 14px;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
    }
    .hub-btn:hover {
      background: rgba(255,255,255,0.12);
      border-color: rgba(255,255,255,0.25);
    }
    .hub-btn.primary {
      grid-column: 1 / -1;
      background: linear-gradient(135deg, #8B5CF6, #7C3AED);
      color: #fff;
      border: none;
      font-weight: bold;
      padding: 20px 24px;
    }
    .hub-btn.primary:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(139, 92, 246, 0.5);
    }
    .primary-btn-content {
      display: flex;
      align-items: center;
      gap: 15px;
    }
    .primary-btn-content .btn-icon {
      font-size: 32px;
    }
    .primary-btn-content .btn-text {
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      text-align: left;
    }
    .primary-btn-content .btn-main {
      font-size: 18px;
      font-weight: bold;
    }
    .primary-btn-content .btn-sub {
      font-size: 12px;
      opacity: 0.8;
      font-weight: normal;
    }
    /* Career Tournament Selection */
    #career-tournament-overlay {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: linear-gradient(135deg, #1a1040 0%, #2d1b69 50%, #1a1040 100%);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1650;
    }
    #career-tournament-overlay.hidden { display: none; }

    .career-tournament-modal {
      background: linear-gradient(145deg, #1e2a4c, #0d1525);
      border-radius: 24px;
      padding: 25px;
      max-width: 450px;
      width: 95%;
      border: 2px solid rgba(139, 92, 246, 0.4);
    }
    .tournament-header {
      text-align: center;
      margin-bottom: 20px;
    }
    .tournament-header h2 {
      color: #A78BFA;
      margin: 0 0 5px 0;
    }
    .tournament-week {
      color: rgba(255,255,255,0.6);
      font-size: 14px;
    }
    .tournament-list {
      display: flex;
      flex-direction: column;
      gap: 10px;
      margin-bottom: 20px;
      max-height: 400px;
      overflow-y: auto;
    }
    .tournament-option {
      background: rgba(255,255,255,0.05);
      border: 2px solid rgba(255,255,255,0.1);
      border-radius: 12px;
      padding: 15px;
      cursor: pointer;
      transition: all 0.2s;
    }
    .tournament-option:hover {
      background: rgba(255,255,255,0.1);
      border-color: rgba(139, 92, 246, 0.5);
    }
    .tournament-option-name {
      color: #fff;
      font-size: 16px;
      font-weight: bold;
      margin-bottom: 5px;
    }
    .tournament-option-details {
      color: rgba(255,255,255,0.6);
      font-size: 12px;
      display: flex;
      gap: 15px;
    }
    .tournament-confirm {
      text-align: center;
      padding: 20px;
    }
    .tournament-confirm-name {
      color: #fff;
      font-size: 28px;
      font-weight: bold;
      margin-bottom: 20px;
      text-shadow: 0 2px 10px rgba(139, 92, 246, 0.3);
    }
    .tournament-confirm-details {
      display: flex;
      justify-content: center;
      gap: 25px;
      margin-bottom: 30px;
    }
    .confirm-detail {
      display: flex;
      align-items: center;
      gap: 8px;
      color: rgba(255,255,255,0.8);
      font-size: 15px;
    }
    .confirm-detail span {
      font-size: 18px;
    }
    .tournament-start-btn {
      font-size: 18px !important;
      padding: 16px 50px !important;
    }

    /* Tour Coins Shop Overlay */
    #tour-coins-shop-overlay {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: linear-gradient(135deg, #1a1040 0%, #2d1b69 50%, #1a1040 100%);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1660;
    }
    #tour-coins-shop-overlay.hidden { display: none; }
    .shop-modal {
      background: linear-gradient(145deg, #1e2a4c, #0d1525);
      border-radius: 24px;
      padding: 25px;
      max-width: 700px;
      width: 95%;
      max-height: 90vh;
      border: 2px solid rgba(139, 92, 246, 0.4);
      display: flex;
      flex-direction: column;
    }
    .shop-body {
      display: flex;
      gap: 20px;
      flex: 1;
      min-height: 0;
    }
    .shop-character-panel {
      flex: 0 0 180px;
      display: flex;
      flex-direction: column;
      align-items: center;
      background: linear-gradient(180deg, rgba(139, 92, 246, 0.1) 0%, rgba(30, 42, 76, 0.5) 100%);
      border-radius: 16px;
      padding: 15px;
      border: 1px solid rgba(139, 92, 246, 0.3);
    }
    .shop-character-canvas {
      width: 160px;
      height: 280px;
      border-radius: 12px;
      background: radial-gradient(ellipse at center bottom, rgba(139, 92, 246, 0.2) 0%, transparent 70%);
    }
    .shop-character-label {
      color: rgba(255,255,255,0.7);
      font-size: 12px;
      margin-top: 10px;
      text-align: center;
    }
    .shop-trying-on {
      color: #A78BFA;
      font-size: 13px;
      font-weight: bold;
      margin-top: 8px;
      text-align: center;
      min-height: 20px;
    }
    .shop-equipped-list {
      margin-top: 12px;
      width: 100%;
      font-size: 11px;
      color: rgba(255,255,255,0.6);
    }
    .shop-equipped-item {
      display: flex;
      justify-content: space-between;
      padding: 4px 8px;
      background: rgba(255,255,255,0.05);
      border-radius: 6px;
      margin-bottom: 4px;
    }
    .shop-equipped-item span:first-child {
      color: #FFD700;
    }
    .shop-items-panel {
      flex: 1;
      display: flex;
      flex-direction: column;
      min-width: 0;
    }
    .shop-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
      padding-bottom: 15px;
      border-bottom: 1px solid rgba(139, 92, 246, 0.3);
    }
    .shop-header h2 {
      color: #A78BFA;
      margin: 0;
      font-size: 24px;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .shop-balance {
      display: flex;
      align-items: center;
      gap: 8px;
      background: linear-gradient(135deg, rgba(139, 92, 246, 0.3), rgba(124, 58, 237, 0.2));
      padding: 10px 16px;
      border-radius: 20px;
      border: 1px solid rgba(139, 92, 246, 0.5);
    }
    .shop-balance span {
      color: #fff;
      font-size: 18px;
      font-weight: bold;
    }
    .shop-tabs {
      display: flex;
      gap: 8px;
      margin-bottom: 15px;
    }
    .shop-tab {
      flex: 1;
      padding: 12px;
      background: rgba(255,255,255,0.05);
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 10px;
      color: rgba(255,255,255,0.6);
      font-size: 13px;
      cursor: pointer;
      transition: all 0.2s;
    }
    .shop-tab:hover {
      background: rgba(255,255,255,0.1);
    }
    .shop-tab.active {
      background: linear-gradient(135deg, rgba(139, 92, 246, 0.3), rgba(124, 58, 237, 0.2));
      border-color: rgba(139, 92, 246, 0.5);
      color: #fff;
    }
    .shop-items {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 10px;
      overflow-y: auto;
      max-height: 380px;
      padding-right: 5px;
    }
    .shop-item {
      background: rgba(255,255,255,0.05);
      border: 2px solid rgba(255,255,255,0.1);
      border-radius: 14px;
      padding: 12px;
      text-align: center;
      cursor: pointer;
      transition: all 0.2s;
      position: relative;
    }
    .shop-item:hover {
      background: rgba(255,255,255,0.1);
      border-color: rgba(139, 92, 246, 0.5);
      transform: translateY(-2px);
    }
    .shop-item.selected {
      border-color: #A78BFA;
      background: rgba(139, 92, 246, 0.2);
      box-shadow: 0 0 15px rgba(139, 92, 246, 0.4);
    }
    .shop-item.owned {
      border-color: #4CAF50;
      background: rgba(76, 175, 80, 0.1);
    }
    .shop-item.owned.selected {
      border-color: #4CAF50;
      box-shadow: 0 0 15px rgba(76, 175, 80, 0.4);
    }
    .shop-item.equipped {
      border-color: #FFD700;
      background: rgba(255, 215, 0, 0.15);
    }
    .shop-item.equipped.selected {
      box-shadow: 0 0 15px rgba(255, 215, 0, 0.4);
    }
    .shop-item-preview {
      font-size: 32px;
      margin-bottom: 6px;
    }
    .shop-item-name {
      color: #fff;
      font-size: 12px;
      font-weight: bold;
      margin-bottom: 6px;
    }
    .shop-set-contents {
      display: flex;
      flex-direction: row;
      flex-wrap: wrap;
      justify-content: center;
      gap: 3px;
      font-size: 8px;
      color: rgba(255,255,255,0.7);
      margin-bottom: 8px;
    }
    .shop-set-contents span {
      background: rgba(139, 92, 246, 0.3);
      padding: 3px 6px;
      border-radius: 6px;
      white-space: nowrap;
    }
    .set-item {
      min-height: 150px;
      min-width: 130px;
    }
    .shop-items-grid.sets-grid {
      grid-template-columns: repeat(2, 1fr);
      gap: 12px;
    }
    .shop-item-price {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 5px;
      color: #A78BFA;
      font-size: 13px;
      font-weight: bold;
      margin-bottom: 8px;
    }
    .shop-item-price.owned {
      color: #4CAF50;
    }
    .shop-item-btn {
      width: 100%;
      padding: 8px;
      border: none;
      border-radius: 8px;
      font-size: 11px;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.2s;
    }
    .shop-item-btn.buy-btn {
      background: linear-gradient(135deg, #8B5CF6, #7C3AED);
      color: #fff;
    }
    .shop-item-btn.buy-btn:hover {
      transform: scale(1.02);
    }
    .shop-item-btn.buy-btn:disabled {
      background: #555;
      cursor: not-allowed;
      transform: none;
    }
    .shop-item-btn.equip-btn {
      background: linear-gradient(135deg, #4CAF50, #388E3C);
      color: #fff;
    }
    .shop-item-btn.unequip-btn {
      background: linear-gradient(135deg, #FF9800, #F57C00);
      color: #fff;
    }
    .shop-item-badge {
      position: absolute;
      top: 6px;
      right: 6px;
      font-size: 9px;
      padding: 2px 6px;
      border-radius: 8px;
      font-weight: bold;
    }
    .shop-item-badge.owned-badge {
      background: #4CAF50;
      color: #fff;
    }
    .shop-item-badge.equipped-badge {
      background: #FFD700;
      color: #000;
    }
    .shop-back-btn {
      margin-top: 15px;
      width: 100%;
      padding: 14px;
      background: rgba(255,255,255,0.08);
      border: 1px solid rgba(255,255,255,0.15);
      border-radius: 12px;
      color: #fff;
      font-size: 14px;
      cursor: pointer;
      transition: all 0.2s;
    }
    .shop-back-btn:hover {
      background: rgba(255,255,255,0.12);
    }

    /* Sponsors Management Overlay */
    #sponsors-overlay {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: linear-gradient(135deg, #1a1040 0%, #2d1b69 50%, #1a1040 100%);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1660;
    }
    #sponsors-overlay.hidden { display: none; }
    .sponsors-modal {
      background: linear-gradient(145deg, #1e2a4c, #0d1525);
      border-radius: 24px;
      padding: 25px;
      max-width: 500px;
      width: 95%;
      max-height: 85vh;
      border: 2px solid rgba(139, 92, 246, 0.4);
      display: flex;
      flex-direction: column;
    }
    .sponsors-header {
      text-align: center;
      margin-bottom: 20px;
      padding-bottom: 15px;
      border-bottom: 1px solid rgba(139, 92, 246, 0.3);
    }
    .sponsors-header h2 {
      color: #A78BFA;
      margin: 0 0 5px 0;
      font-size: 24px;
    }
    .sponsors-header p {
      color: rgba(255,255,255,0.6);
      margin: 0;
      font-size: 13px;
    }
    .sponsor-section {
      margin-bottom: 20px;
    }
    .sponsor-section h3 {
      color: #fff;
      font-size: 14px;
      margin: 0 0 10px 0;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .sponsor-card {
      background: rgba(255,255,255,0.05);
      border: 2px solid rgba(255,255,255,0.1);
      border-radius: 14px;
      padding: 15px;
    }
    .sponsor-card.active {
      border-color: rgba(139, 92, 246, 0.5);
      background: rgba(139, 92, 246, 0.1);
    }
    .sponsor-card.empty {
      border-style: dashed;
      text-align: center;
      color: rgba(255,255,255,0.4);
      padding: 25px 15px;
    }
    .sponsor-info {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 12px;
    }
    .sponsor-icon-large {
      font-size: 32px;
    }
    .sponsor-details {
      flex: 1;
    }
    .sponsor-name {
      color: #fff;
      font-size: 16px;
      font-weight: bold;
    }
    .sponsor-level {
      color: #A78BFA;
      font-size: 12px;
    }
    .sponsor-progress {
      background: rgba(0,0,0,0.3);
      border-radius: 8px;
      height: 8px;
      overflow: hidden;
      margin-bottom: 8px;
    }
    .sponsor-progress-fill {
      height: 100%;
      background: linear-gradient(90deg, #8B5CF6, #7C3AED);
      border-radius: 8px;
      transition: width 0.3s;
    }
    .sponsor-bonuses {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }
    .sponsor-bonus {
      background: rgba(76, 175, 80, 0.2);
      color: #81C784;
      padding: 4px 10px;
      border-radius: 12px;
      font-size: 11px;
      font-weight: bold;
    }
    .sponsors-back-btn {
      margin-top: 15px;
      width: 100%;
      padding: 14px;
      background: rgba(255,255,255,0.08);
      border: 1px solid rgba(255,255,255,0.15);
      border-radius: 12px;
      color: #fff;
      font-size: 14px;
      cursor: pointer;
      transition: all 0.2s;
    }
    .sponsors-back-btn:hover {
      background: rgba(255,255,255,0.12);
    }

    /* Debut Cutscene Overlay */
    #debut-cutscene-overlay {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: #000;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1750;
    }
    #debut-cutscene-overlay.hidden { display: none; }
    .debut-cutscene {
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }
    .debut-scene {
      width: 100%;
      max-width: 600px;
      padding: 40px;
      animation: fadeIn 0.5s ease;
    }
    .debut-scene.hidden { display: none; }
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(20px); }
      to { opacity: 1; transform: translateY(0); }
    }
    .debut-backdrop {
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      background: linear-gradient(135deg, #1a1040 0%, #2d1b69 50%, #1a1040 100%);
      z-index: -1;
    }
    .debut-content {
      text-align: center;
    }
    .debut-announcer {
      font-size: 60px;
      margin-bottom: 30px;
      animation: pulse 1.5s ease-in-out infinite;
    }
    .debut-text {
      color: #fff;
      font-size: 24px;
      line-height: 1.6;
      text-shadow: 0 2px 10px rgba(0,0,0,0.5);
    }
    .debut-interview {
      background: linear-gradient(145deg, #1e2a4c, #0d1525);
      border-radius: 20px;
      padding: 30px;
      border: 2px solid rgba(139, 92, 246, 0.4);
    }
    .interview-reporter {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 20px;
    }
    .reporter-icon {
      font-size: 36px;
    }
    .reporter-name {
      color: #A78BFA;
      font-weight: bold;
      font-size: 14px;
    }
    .interview-question {
      color: #fff;
      font-size: 18px;
      font-style: italic;
      margin-bottom: 25px;
      padding-left: 15px;
      border-left: 3px solid #A78BFA;
    }
    .interview-player {
      display: flex;
      align-items: center;
      gap: 15px;
      background: rgba(139, 92, 246, 0.1);
      padding: 15px;
      border-radius: 12px;
    }
    #debut-player-canvas {
      background: linear-gradient(180deg, #87CEEB 0%, #4CAF50 100%);
      border-radius: 10px;
    }
    .player-response {
      color: #E9D5FF;
      font-size: 16px;
      line-height: 1.5;
    }
    .debut-tee-intro {
      text-align: center;
    }
    .tee-intro-text {
      margin-bottom: 30px;
    }
    .intro-now {
      color: #A78BFA;
      font-size: 16px;
      letter-spacing: 3px;
      margin-bottom: 15px;
      animation: pulse 2s ease-in-out infinite;
    }
    .intro-name {
      color: #fff;
      font-size: 42px;
      font-weight: bold;
      text-shadow: 0 4px 20px rgba(139, 92, 246, 0.5);
      margin-bottom: 10px;
    }
    .intro-hometown {
      color: rgba(255,255,255,0.6);
      font-size: 16px;
    }
    #debut-golfer-canvas {
      background: linear-gradient(180deg, #87CEEB 0%, #4CAF50 100%);
      border-radius: 15px;
      box-shadow: 0 10px 40px rgba(0,0,0,0.5);
    }
    .debut-continue {
      margin-top: 30px;
    }

    /* Pre-Tournament Interview Overlay */
    #interview-overlay {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: linear-gradient(180deg, #0a0a0a 0%, #1a1a2e 100%);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1760;
    }
    #interview-overlay.hidden { display: none; }

    .interview-scene {
      width: 100%;
      height: 100%;
      max-width: 700px;
      display: flex;
      flex-direction: column;
      padding: 20px;
    }

    .interview-broadcast-banner {
      background: linear-gradient(90deg, #c41e3a 0%, #8b0000 100%);
      padding: 8px 20px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-radius: 8px;
      margin-bottom: 20px;
    }

    .broadcast-live {
      color: #fff;
      font-weight: bold;
      font-size: 14px;
      animation: pulse 1.5s ease-in-out infinite;
    }

    .broadcast-network {
      color: #fff;
      font-size: 16px;
      font-weight: bold;
      letter-spacing: 2px;
    }

    .interview-stage {
      flex: 1;
      display: flex;
      justify-content: center;
      align-items: flex-end;
      gap: 60px;
      padding: 20px;
      background: linear-gradient(180deg, #2c5f2d 0%, #1e4d2b 50%, #143d1a 100%);
      border-radius: 12px;
      position: relative;
      overflow: hidden;
    }

    .interview-stage::before {
      content: '';
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 30px;
      background: linear-gradient(0deg, rgba(0,0,0,0.3) 0%, transparent 100%);
    }

    .interview-reporter-side, .interview-player-side {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
    }

    #interview-reporter-canvas, #interview-player-canvas {
      border-radius: 8px;
    }

    .reporter-nameplate, .player-nameplate {
      background: rgba(0,0,0,0.8);
      color: #fff;
      padding: 6px 16px;
      border-radius: 4px;
      font-size: 14px;
      font-weight: bold;
      border-bottom: 3px solid #c41e3a;
    }

    #interview-player-canvas {
      border-radius: 8px;
    }

    .interview-dialogue-box {
      background: rgba(0,0,0,0.9);
      border-radius: 12px;
      padding: 20px;
      margin-top: 20px;
      border-left: 4px solid #c41e3a;
    }

    .interview-speaker {
      color: #c41e3a;
      font-weight: bold;
      font-size: 14px;
      margin-bottom: 8px;
      text-transform: uppercase;
    }

    .interview-text {
      color: #fff;
      font-size: 18px;
      line-height: 1.5;
    }

    .interview-controls {
      display: flex;
      gap: 15px;
      justify-content: center;
      margin-top: 20px;
    }

    .interview-responses {
      display: flex;
      flex-direction: column;
      gap: 10px;
      margin-top: 15px;
    }

    .interview-response-btn {
      background: linear-gradient(145deg, #1e3a5f, #0d1f3c);
      border: 2px solid rgba(100, 150, 200, 0.3);
      color: #fff;
      padding: 12px 20px;
      border-radius: 8px;
      font-size: 15px;
      cursor: pointer;
      text-align: left;
      transition: all 0.2s ease;
    }

    .interview-response-btn:hover {
      background: linear-gradient(145deg, #2a4a7f, #15294f);
      border-color: rgba(100, 150, 200, 0.6);
      transform: translateX(5px);
    }

    .interview-response-btn.selected {
      background: linear-gradient(145deg, #2e7d32, #1b5e20);
      border-color: #4CAF50;
    }

    .fanbase-gain {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: linear-gradient(145deg, #6B46C1, #553C9A);
      color: #fff;
      padding: 15px 30px;
      border-radius: 12px;
      font-size: 20px;
      font-weight: bold;
      animation: fanbasePopup 2s ease forwards;
      z-index: 2000;
      box-shadow: 0 10px 40px rgba(107, 70, 193, 0.5);
    }

    @keyframes fanbasePopup {
      0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
      20% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }
      40% { transform: translate(-50%, -50%) scale(1); }
      80% { opacity: 1; }
      100% { opacity: 0; transform: translate(-50%, -70%); }
    }

    .milestone-popup {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: linear-gradient(145deg, #1a1040 0%, #2d1b69 50%, #1a1040 100%);
      border: 3px solid #FFD700;
      border-radius: 20px;
      padding: 30px 50px;
      text-align: center;
      z-index: 2100;
      animation: milestoneAppear 4s ease forwards;
      box-shadow: 0 0 50px rgba(255, 215, 0, 0.5), 0 20px 60px rgba(0, 0, 0, 0.5);
    }

    @keyframes milestoneAppear {
      0% { opacity: 0; transform: translate(-50%, -50%) scale(0.3); }
      15% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }
      25% { transform: translate(-50%, -50%) scale(1); }
      85% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
      100% { opacity: 0; transform: translate(-50%, -60%) scale(0.9); }
    }

    .milestone-badge {
      font-size: 60px;
      margin-bottom: 10px;
      animation: starPulse 1s ease-in-out infinite;
    }

    @keyframes starPulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.2); }
    }

    .milestone-title {
      color: #FFD700;
      font-size: 28px;
      font-weight: bold;
      text-transform: uppercase;
      letter-spacing: 2px;
      margin-bottom: 5px;
      text-shadow: 0 2px 10px rgba(255, 215, 0, 0.5);
    }

    .milestone-fans {
      color: #fff;
      font-size: 20px;
      margin-bottom: 15px;
    }

    .milestone-message {
      color: #A78BFA;
      font-size: 16px;
      margin-bottom: 15px;
    }

    .milestone-rewards {
      display: flex;
      justify-content: center;
      gap: 20px;
    }

    .milestone-rewards span {
      background: rgba(255, 255, 255, 0.1);
      padding: 8px 16px;
      border-radius: 20px;
      color: #fff;
      font-size: 16px;
    }

    /* Sponsor Offer Overlay */
    #sponsor-offer-overlay {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.9);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1700;
    }
    #sponsor-offer-overlay.hidden { display: none; }

    .sponsor-offer-modal {
      background: linear-gradient(145deg, #1e2a4c, #0d1525);
      border-radius: 24px;
      padding: 30px;
      max-width: 400px;
      width: 90%;
      text-align: center;
      border: 2px solid rgba(139, 92, 246, 0.4);
    }
    .sponsor-offer-modal h2 {
      color: #A78BFA;
      margin: 0 0 10px 0;
    }
    .sponsor-offer-intro {
      color: rgba(255,255,255,0.7);
      font-size: 14px;
      margin-bottom: 20px;
    }
    .sponsor-offer-content {
      display: flex;
      flex-direction: column;
      gap: 12px;
      margin-bottom: 20px;
    }
    .sponsor-card {
      background: rgba(255,255,255,0.08);
      border: 2px solid rgba(255,255,255,0.15);
      border-radius: 12px;
      padding: 15px;
      cursor: pointer;
      transition: all 0.2s;
    }
    .sponsor-card:hover {
      border-color: #8B5CF6;
      background: rgba(139, 92, 246, 0.15);
    }
    .sponsor-card-header {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 8px;
    }
    .sponsor-icon {
      font-size: 24px;
    }
    .sponsor-name {
      color: #fff;
      font-weight: bold;
      font-size: 16px;
    }
    .sponsor-type {
      color: rgba(255,255,255,0.5);
      font-size: 11px;
      text-transform: uppercase;
    }
    .sponsor-benefits {
      color: rgba(255,255,255,0.7);
      font-size: 12px;
      text-align: left;
    }

    /* Career Dialogue Overlay */
    #career-dialogue-overlay {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.85);
      display: flex;
      align-items: flex-end;
      justify-content: center;
      z-index: 1800;
      padding-bottom: 50px;
    }
    #career-dialogue-overlay.hidden { display: none; }

    .dialogue-box {
      background: linear-gradient(145deg, #1e3a4c, #0d1f2d);
      border-radius: 16px;
      padding: 20px;
      max-width: 600px;
      width: 95%;
      display: flex;
      gap: 15px;
      align-items: flex-start;
      border: 2px solid rgba(255,255,255,0.2);
    }
    .dialogue-portrait {
      width: 80px;
      height: 80px;
      background: rgba(0,0,0,0.3);
      border-radius: 50%;
      flex-shrink: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 40px;
    }
    .dialogue-content {
      flex: 1;
    }
    .dialogue-speaker {
      color: #A78BFA;
      font-weight: bold;
      font-size: 14px;
      display: block;
      margin-bottom: 8px;
    }
    .dialogue-text {
      color: #fff;
      font-size: 15px;
      line-height: 1.5;
      margin: 0;
    }
    .dialogue-continue {
      position: absolute;
      bottom: 20px;
      right: 20px;
      background: linear-gradient(135deg, #8B5CF6, #7C3AED);
      border: none;
      color: #fff;
      padding: 10px 20px;
      border-radius: 8px;
      font-weight: bold;
      cursor: pointer;
    }

    /* Career Headlines */
    #career-headlines {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      background: linear-gradient(90deg, #1a1a2e, #2d2d44, #1a1a2e);
      padding: 10px 20px;
      z-index: 1100;
      overflow: hidden;
    }
    #career-headlines.hidden { display: none; }

    .headline-content {
      color: #A78BFA;
      font-size: 14px;
      white-space: nowrap;
      animation: scrollHeadline 15s linear infinite;
    }
    @keyframes scrollHeadline {
      0% { transform: translateX(100%); }
      100% { transform: translateX(-200%); }
    }

    /* Mini-Game Overlay */
    #minigame-overlay {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.95);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 1600;
    }
    #minigame-overlay.hidden { display: none; }
    .minigame-title {
      font-size: 32px;
      color: #FFD700;
      margin-bottom: 10px;
    }
    .minigame-desc {
      font-size: 16px;
      color: rgba(255,255,255,0.7);
      margin-bottom: 20px;
      text-align: center;
      max-width: 400px;
    }
    .minigame-timer {
      font-size: 48px;
      color: #fff;
      font-weight: bold;
      margin-bottom: 15px;
    }
    .minigame-score {
      font-size: 24px;
      color: #4CAF50;
      margin-bottom: 20px;
    }
    .minigame-result {
      background: linear-gradient(135deg, #1a1a2e, #16213e);
      border-radius: 20px;
      padding: 30px 50px;
      text-align: center;
      border: 2px solid #FFD700;
    }
    .minigame-result h3 {
      font-size: 28px;
      color: #FFD700;
      margin-bottom: 15px;
    }
    .minigame-result .final-score {
      font-size: 48px;
      color: #4CAF50;
      margin-bottom: 10px;
    }
    .minigame-result .high-score {
      font-size: 16px;
      color: rgba(255,255,255,0.6);
      margin-bottom: 20px;
    }
    .minigame-result .reward {
      font-size: 20px;
      color: #FFD700;
      margin-bottom: 20px;
    }
    .minigame-hud {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.8);
      padding: 10px 30px;
      border-radius: 20px;
      display: flex;
      gap: 30px;
      z-index: 1601;
    }
    .minigame-hud.hidden { display: none; }
    .minigame-hud-item {
      text-align: center;
    }
    .minigame-hud-label {
      font-size: 12px;
      color: rgba(255,255,255,0.6);
      text-transform: uppercase;
    }
    .minigame-hud-value {
      font-size: 24px;
      font-weight: bold;
      color: #fff;
    }
    .minigame-hud-value.timer { color: #FFD700; }
    .minigame-hud-value.score { color: #4CAF50; }

    /* UFO abduction effect */
    .ufo-popup {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) scale(0.8);
      background: linear-gradient(135deg, #4a0080, #000066);
      color: #88FF88;
      padding: 20px 35px;
      border-radius: 15px;
      font-size: 18px;
      z-index: 2002;
      opacity: 0;
      transition: all 0.3s ease-out;
      box-shadow: 0 10px 40px rgba(136, 255, 136, 0.3), 0 0 30px rgba(136, 255, 136, 0.2);
      text-align: center;
    }
    .ufo-popup.show {
      opacity: 1;
      transform: translate(-50%, -50%) scale(1);
    }

    /* Out of bounds popup */
    .oob-popup {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) scale(0.8);
      background: linear-gradient(135deg, #8B0000, #4a0000);
      color: #fff;
      padding: 20px 35px;
      border-radius: 15px;
      font-size: 18px;
      z-index: 2002;
      opacity: 0;
      transition: all 0.3s ease-out;
      box-shadow: 0 10px 40px rgba(139, 0, 0, 0.4);
      text-align: center;
    }
    .oob-popup.show {
      opacity: 1;
      transform: translate(-50%, -50%) scale(1);
    }
  </style>
</head>
<body>
  <canvas id="game-canvas"></canvas>

  <div id="ui-overlay">
    <div id="scoreboard">
      <div class="score-header">
        <span class="hole-info">Hole <span id="hole-number">1</span></span>
        <span class="par-info">Par <span id="hole-par">3</span></span>
        <button class="ingame-settings-btn" id="ingame-settings-btn" title="Settings">âš™ï¸</button>
      </div>
      <div class="score-row">
        <span class="score-label">Strokes</span>
        <span class="score-value" id="stroke-count">0</span>
      </div>
      <div class="score-row">
        <span class="score-label">Score</span>
        <span class="score-value" id="total-score">E</span>
      </div>
      <div class="club-info">
        <div class="club-name" id="current-club">Driver</div>
        <div class="distance-info"><span id="distance-to-hole">---</span> yds to hole</div>
      </div>
    </div>

    <div id="ball-state">ðŸ”´ Ready</div>

    <div id="powerups-display" class="hidden">
      <div class="powerups-label">Power-Ups:</div>
      <div class="powerups-list" id="powerups-list"></div>
    </div>

    <div id="wind-indicator" class="hidden wind-calm">
      <div class="wind-label">WIND</div>
      <div class="wind-arrow">âž¤</div>
      <div class="wind-speed">0 mph</div>
    </div>

    <div id="achievement-popup">
      <div class="achievement-icon">ðŸ†</div>
      <div class="achievement-title">Achievement Unlocked!</div>
      <div class="achievement-name"></div>
      <div class="achievement-desc"></div>
    </div>

    <div id="distance-display" class="hidden">
      <span class="label">Distance to Hole</span>
      <span id="distance-value">---</span>yd
    </div>

    <div id="round-progress" class="hidden">
      <strong>Progress:</strong> <span id="progress-text">0/9 holes</span>
    </div>

    <div id="club-selector-container">
      <div id="caddie-tip" class="hidden"></div>
      <div id="club-selector">
        <button class="button selected" data-club="driver">Driver</button>
      </div>
      <button id="club-toggle-btn">Hide Clubs</button>
    </div>

    <div id="scorecard-overlay" class="hidden">
      <h2>Scorecard</h2>
      <div id="scorecard-content"></div>
      <button class="button" onclick="document.getElementById('scorecard-overlay').classList.add('hidden')">Close</button>
    </div>

    <div id="leaderboard-overlay" class="hidden">
      <h2>ðŸ† Leaderboard - Top 10</h2>
      <div id="leaderboard-content"></div>
      <button class="button" onclick="document.getElementById('leaderboard-overlay').classList.add('hidden')">Close</button>
    </div>

    <div id="settings-overlay" class="hidden">
      <h2>âš™ï¸ Settings</h2>
      <div class="settings-group">
        <div class="settings-row">
          <span class="settings-label"><span class="icon">ðŸ”Š</span> Sound Effects</span>
          <label class="toggle-switch">
            <input type="checkbox" id="setting-sound" checked>
            <span class="toggle-slider"></span>
          </label>
        </div>
        <div class="settings-row">
          <span class="settings-label"><span class="icon">ðŸŽµ</span> Background Music</span>
          <label class="toggle-switch">
            <input type="checkbox" id="setting-music" checked>
            <span class="toggle-slider"></span>
          </label>
        </div>
        <div class="settings-row">
          <span class="settings-label"><span class="icon">ðŸ’¨</span> Ball Trails</span>
          <label class="toggle-switch">
            <input type="checkbox" id="setting-trails" checked>
            <span class="toggle-slider"></span>
          </label>
        </div>
        <div class="settings-row">
          <span class="settings-label"><span class="icon">ðŸŒªï¸</span> Random Events</span>
          <label class="toggle-switch">
            <input type="checkbox" id="setting-events" checked>
            <span class="toggle-slider"></span>
          </label>
        </div>
        <div class="settings-row">
          <span class="settings-label"><span class="icon">ðŸ“–</span> Reset Tutorial</span>
          <button class="button" id="reset-tutorial-btn" style="padding: 8px 16px; font-size: 14px;">Reset</button>
        </div>
        <div class="settings-row" style="flex-direction: column; align-items: flex-start; gap: 8px;">
          <span class="settings-label"><span class="icon">ðŸŒï¸</span> Swing Mode</span>
          <div class="swing-mode-selector" id="swing-mode-selector">
            <button class="swing-mode-btn active" data-mode="easy">
              <span class="mode-name">Easy</span>
              <span class="mode-desc">Drag & release</span>
            </button>
            <button class="swing-mode-btn" data-mode="pro">
              <span class="mode-name">Pro</span>
              <span class="mode-desc">Timing meter (+25% ðŸ’µ)</span>
            </button>
          </div>
        </div>
      </div>
      <div class="settings-buttons">
        <button class="button" id="close-settings-btn">Close</button>
      </div>
    </div>

    <div id="achievements-overlay" class="hidden">
      <h2>ðŸ† Achievements</h2>
      <div class="achievements-progress" id="achievements-progress">0 / 0 unlocked</div>
      <div class="achievements-grid" id="achievements-grid"></div>
      <div class="achievements-buttons">
        <button class="button" id="close-achievements-btn">Close</button>
      </div>
    </div>

    <!-- Mailbox Overlay -->
    <div id="mailbox-overlay" class="hidden">
      <h2>ðŸ“¬ Mailbox</h2>
      <div class="mailbox-actions">
        <button class="button" id="mark-all-read-btn">Mark All Read</button>
      </div>
      <div id="mailbox-content"></div>
      <button class="button" id="mailbox-close-btn">Close</button>
    </div>

    <!-- Shop Overlay -->
    <div id="shop-overlay" class="hidden">
      <div id="shop-modal">
        <div id="shop-header">
          <h2>Pro Shop</h2>
          <div id="shop-balance-display"><span id="shop-balance">0</span> Golf Bucks</div>
          <button id="shop-close-btn" class="shop-close-x">&times;</button>
        </div>
        <div id="shop-tabs">
          <button class="shop-tab active" data-tab="clubs">Clubs</button>
          <button class="shop-tab" data-tab="balls">Balls</button>
          <button class="shop-tab" data-tab="skins">Skins</button>
          <button class="shop-tab" data-tab="themes">Themes</button>
          <button class="shop-tab" data-tab="caddie">Caddie</button>
          <button class="shop-tab" data-tab="info">Info</button>
        </div>
        <div id="shop-content">
          <!-- Clubs Tab -->
          <div id="shop-tab-clubs" class="shop-tab-content active">
            <div class="shop-tab-header">
              <h3>Club Upgrades</h3>
              <p>Upgrade your clubs to hit farther and score better</p>
            </div>
            <div id="shop-tier-legend">
              <div class="tier-item basic"><span class="tier-stars">â˜…â˜†â˜†</span> Basic</div>
              <div class="tier-item standard"><span class="tier-stars">â˜…â˜…â˜†</span> Standard</div>
              <div class="tier-item pro"><span class="tier-stars">â˜…â˜…â˜…</span> Pro</div>
            </div>
            <div id="shop-clubs-grid"></div>
          </div>

          <!-- Balls Tab -->
          <div id="shop-tab-balls" class="shop-tab-content">
            <div class="shop-tab-header">
              <h3>Ball Collection</h3>
              <p>Customize your ball style on the course</p>
            </div>
            <div id="shop-balls-grid"></div>
          </div>

          <!-- Skins Tab -->
          <div id="shop-tab-skins" class="shop-tab-content">
            <div class="shop-tab-header">
              <h3>Club Skins</h3>
              <p>Cosmetic skins that apply to all your clubs</p>
            </div>
            <div id="shop-club-skins-grid"></div>
          </div>

          <!-- Themes Tab -->
          <div id="shop-tab-themes" class="shop-tab-content">
            <div class="shop-tab-header">
              <h3>Course Themes</h3>
              <p>Unlock new visual themes with unique physics</p>
            </div>
            <div id="shop-themes-grid"></div>
          </div>

          <!-- Caddie Tab -->
          <div id="shop-tab-caddie" class="shop-tab-content">
            <div id="caddie-shop-content"></div>
          </div>

          <!-- Info Tab -->
          <div id="shop-tab-info" class="shop-tab-content">
            <div class="shop-tab-header">
              <h3>How to Earn Golf Bucks</h3>
              <p>Play well to unlock more items!</p>
            </div>
            <div id="shop-info">
              <div class="earn-list">
                <div class="earn-item"><span>Birdie</span><span>+50 Golf Bucks</span></div>
                <div class="earn-item"><span>Eagle</span><span>+150 Golf Bucks</span></div>
                <div class="earn-item"><span>Hole-in-One</span><span>+500 Golf Bucks</span></div>
                <div class="earn-item"><span>Complete Round</span><span>+100 Golf Bucks</span></div>
                <div class="earn-item"><span>Under Par Bonus</span><span>+50/stroke</span></div>
                <div class="earn-item"><span>Achievement</span><span>+200 Golf Bucks</span></div>
                <div class="earn-item"><span>Daily Challenge</span><span>+25-200 Golf Bucks</span></div>
              </div>
              <div class="shop-tips">
                <h4>Tips</h4>
                <ul>
                  <li>Upgrade clubs to increase your distance</li>
                  <li>Pro swing mode gives 25% bonus Golf Bucks</li>
                  <li>Complete daily challenges for easy rewards</li>
                  <li>Themed courses add fun obstacles</li>
                </ul>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Game Mode Selection -->
    <div id="game-mode-overlay" class="hidden">
      <div class="game-mode-modal">
        <div class="game-mode-header">
          <span class="header-icon">ðŸŒï¸</span>
          <h2>Choose Game Mode</h2>
        </div>
        <div class="game-mode-options">
          <button class="game-mode-btn" id="quick-play-btn">
            <div class="mode-icon-wrap">
              <span class="mode-icon">â›³</span>
            </div>
            <div class="mode-text">
              <span class="mode-title">Quick Play</span>
              <span class="mode-subtitle">9 holes, casual round</span>
            </div>
            <span class="mode-arrow">â€º</span>
          </button>
          <button class="game-mode-btn" id="tournament-play-btn">
            <div class="mode-icon-wrap">
              <span class="mode-icon">ðŸ†</span>
            </div>
            <div class="mode-text">
              <span class="mode-title">Tournament</span>
              <span class="mode-subtitle">Compete for prizes</span>
            </div>
            <span class="mode-arrow">â€º</span>
          </button>
          <button class="game-mode-btn" id="minigame-play-btn">
            <div class="mode-icon-wrap">
              <span class="mode-icon">ðŸŽ¯</span>
            </div>
            <div class="mode-text">
              <span class="mode-title">Mini-Games</span>
              <span class="mode-subtitle" id="minigame-today-label">Daily challenge</span>
            </div>
            <span class="mode-arrow">â€º</span>
          </button>
          <button class="game-mode-btn career-mode-btn" id="career-play-btn">
            <div class="mode-icon-wrap">
              <span class="mode-icon">ðŸŒï¸</span>
              <span class="new-badge">NEW</span>
            </div>
            <div class="mode-text">
              <span class="mode-title">Career Mode</span>
              <span class="mode-subtitle">Build your legacy from rookie to legend!</span>
            </div>
            <span class="mode-arrow">â€º</span>
          </button>
        </div>
        <button id="cancel-mode-btn">Cancel</button>
      </div>
    </div>

    <!-- Mini-Game Overlay -->
    <div id="minigame-overlay" class="hidden">
      <div id="minigame-content"></div>
    </div>

    <!-- Mini-Game HUD (shown during gameplay) -->
    <div id="minigame-hud" class="minigame-hud hidden">
      <div class="minigame-hud-item">
        <div class="minigame-hud-label">Time</div>
        <div class="minigame-hud-value timer" id="minigame-timer">60</div>
      </div>
      <div class="minigame-hud-item">
        <div class="minigame-hud-label">Score</div>
        <div class="minigame-hud-value score" id="minigame-score">0</div>
      </div>
    </div>

    <div id="name-entry-overlay" class="hidden">
      <h2>Enter Your Name</h2>
      <p>Your scores will appear on the global leaderboard!</p>
      <input type="text" id="player-name-input" maxlength="20" placeholder="Your name" autocomplete="off">

      <div class="ball-color-section">
        <label>Choose Your Ball</label>
        <div class="ball-color-options" id="ball-color-options">
          <!-- Dynamically populated based on owned skins -->
        </div>
      </div>

      <div class="name-entry-buttons">
        <button class="button" id="start-with-name-btn">Start Game</button>
        <button class="button cancel-btn" id="cancel-name-entry-btn">Cancel</button>
      </div>
    </div>

    <div id="debug-info" class="hidden"></div>

    <button id="reset-shot-btn" class="hidden">Cancel Shot</button>

    <!-- Pro Swing Timing Meter -->
    <div id="timing-meter-overlay" class="hidden">
      <div class="timing-meter-container">
        <div class="timing-meter-label">TAP FOR ACCURACY!</div>
        <div class="timing-meter-bar">
          <div class="timing-meter-sweet-spot"></div>
          <div class="timing-meter-marker"></div>
        </div>
        <div class="timing-meter-hint">Perfect timing = straight shot</div>
      </div>
    </div>

    <div id="hole-complete-overlay" class="hidden">
      <div class="hole-complete-modal">
        <div class="hole-complete-header">Hole Complete</div>
        <div class="hole-complete-number" id="hole-complete-number">1</div>
        <div class="hole-complete-score-name" id="hole-complete-score-name">Par</div>
        <div class="hole-complete-details">
          <div class="hole-complete-stat">
            <div class="hole-complete-stat-value" id="hole-complete-strokes">4</div>
            <div class="hole-complete-stat-label">Strokes</div>
          </div>
          <div class="hole-complete-stat">
            <div class="hole-complete-stat-value" id="hole-complete-par">4</div>
            <div class="hole-complete-stat-label">Par</div>
          </div>
        </div>
        <div class="hole-complete-total">Round Total: <span id="hole-complete-total">E</span></div>
        <button class="hole-complete-btn" id="hole-complete-btn">Next Hole</button>
      </div>
    </div>
  </div>

  <!-- Tutorial Overlay -->
  <div id="tutorial-overlay" class="hidden">
    <div class="tutorial-modal">
      <h2 id="tutorial-title">Welcome!</h2>
      <p id="tutorial-text">Tutorial text here</p>
      <div class="tutorial-buttons">
        <button id="tutorial-next-btn" class="menu-button">Next</button>
        <button id="tutorial-skip-btn" class="menu-button cancel-btn">Skip Tutorial</button>
      </div>
      <div id="tutorial-progress">Step 1 of 5</div>
    </div>
  </div>

  <!-- Tutorial Prompt Overlay -->
  <div id="tutorial-prompt-overlay" class="hidden">
    <div class="tutorial-modal">
      <h2>First Time Playing?</h2>
      <p>Would you like a quick tutorial to learn how to play?</p>
      <div class="tutorial-buttons">
        <button id="tutorial-yes-btn" class="menu-button">Yes, Show Me!</button>
        <button id="tutorial-no-btn" class="menu-button cancel-btn">No Thanks</button>
      </div>
    </div>
  </div>

  <div id="menu-overlay">
    <h1>Howlett Golf Chaos</h1>
    <p style="color: white; font-size: 18px; margin: 20px; max-width: 500px; text-align: center;">
      ðŸ–±ï¸ Desktop: Click and drag backward from the ball, then release to swing<br>
      ðŸ“± Touch: Drag backward from the ball, then release
    </p>
    <button class="menu-button" id="new-game-btn">New Game</button>
    <button class="menu-button hidden" id="resume-game-btn">Resume Game</button>
    <button class="menu-button" id="leaderboard-btn">Leaderboard</button>
    <button class="menu-button" id="tutorial-btn" style="background: #9C27B0;">Tutorial</button>

    <div id="daily-challenges-panel">
      <div class="daily-challenges-header">
        <span>ðŸ“… Daily Challenges</span>
        <span id="daily-timer"></span>
      </div>
      <div id="daily-challenges-list"></div>
    </div>

    <button id="music-prompt-btn">ðŸŽµ Tap for Music</button>

    <div class="menu-bottom-buttons">
      <button class="menu-icon-btn" id="mailbox-btn" title="Mailbox">ðŸ“¬<span class="mailbox-badge hidden" id="mailbox-badge">0</span></button>
      <button class="menu-icon-btn" id="shop-btn" title="Shop">ðŸ›’</button>
      <button class="menu-icon-btn" id="achievements-btn" title="Achievements">ðŸ†</button>
      <button class="menu-icon-btn" id="settings-btn" title="Settings">âš™ï¸</button>
    </div>
    <div id="menu-balance"><span id="menu-balance-amount">0</span> Golf Bucks</div>
    <div id="version-footer">v1.0.3 | Built: 2025-12-30</div>
  </div>

  <!-- Tournament Overlay -->
  <div id="tournament-overlay" class="hidden">
    <div id="tournament-modal">
      <h2>Tournaments</h2>
      <div id="tournament-content"></div>
      <button class="tournament-btn secondary" id="tournament-close-btn">Close</button>
    </div>
  </div>

  <!-- Tournament Indicator (shown during tournament play) -->
  <div id="tournament-indicator" class="hidden">
    <span id="tournament-indicator-text"></span>
  </div>

  <!-- Career Mode Entry -->
  <div id="career-entry-overlay" class="hidden">
    <div class="career-entry-modal">
      <div class="career-entry-header">
        <span class="header-icon">ðŸŒï¸</span>
        <h2>Career Mode</h2>
      </div>
      <div class="career-entry-content">
        <p class="career-intro">Rise from local courses to legendary status. Create your golfer and compete across 4 tour tiers!</p>
        <div class="career-slots" id="career-slots">
          <!-- Career save slots will be populated here -->
        </div>
      </div>
      <div class="career-entry-buttons">
        <button class="career-btn primary" id="new-career-btn">New Career</button>
        <button class="career-btn secondary" id="career-back-btn">Back</button>
      </div>
    </div>
  </div>

  <!-- Character Creator -->
  <div id="character-creator-overlay" class="hidden">
    <div class="character-creator-modal">
      <div class="creator-header">
        <h2>Create Your <span>Golfer</span></h2>
        <div class="creator-subtitle">Customize your champion</div>
      </div>
      <div class="creator-main">
        <div class="creator-stage">
          <div class="creator-preview">
            <canvas id="character-preview-canvas" width="200" height="280"></canvas>
            <div class="stage-platform"></div>
          </div>
          <div class="creator-name-display">
            <input type="text" id="career-name-input" placeholder="Your Name" maxlength="12">
          </div>
        </div>
        <div class="creator-options">
          <div class="creator-section">
            <label>Gender</label>
            <div class="gender-toggle" id="gender-options">
              <button class="gender-btn selected" data-value="boy">
                <span class="gender-icon">M</span>
                <span>Boy</span>
              </button>
              <button class="gender-btn" data-value="girl">
                <span class="gender-icon">F</span>
                <span>Girl</span>
              </button>
            </div>
          </div>
          <div class="creator-section">
            <label>Hairstyle</label>
            <div class="style-options" id="hair-style-options"></div>
          </div>
          <div class="creator-section">
            <label>Hair Color</label>
            <div class="color-options" id="hair-color-options"></div>
          </div>
          <div class="creator-section" id="facial-hair-section">
            <label>Facial Hair</label>
            <div class="style-options" id="facial-hair-options"></div>
          </div>
          <div class="creator-section" id="beard-color-section" style="display: none;">
            <label>Beard Color</label>
            <div class="color-options" id="beard-color-options"></div>
          </div>
          <div class="creator-section">
            <label>Skin Tone</label>
            <div class="color-options" id="skin-options"></div>
          </div>
          <div class="creator-section">
            <label>Shirt</label>
            <div class="color-options" id="shirt-options"></div>
          </div>
          <div class="creator-section">
            <label>Pants</label>
            <div class="color-options" id="pants-options"></div>
          </div>
        </div>
      </div>
      <div class="creator-buttons">
        <button class="creator-btn secondary" id="creator-back-btn">Back</button>
        <button class="creator-btn primary" id="create-career-btn">Start Career</button>
      </div>
    </div>
  </div>

  <!-- Career Hub -->
  <div id="career-hub-overlay" class="hidden">
    <div class="career-hub-modal">
      <div class="hub-header">
        <div class="hub-player-info">
          <canvas id="hub-avatar-canvas" width="70" height="70"></canvas>
          <div class="hub-player-details">
            <span class="hub-player-name" id="hub-player-name">Player</span>
            <span class="hub-tour-name" id="hub-tour-name">Local Tour</span>
            <div class="hub-ranking-badge">
              <span class="ranking-icon">ðŸ…</span>
              <span id="hub-tour-ranking">#1</span>
            </div>
          </div>
        </div>
        <div class="hub-currencies">
          <div class="currency-display">
            <span class="currency-icon">ðŸ’µ</span>
            <span id="hub-golf-bucks">$0</span>
          </div>
          <div class="currency-display premium">
            <span class="currency-icon">ðŸª™</span>
            <span id="hub-tour-coins">0</span>
          </div>
        </div>
      </div>

      <div class="hub-news-ticker">
        <div class="news-ticker-content" id="hub-headline-text">ðŸ“° DAILY NEWS: Many new rookies ready to make their debut on the Local Tour this season...</div>
      </div>

      <div class="hub-next-tournament">
        <div class="next-tournament-header">
          <span class="next-label">NEXT EVENT</span>
          <span class="season-week" id="hub-season-week">Season 1, Week 1</span>
        </div>
        <div class="next-tournament-info">
          <span class="tournament-name" id="hub-next-tournament-name">Local Championship</span>
          <div class="tournament-details">
            <span>ðŸ“ 9 Holes</span>
            <span id="hub-next-entry">Entry: Free</span>
            <span id="hub-next-prize">Prize: $25</span>
          </div>
        </div>
      </div>

      <div class="hub-stats-panel">
        <h3>Season Progress</h3>
        <div class="hub-stat">
          <span>Ranking Points</span>
          <span id="hub-ranking-points">0</span>
        </div>
        <div class="hub-stat">
          <span>Tournaments Won</span>
          <span id="hub-wins">0</span>
        </div>
        <div class="hub-stat">
          <span>Total Earnings</span>
          <span id="hub-total-earnings">$0</span>
        </div>
        <div class="hub-stat">
          <span>Fanbase</span>
          <span id="hub-fanbase">0 fans</span>
        </div>
        <div class="hub-progress-bar">
          <div class="progress-fill" id="hub-promotion-progress"></div>
          <span class="progress-label" id="hub-promotion-label">0 / 500 pts to promote</span>
        </div>
      </div>

      <div class="hub-actions">
        <button class="hub-btn primary" id="hub-play-tournament-btn">
          <div class="primary-btn-content">
            <span class="btn-icon">â›³</span>
            <div class="btn-text">
              <span class="btn-main" id="hub-play-btn-text">Play Local Tournament</span>
              <span class="btn-sub">9 holes â€¢ Earn ranking points</span>
            </div>
          </div>
        </button>
        <button class="hub-btn" id="hub-standings-btn">
          <span class="btn-icon">ðŸ“Š</span>
          Standings
        </button>
        <button class="hub-btn" id="hub-sponsors-btn">
          <span class="btn-icon">ðŸ¤</span>
          Sponsors
        </button>
        <button class="hub-btn" id="hub-customize-btn">
          <span class="btn-icon">ðŸ‘•</span>
          Customize
        </button>
        <button class="hub-btn" id="hub-back-btn">
          <span class="btn-icon">ðŸšª</span>
          Exit
        </button>
      </div>
    </div>
  </div>

  <!-- Tour Coins Shop -->
  <div id="tour-coins-shop-overlay" class="hidden">
    <div class="shop-modal">
      <div class="shop-header">
        <h2>ðŸ›ï¸ Pro Shop</h2>
        <div class="shop-balance">
          <span>ðŸª™</span>
          <span id="shop-coin-balance">0</span>
        </div>
      </div>
      <div class="shop-body">
        <!-- Character Preview Panel -->
        <div class="shop-character-panel">
          <canvas class="shop-character-canvas" id="shop-character-canvas" width="160" height="280"></canvas>
          <div class="shop-trying-on" id="shop-trying-on"></div>
          <div class="shop-equipped-list" id="shop-equipped-list">
            <!-- Shows currently equipped items -->
          </div>
        </div>
        <!-- Items Panel -->
        <div class="shop-items-panel">
          <div class="shop-tabs">
            <button class="shop-tab active" data-tab="hats">ðŸ§¢ Hats</button>
            <button class="shop-tab" data-tab="glasses">ðŸ•¶ï¸ Glasses</button>
            <button class="shop-tab" data-tab="outfits">ðŸ‘” Outfits</button>
            <button class="shop-tab" data-tab="sets">âœ¨ Sets</button>
          </div>
          <div class="shop-items" id="shop-items-grid">
            <!-- Items populated by JS -->
          </div>
        </div>
      </div>
      <button class="shop-back-btn" id="shop-back-btn">â† Back to Hub</button>
    </div>
  </div>

  <!-- Sponsors Management -->
  <div id="sponsors-overlay" class="hidden">
    <div class="sponsors-modal">
      <div class="sponsors-header">
        <h2>ðŸ¤ My Sponsors</h2>
        <p>Earn XP by playing tournaments to level up your sponsors</p>
      </div>
      <div id="sponsors-content">
        <!-- Populated by JS -->
      </div>
      <button class="sponsors-back-btn" id="sponsors-back-btn">â† Back to Hub</button>
    </div>
  </div>

  <!-- Career Tournament Selection -->
  <div id="career-tournament-overlay" class="hidden">
    <div class="career-tournament-modal">
      <div class="tournament-header">
        <h2 id="career-tour-title">Local Tour</h2>
        <span class="tournament-week" id="career-week-label">Week 1</span>
      </div>
      <div class="tournament-list" id="career-tournament-list">
        <!-- Tournament options populated here -->
      </div>
      <button class="career-btn secondary" id="career-tournament-back-btn">Back</button>
    </div>
  </div>

  <!-- Debut Cutscene Overlay -->
  <div id="debut-cutscene-overlay" class="hidden">
    <div class="debut-cutscene">
      <div class="debut-scene" id="debut-scene-1">
        <div class="debut-backdrop"></div>
        <div class="debut-content">
          <div class="debut-announcer">ðŸŽ™ï¸</div>
          <div class="debut-text" id="debut-text-1"></div>
        </div>
      </div>
      <div class="debut-scene hidden" id="debut-scene-2">
        <div class="debut-interview">
          <div class="interview-reporter">
            <div class="reporter-icon">ðŸ“º</div>
            <div class="reporter-name">Tour Reporter</div>
          </div>
          <div class="interview-question" id="interview-question"></div>
          <div class="interview-player">
            <canvas id="debut-player-canvas" width="80" height="100"></canvas>
            <div class="player-response" id="player-response"></div>
          </div>
        </div>
      </div>
      <div class="debut-scene hidden" id="debut-scene-3">
        <div class="debut-tee-intro">
          <div class="tee-intro-text">
            <div class="intro-now">NOW ON THE TEE...</div>
            <div class="intro-name" id="debut-player-name"></div>
            <div class="intro-hometown">Making their professional debut</div>
          </div>
          <canvas id="debut-golfer-canvas" width="150" height="200"></canvas>
        </div>
      </div>
      <div class="debut-continue">
        <button class="career-btn primary" id="debut-continue-btn">Continue</button>
      </div>
    </div>
  </div>

  <!-- Pre-Tournament Interview Overlay -->
  <div id="interview-overlay" class="hidden">
    <div class="interview-scene">
      <div class="interview-broadcast-banner">
        <span class="broadcast-live">â— LIVE</span>
        <span class="broadcast-network">GOLF NETWORK</span>
      </div>
      <div class="interview-stage">
        <div class="interview-reporter-side">
          <canvas id="interview-reporter-canvas" width="140" height="220"></canvas>
          <div class="reporter-nameplate">Sarah Collins</div>
        </div>
        <div class="interview-player-side">
          <canvas id="interview-player-canvas" width="140" height="220"></canvas>
          <div class="player-nameplate" id="interview-player-name"></div>
        </div>
      </div>
      <div class="interview-dialogue-box">
        <div class="interview-speaker" id="interview-speaker">Reporter</div>
        <div class="interview-text" id="interview-text"></div>
      </div>
      <div class="interview-controls">
        <button class="career-btn primary" id="interview-continue-btn">Continue</button>
        <button class="career-btn secondary hidden" id="interview-skip-btn">Skip Interview</button>
      </div>
    </div>
  </div>

  <!-- Sponsor Offers Overlay -->
  <div id="sponsor-offer-overlay" class="hidden">
    <div class="sponsor-offer-modal">
      <h2>Sponsor Offer!</h2>
      <p class="sponsor-offer-intro">A sponsor wants to work with you!</p>
      <div class="sponsor-offer-content" id="sponsor-offer-content">
        <!-- Sponsor offers populated here -->
      </div>
      <div class="sponsor-offer-buttons">
        <button class="career-btn secondary" id="sponsor-decline-btn">Decline</button>
      </div>
    </div>
  </div>

  <!-- Career Story/Dialogue Overlay -->
  <div id="career-dialogue-overlay" class="hidden">
    <div class="dialogue-box">
      <div class="dialogue-portrait" id="dialogue-portrait"></div>
      <div class="dialogue-content">
        <span class="dialogue-speaker" id="dialogue-speaker">???</span>
        <p class="dialogue-text" id="dialogue-text">...</p>
      </div>
      <button class="dialogue-continue" id="dialogue-continue-btn">Continue</button>
    </div>
  </div>

  <!-- Career Headlines Ticker -->
  <div id="career-headlines" class="hidden">
    <div class="headline-content" id="headline-text"></div>
  </div>

  <!-- Career Player View Canvas (for cinematic cutaway) -->
  <canvas id="career-player-view" class="hidden"></canvas>

  <script>
    'use strict';

    // T001-T005: Basic setup complete
    // T006-T012: Foundational modules below

    // === Ball Color Definitions ===
    const BallColors = {
      white:  { highlight: '#FFFFFF', base: '#CCCCCC', stroke: '#999999' },
      yellow: { highlight: '#FFEB3B', base: '#FBC02D', stroke: '#F9A825' },
      orange: { highlight: '#FF9800', base: '#F57C00', stroke: '#E65100' },
      pink:   { highlight: '#FF69B4', base: '#DB7093', stroke: '#C71585' },
      red:    { highlight: '#F44336', base: '#C62828', stroke: '#B71C1C' },
      blue:   { highlight: '#2196F3', base: '#1565C0', stroke: '#0D47A1' },
      green:  { highlight: '#4CAF50', base: '#2E7D32', stroke: '#1B5E20' },
      purple: { highlight: '#9C27B0', base: '#6A1B9A', stroke: '#4A148C' }
    };

    // Premium ball colors (purchasable in shop)
    const PremiumBallColors = {
      // Solid premium colors
      gold:     { highlight: '#FFD700', base: '#B8860B', stroke: '#8B6914' },
      chrome:   { highlight: '#E8E8E8', base: '#A8A8A8', stroke: '#787878' },
      neon:     { highlight: '#39FF14', base: '#32CD32', stroke: '#228B22' },
      midnight: { highlight: '#1a1a40', base: '#0d0d20', stroke: '#000010' },
      rose:     { highlight: '#FFB6C1', base: '#FF69B4', stroke: '#DB7093' },
      // Animated/special effects
      galaxy:   { highlight: '#9B59B6', base: '#8E44AD', stroke: '#6C3483', animated: 'galaxy' },
      fire:     { highlight: '#FF4500', base: '#FF6347', stroke: '#DC143C', animated: 'fire' },
      rainbow:  { highlight: '#FF0000', base: '#FF7F00', stroke: '#FFFF00', animated: 'rainbow' }
    };

    // === SeededRandom Class (T006) ===
    class SeededRandom {
      constructor(seed = Date.now()) {
        this.state = seed;
      }

      next() {
        let t = this.state += 0x6D2B79F5;
        t = Math.imul(t ^ t >>> 15, t | 1);
        t ^= t + Math.imul(t ^ t >>> 7, t | 61);
        return ((t ^ t >>> 14) >>> 0) / 4294967296;
      }

      nextInt(min, max) {
        return Math.floor(this.next() * (max - min + 1)) + min;
      }

      nextFloat(min, max) {
        return this.next() * (max - min) + min;
      }
    }

    // === Distance Conversion ===
    // ScreenScale manages consistent yardage across all screen sizes
    // Holes are defined in YARDS and scaled to fit the screen
    const ScreenScale = {
      pixelsPerYard: 1, // Will be calculated based on screen size

      // Initialize scale based on canvas size
      // Longest hole (par 5) is ~480 yards, should use ~85% of screen width
      init(canvasWidth) {
        const longestHoleYards = 480;
        const usableWidth = canvasWidth * 0.85; // Leave margins
        this.pixelsPerYard = usableWidth / longestHoleYards;
      },

      // Convert yards to pixels
      yardsToPixels(yards) {
        return yards * this.pixelsPerYard;
      },

      // Convert pixels to yards
      pixelsToYards(pixels) {
        return pixels / this.pixelsPerYard;
      }
    };

    // Legacy constant for backwards compatibility (will be overwritten by ScreenScale)
    let PIXELS_TO_YARDS = 0.42;

    // === PhysicsEngine Module (T008, T016, T017, T018) ===
    const PhysicsEngine = {
      gravity: 980,
      friction: 0.98,
      roughFrictionMultiplier: 0.80, // 20% more friction in rough
      roughPowerMultiplier: 0.80, // 20% less power when hitting from rough
      airResistance: 0.995,
      baseStopThreshold: 5,
      holeRadius: 15,

      // Stop threshold scaled to screen size (in yards, converted to pixels)
      get stopThreshold() {
        const thresholdYards = 2; // Ball stops when moving less than 2 yards/sec
        return thresholdYards * ScreenScale.pixelsPerYard;
      },

      add(v1, v2) {
        return { x: v1.x + v2.x, y: v1.y + v2.y };
      },

      subtract(v1, v2) {
        return { x: v1.x - v2.x, y: v1.y - v2.y };
      },

      magnitude(v) {
        return Math.sqrt(v.x * v.x + v.y * v.y);
      },

      normalize(v) {
        const mag = this.magnitude(v);
        if (mag === 0) return { x: 0, y: 0 };
        return { x: v.x / mag, y: v.y / mag };
      },

      distance(p1, p2) {
        const dx = p2.x - p1.x;
        const dy = p2.y - p1.y;
        return Math.sqrt(dx * dx + dy * dy);
      },

      // Check if ball is in rough (not on fairway, green, sand, or water)
      isInRough(ball, hole) {
        if (!hole) return false;

        // Check if on green (within 90 pixels of green center)
        const greenDist = this.distance(ball, hole.greenPosition);
        if (greenDist < 90) return false;

        // Check if in sand (handled separately)
        if (ball.inSand) return false;

        // Check if on fairway - point must be within fairwayWidth of the path
        const path = hole.fairwayPath;
        const fairwayWidth = 70; // Half-width of fairway

        for (let i = 0; i < path.length - 1; i++) {
          const p1 = path[i];
          const p2 = path[i + 1];

          // Find closest point on line segment
          const dx = p2.x - p1.x;
          const dy = p2.y - p1.y;
          const len2 = dx * dx + dy * dy;

          let t = Math.max(0, Math.min(1, ((ball.x - p1.x) * dx + (ball.y - p1.y) * dy) / len2));
          const closestX = p1.x + t * dx;
          const closestY = p1.y + t * dy;

          const distToFairway = Math.sqrt((ball.x - closestX) ** 2 + (ball.y - closestY) ** 2);
          if (distToFairway < fairwayWidth) return false; // On fairway
        }

        // Check if on tee box (within 50 pixels of tee)
        const teeDist = this.distance(ball, hole.teePosition);
        if (teeDist < 50) return false;

        // Not on fairway, green, or tee - must be in rough
        return true;
      },

      applySwing(ball, swingVector) {
        // Fixed max distance - clubs always hit the same distance in yards
        // Calculate velocity needed to travel 280 yards after friction
        const targetYards = 280; // Driver at 100% = 280 yards
        const targetPixels = targetYards * ScreenScale.pixelsPerYard;
        // With friction 0.98 at 60fps, velocity needs to be ~1.2x target distance
        // This compensates for the friction decay during ball travel
        const maxVelocity = targetPixels * 1.2;

        ball.velocityX = -Math.cos(swingVector.angle) * swingVector.power * maxVelocity;
        ball.velocityY = -Math.sin(swingVector.angle) * swingVector.power * maxVelocity;
        ball.isAirborne = true;
        ball.isMoving = true;
        ball.spin = swingVector.power * 0.5;
      },

      updateBall(ball, deltaTime, obstacles, hole = null) {
        if (!ball.isMoving) return;

        // Apply wind force only when ball is moving fast enough (not when nearly stopped)
        const currentSpeed = Math.sqrt(ball.velocityX * ball.velocityX + ball.velocityY * ball.velocityY);
        if (currentSpeed > 20 && !ball.windImmune) {
          const wind = WindSystem.getWindForce();
          // Scale wind effect by speed - less effect when slowing down
          const windScale = Math.min(1, currentSpeed / 100);
          ball.velocityX += wind.x * deltaTime * windScale;
          ball.velocityY += wind.y * deltaTime * windScale;
        }

        // Check if ball is in rough
        const inRough = hole && this.isInRough(ball, hole);
        ball.inRough = inRough; // Store for swing penalty

        // Apply friction (frame-rate independent: same slowdown regardless of FPS)
        // Theme physics modifier affects friction - lower frictionMod = more sliding
        const theme = ShopSystem.getSelectedTheme();
        let adjustedFriction = 1 - (1 - this.friction) * theme.physics.frictionMod;

        // Extra friction in rough - ball slows down 20% faster
        if (inRough) {
          adjustedFriction = 1 - (1 - adjustedFriction) / this.roughFrictionMultiplier;
        }

        const frictionFactor = Math.pow(adjustedFriction, deltaTime * 60);
        ball.velocityX *= frictionFactor;
        ball.velocityY *= frictionFactor;

        // Update position
        ball.x += ball.velocityX * deltaTime;
        ball.y += ball.velocityY * deltaTime;

        // Check obstacle collisions
        if (obstacles) {
          this.checkObstacleCollisions(ball, obstacles);
        }

        // Apply magnet power-up effect - attract ball to hole when close and slow
        if (ball.hasMagnet && hole && hole.holePosition) {
          const toHoleX = hole.holePosition.x - ball.x;
          const toHoleY = hole.holePosition.y - ball.y;
          const distToHole = Math.sqrt(toHoleX * toHoleX + toHoleY * toHoleY);
          const magnetRange = 80; // Pixels - range of magnet attraction
          const currentSpd = Math.sqrt(ball.velocityX * ball.velocityX + ball.velocityY * ball.velocityY);

          if (distToHole < magnetRange && currentSpd < 150) {
            // Stronger attraction when closer to hole
            const magnetStrength = 120 * (1 - distToHole / magnetRange);
            const dirX = toHoleX / distToHole;
            const dirY = toHoleY / distToHole;
            ball.velocityX += dirX * magnetStrength * deltaTime;
            ball.velocityY += dirY * magnetStrength * deltaTime;
          }
        }

        // Stop ball if moving too slowly
        const speed = Math.sqrt(ball.velocityX * ball.velocityX + ball.velocityY * ball.velocityY);
        if (speed < this.stopThreshold) {
          ball.velocityX = 0;
          ball.velocityY = 0;
          ball.isMoving = false;
          ball.isAirborne = false;
          ball.leavingSand = false;  // Clear escape flag when ball stops
          // Note: inSand will be set by collision detection if ball lands in sand

          // Power-ups disabled
          ball.windImmune = false;
          ball.hasMagnet = false;
        }

        ball.rotation += speed * deltaTime * 0.1;
        ball.distanceFromHole = this.distance(ball, ball.holePosition);
      },

      checkObstacleCollisions(ball, obstacles) {
        let inSandNow = false;
        for (const obstacle of obstacles) {
          if (this.checkCollision(ball, obstacle)) {
            if (obstacle.type === 'sand') {
              inSandNow = true;
            }
            this.handleObstacleCollision(ball, obstacle);
          }
        }
        // Clear leavingSand flag once ball has left all sand areas
        if (!inSandNow && ball.leavingSand) {
          ball.leavingSand = false;
          ball.inSand = false;
        }
      },

      checkCollision(ball, obstacle) {
        if (obstacle.shape === 'circle') {
          const dist = this.distance(ball, obstacle);
          return dist < (8 + obstacle.radius);
        } else if (obstacle.shape === 'rectangle') {
          return ball.x >= obstacle.x && ball.x <= obstacle.x + obstacle.width &&
                 ball.y >= obstacle.y && ball.y <= obstacle.y + obstacle.height;
        }
        return false;
      },

      handleObstacleCollision(ball, obstacle) {
        // Track if this is a new collision to avoid repeated sounds
        if (!ball.lastCollision || ball.lastCollision !== obstacle) {
          ball.lastCollision = obstacle;
          ball.collisionSoundPlayed = false;
        }

        if (obstacle.type === 'sand') {
          // If ball is being hit out of sand, let it pass through
          if (ball.leavingSand) {
            return;  // Don't stop - ball is escaping
          }

          // Ball entering sand - slow it dramatically and pull toward center
          if (!ball.collisionSoundPlayed) {
            AudioManager.playLandSound('sand');
            AudioManager.playCrowdGasp();  // Crowd reacts to bunker
            Announcer.announceShot('bunker');
            ball.collisionSoundPlayed = true;
          }

          // Calculate direction toward center of bunker
          const dx = obstacle.x - ball.x;
          const dy = obstacle.y - ball.y;
          const dist = Math.sqrt(dx * dx + dy * dy);

          // Slow the ball and redirect toward center (simulating rolling into depression)
          const currentSpeed = Math.sqrt(ball.velocityX * ball.velocityX + ball.velocityY * ball.velocityY);

          // Only stop if very close to center of bunker
          if (dist < 15) {
            // Close to center - stop the ball
            ball.velocityX = 0;
            ball.velocityY = 0;
            ball.isMoving = false;
          } else {
            // Roll toward center with minimum speed to ensure ball reaches center
            const minRollSpeed = 25;
            const rollSpeed = Math.max(Math.min(currentSpeed * 0.4, 60), minRollSpeed);
            ball.velocityX = (dx / dist) * rollSpeed;
            ball.velocityY = (dy / dist) * rollSpeed;
          }

          ball.inSand = true;  // Flag for reduced power on next shot
          // Track for achievements
          AchievementManager.stats.hadSand = true;
        } else if (obstacle.type === 'water') {
          if (!ball.collisionSoundPlayed) {
            AudioManager.playLandSound('water');
            AudioManager.playCrowdGasp();  // Crowd reacts to water hazard
            Announcer.announceShot('water');
            ball.collisionSoundPlayed = true;
          }
          if (ball.lastSafePosition) {
            ball.x = ball.lastSafePosition.x;
            ball.y = ball.lastSafePosition.y;
            ball.velocityX = 0;
            ball.velocityY = 0;
            ball.isMoving = false;
            ball.waterPenalty = true;
            // Track for achievements
            AchievementManager.stats.hadWater = true;
          }
        } else if (obstacle.type === 'tree' || obstacle.type === 'rock') {
          if (!ball.collisionSoundPlayed) {
            AudioManager.playLandSound('grass');
            ball.collisionSoundPlayed = true;
          }
          const dx = ball.x - obstacle.x;
          const dy = ball.y - obstacle.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          const nx = dx / dist;
          const ny = dy / dist;

          ball.x = obstacle.x + nx * (obstacle.radius + 10);
          ball.y = obstacle.y + ny * (obstacle.radius + 10);

          // Apply bounce with theme modifier
          const theme = ShopSystem.getSelectedTheme();
          const bounceCoeff = 0.6 * theme.physics.bounceMod;
          const dotProduct = ball.velocityX * nx + ball.velocityY * ny;
          ball.velocityX = (ball.velocityX - 2 * dotProduct * nx) * bounceCoeff;
          ball.velocityY = (ball.velocityY - 2 * dotProduct * ny) * bounceCoeff;
        } else if (obstacle.type === 'windmill') {
          // Windmill deflects ball based on blade angle
          if (!ball.collisionSoundPlayed) {
            AudioManager.playLandSound('grass');
            ball.collisionSoundPlayed = true;
          }
          // Get current blade angle
          const bladeAngle = obstacle.angle || 0;
          // Deflect ball perpendicular to the blade that hit it
          const deflectAngle = bladeAngle + Math.PI / 2;
          const speed = Math.sqrt(ball.velocityX * ball.velocityX + ball.velocityY * ball.velocityY);
          ball.velocityX = Math.cos(deflectAngle) * speed * 0.8;
          ball.velocityY = Math.sin(deflectAngle) * speed * 0.8;
          // Push ball away from windmill center
          const dx = ball.x - obstacle.x;
          const dy = ball.y - obstacle.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist > 0) {
            ball.x = obstacle.x + (dx / dist) * (obstacle.radius + 15);
            ball.y = obstacle.y + (dy / dist) * (obstacle.radius + 15);
          }
        } else if (obstacle.type === 'movingRock') {
          // Moving rock behaves like regular rock - bounce off
          if (!ball.collisionSoundPlayed) {
            AudioManager.playLandSound('grass');
            ball.collisionSoundPlayed = true;
          }
          const dx = ball.x - obstacle.x;
          const dy = ball.y - obstacle.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          const nx = dx / dist;
          const ny = dy / dist;

          ball.x = obstacle.x + nx * (obstacle.radius + 10);
          ball.y = obstacle.y + ny * (obstacle.radius + 10);

          const theme = ShopSystem.getSelectedTheme();
          const bounceCoeff = 0.7 * theme.physics.bounceMod; // Slightly bouncier
          const dotProduct = ball.velocityX * nx + ball.velocityY * ny;
          ball.velocityX = (ball.velocityX - 2 * dotProduct * nx) * bounceCoeff;
          ball.velocityY = (ball.velocityY - 2 * dotProduct * ny) * bounceCoeff;
        } else if (obstacle.type === 'teleporter') {
          // Teleporter - teleport to paired portal
          if (obstacle.pairedWith && !ball.justTeleported) {
            if (!ball.collisionSoundPlayed) {
              AudioManager.playAchievement(); // Fun teleport sound
              ball.collisionSoundPlayed = true;
            }
            // Find the paired teleporter
            const paired = obstacle.pairedWith;
            // Teleport ball to paired location with same velocity
            ball.x = paired.x;
            ball.y = paired.y;
            ball.justTeleported = true; // Prevent instant re-teleport
            // Reset after a short delay
            setTimeout(() => { ball.justTeleported = false; }, 500);
          }
        }
      },

      isBallInHole(ball) {
        if (ball.distanceFromHole >= this.holeRadius) return false;

        // Ball goes in if it's in the hole radius and moving slowly or stopped
        const speed = Math.sqrt(ball.velocityX * ball.velocityX + ball.velocityY * ball.velocityY);
        const slowEnough = speed < 50; // Ball moving slower than 50 units/second

        return slowEnough;
      }
    };

    // === Renderer Module (T009, T019, T020, T021) ===
    const Renderer = {
      canvas: null,
      ctx: null,
      backgroundCache: null,

      init(canvas) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        this.backgroundCache = document.createElement('canvas');
        this.resizeCanvas();
        window.addEventListener('resize', () => this.resizeCanvas());
      },

      resizeCanvas() {
        const dpr = window.devicePixelRatio || 1;
        const rect = this.canvas.getBoundingClientRect();

        this.canvas.width = rect.width * dpr;
        this.canvas.height = rect.height * dpr;

        this.ctx.scale(dpr, dpr);

        this.canvas.style.width = rect.width + 'px';
        this.canvas.style.height = rect.height + 'px';
      },

      renderFrame(gameState, animationTime = 0) {
        if (!gameState) return;

        this.clearCanvas();

        if (gameState.currentHole && gameState.ball) {
          this.drawCourse(gameState.currentHole, animationTime);
          // Crowd disabled for now - this.drawCrowd(gameState.currentHole);
          if (gameState.currentHole.obstacles) {
            this.drawObstacles(gameState.currentHole.obstacles);
          }

          // Update and draw ball trail (if enabled)
          const trailsEnabled = StorageManager.loadSettings().trailsEnabled !== false;
          if (trailsEnabled) {
            BallTrail.update(gameState.ball);
            BallTrail.draw(this.ctx);
          }

          // Draw ghost ball (replay of best run) before player ball
          if (GhostSystem.isEnabled && GhostSystem.ghostData) {
            GhostSystem.renderGhost(this.ctx, performance.now());
          }

          // Draw golfer next to ball (only in Career Mode)
          // Show during address (ball not moving) or during follow-through animation
          if (typeof CareerSystem !== 'undefined' && CareerSystem.activeCareer) {
            const inFollowThrough = this.followThroughEndTime && performance.now() < this.followThroughEndTime;
            if (!gameState.ball.isMoving) {
              this.drawGolfer(gameState.ball, null, false);
            } else if (inFollowThrough) {
              this.drawGolfer(gameState.ball, null, true); // Show follow-through pose
            }
          }

          this.drawBall(gameState.ball);

          if (gameState.strikeFlash && gameState.strikeFlash.active) {
            this.drawStrikeFlash(gameState.ball, gameState.strikeFlash);
          }

          // Power-ups disabled
          // PowerUpManager.render(this.ctx);

          // Draw confetti particles
          ConfettiSystem.draw(this.ctx);

          // Draw streaker (random event)
          RandomEventManager.draw(this.ctx);
        }

        const swingPreview = InputHandler.getSwingPreview();
        if (swingPreview && gameState.ball && !gameState.ball.isMoving) {
          this.drawGuideArrow(swingPreview, gameState.ball, gameState.selectedClub);
        }
      },

      clearCanvas() {
        const rect = this.canvas.getBoundingClientRect();
        this.ctx.clearRect(0, 0, rect.width, rect.height);
      },

      clearRegion(x, y, width, height) {
        this.ctx.clearRect(x, y, width, height);
      },

      drawCourse(hole, animationTime = 0) {
        const ctx = this.ctx;
        const canvasW = this.canvas.width;
        const canvasH = this.canvas.height;

        // Get current theme colors
        const theme = ShopSystem.getSelectedTheme();

        // Special rendering for putting mini-game - pure green surface
        if (hole.isMinigamePuttingGreen) {
          // Fill entire canvas with green
          const greenGradient = ctx.createRadialGradient(
            canvasW / 2, canvasH / 2, 0,
            canvasW / 2, canvasH / 2, Math.max(canvasW, canvasH)
          );
          greenGradient.addColorStop(0, '#2E7D32');
          greenGradient.addColorStop(0.5, '#388E3C');
          greenGradient.addColorStop(1, '#1B5E20');
          ctx.fillStyle = greenGradient;
          ctx.fillRect(0, 0, canvasW, canvasH);

          // Draw mow lines (alternating stripes like a real putting green)
          const stripeWidth = 30;
          for (let i = 0; i < Math.ceil(canvasW / stripeWidth); i++) {
            if (i % 2 === 0) {
              ctx.fillStyle = 'rgba(255, 255, 255, 0.04)';
            } else {
              ctx.fillStyle = 'rgba(0, 0, 0, 0.03)';
            }
            ctx.fillRect(i * stripeWidth, 0, stripeWidth, canvasH);
          }

          // Draw subtle putting green texture (grain dots)
          ctx.fillStyle = 'rgba(255, 255, 255, 0.02)';
          for (let i = 0; i < 300; i++) {
            const x = (i * 137) % canvasW;
            const y = (i * 173) % canvasH;
            ctx.beginPath();
            ctx.arc(x, y, 1.5, 0, Math.PI * 2);
            ctx.fill();
          }

          // Draw fringe/rough border around edges
          ctx.strokeStyle = '#1B5E20';
          ctx.lineWidth = 8;
          ctx.strokeRect(4, 4, canvasW - 8, canvasH - 8);
          ctx.strokeStyle = '#2E7D32';
          ctx.lineWidth = 3;
          ctx.strokeRect(8, 8, canvasW - 16, canvasH - 16);

          // Draw the hole
          this.drawHole(hole.holePosition, animationTime);

          // Draw obstacles
          if (hole.obstacles) {
            this.drawObstacles(hole.obstacles);
          }

          return; // Skip normal course rendering
        }

        // === ROUGH (themed background) ===
        const roughGradient = ctx.createLinearGradient(0, 0, canvasW, canvasH);
        roughGradient.addColorStop(0, theme.rough.gradient[0]);
        roughGradient.addColorStop(0.4, theme.rough.gradient[1]);
        roughGradient.addColorStop(0.7, theme.rough.gradient[2]);
        roughGradient.addColorStop(1, theme.rough.gradient[3]);
        ctx.fillStyle = roughGradient;
        ctx.fillRect(0, 0, canvasW, canvasH);

        // Long grass blade texture - themed
        ctx.lineWidth = 2;
        for (let i = 0; i < 800; i++) {
          const seed1 = (i * 7919 + 1) % 997;
          const seed2 = (i * 6271 + 3) % 991;
          const seed3 = (i * 3571 + 7) % 983;
          const x = (seed1 / 997) * canvasW;
          const y = (seed2 / 991) * canvasH;
          const len = 8 + (seed3 % 10);
          const lean = ((seed3 % 7) - 3) * 0.8;

          // Themed grass colors
          if (seed3 % 4 === 0) {
            ctx.strokeStyle = theme.rough.grassDark;
          } else if (seed3 % 4 === 1) {
            ctx.strokeStyle = theme.rough.grassMed;
          } else {
            ctx.strokeStyle = theme.rough.grassLight;
          }
          ctx.beginPath();
          ctx.moveTo(x, y);
          ctx.lineTo(x + lean, y - len);
          ctx.stroke();
        }

        // === FAIRWAY with smooth curves and fringe transition ===
        const path = hole.fairwayPath || [hole.teePosition, hole.greenPosition];

        const fairwayWidth = 140;  // WIDER fairway
        const fringeWidth = 25;    // Wider fringe

        // Draw tee-to-fairway connector FIRST (underneath everything)
        // This fills the gap between tee box and fairway start
        const teePos = path[0];
        const nextPos = path[1] || path[0];
        const toGreenDx = nextPos.x - teePos.x;
        const toGreenDy = nextPos.y - teePos.y;
        const toGreenLen = Math.sqrt(toGreenDx * toGreenDx + toGreenDy * toGreenDy) || 1;
        const dirX = toGreenDx / toGreenLen;
        const dirY = toGreenDy / toGreenLen;
        const perpX = -dirY;
        const perpY = dirX;

        // First cut connector from tee to fairway
        ctx.fillStyle = theme.fairway.fringe;
        ctx.beginPath();
        const fringeW = (fairwayWidth + fringeWidth * 2) / 2;
        // Start behind tee box, end past where fairway rounded end will be
        ctx.moveTo(teePos.x - dirX * 60 + perpX * fringeW, teePos.y - dirY * 60 + perpY * fringeW);
        ctx.lineTo(teePos.x + dirX * 20 + perpX * fringeW, teePos.y + dirY * 20 + perpY * fringeW);
        ctx.lineTo(teePos.x + dirX * 20 - perpX * fringeW, teePos.y + dirY * 20 - perpY * fringeW);
        ctx.lineTo(teePos.x - dirX * 60 - perpX * fringeW, teePos.y - dirY * 60 - perpY * fringeW);
        ctx.closePath();
        ctx.fill();

        // Main fairway connector
        ctx.fillStyle = theme.fairway.main;
        ctx.beginPath();
        const fairwayW = fairwayWidth / 2;
        ctx.moveTo(teePos.x - dirX * 55 + perpX * fairwayW, teePos.y - dirY * 55 + perpY * fairwayW);
        ctx.lineTo(teePos.x + dirX * 20 + perpX * fairwayW, teePos.y + dirY * 20 + perpY * fairwayW);
        ctx.lineTo(teePos.x + dirX * 20 - perpX * fairwayW, teePos.y + dirY * 20 - perpY * fairwayW);
        ctx.lineTo(teePos.x - dirX * 55 - perpX * fairwayW, teePos.y - dirY * 55 - perpY * fairwayW);
        ctx.closePath();
        ctx.fill();

        // Helper to get perpendicular at a segment
        const getPerp = (p1, p2) => {
          const dx = p2.x - p1.x;
          const dy = p2.y - p1.y;
          const len = Math.sqrt(dx * dx + dy * dy) || 1;
          return { x: -dy / len, y: dx / len };
        };

        // Build SMOOTH fairway path with bezier curves at corners (original curvy style)
        // NOTE: No rounded end at tee - fairway starts with straight edge at tee position
        const buildSmoothFairwayPath = (width) => {
          ctx.beginPath();
          const w = width / 2;

          if (path.length === 2) {
            // Straight hole - rectangle with rounded end at GREEN only, flat at tee
            const p1 = path[0];
            const p2 = path[1];
            const perp = getPerp(p1, p2);

            // Start at tee right edge, go to green
            ctx.moveTo(p1.x + perp.x * w, p1.y + perp.y * w);
            ctx.lineTo(p2.x + perp.x * w, p2.y + perp.y * w);
            // Rounded end at green
            ctx.arc(p2.x, p2.y, w, Math.atan2(perp.y, perp.x), Math.atan2(-perp.y, -perp.x), false);
            // Back to tee left edge
            ctx.lineTo(p1.x - perp.x * w, p1.y - perp.y * w);
            // Flat end at tee (just close the path)
            ctx.closePath();
          } else {
            // Dogleg - use curves at the bend, flat end at tee
            const p1 = path[0];
            const p2 = path[1];  // Bend point
            const p3 = path[2];

            const perp1 = getPerp(p1, p2);
            const perp2 = getPerp(p2, p3);

            // Right edge: tee to bend to green
            ctx.moveTo(p1.x + perp1.x * w, p1.y + perp1.y * w);
            // Curve through the bend point
            ctx.quadraticCurveTo(
              p2.x + (perp1.x + perp2.x) * w * 0.5,
              p2.y + (perp1.y + perp2.y) * w * 0.5,
              p2.x + perp2.x * w, p2.y + perp2.y * w
            );
            ctx.lineTo(p3.x + perp2.x * w, p3.y + perp2.y * w);

            // Rounded end at green
            ctx.arc(p3.x, p3.y, w, Math.atan2(perp2.y, perp2.x), Math.atan2(-perp2.y, -perp2.x), false);

            // Left edge: green to bend to tee
            ctx.lineTo(p2.x - perp2.x * w, p2.y - perp2.y * w);
            ctx.quadraticCurveTo(
              p2.x - (perp1.x + perp2.x) * w * 0.5,
              p2.y - (perp1.y + perp2.y) * w * 0.5,
              p1.x - perp1.x * w, p1.y - perp1.y * w
            );

            // Flat end at tee (just close the path)
            ctx.closePath();
          }
        };

        // Fringe / first-cut (medium green border)
        ctx.fillStyle = theme.fairway.fringe;
        buildSmoothFairwayPath(fairwayWidth + fringeWidth * 2);
        ctx.fill();

        // Main fairway (bright green)
        ctx.fillStyle = theme.fairway.main;
        buildSmoothFairwayPath(fairwayWidth);
        ctx.fill();

        // VISIBLE mowing stripes along fairway direction
        ctx.save();
        buildSmoothFairwayPath(fairwayWidth);
        ctx.clip();

        // Draw thick alternating stripes
        const stripeWidth = 20;
        for (let seg = 0; seg < path.length - 1; seg++) {
          const p1 = path[seg];
          const p2 = path[seg + 1];
          const dx = p2.x - p1.x;
          const dy = p2.y - p1.y;
          const segLen = Math.sqrt(dx * dx + dy * dy);
          const normX = dx / segLen;
          const normY = dy / segLen;
          const perp = getPerp(p1, p2);

          // Draw alternating stripes
          for (let d = 0; d < segLen; d += stripeWidth * 2) {
            const t = d / segLen;
            const cx = p1.x + dx * t;
            const cy = p1.y + dy * t;

            // Lighter stripe - more visible
            ctx.fillStyle = theme.fairway.stripe;
            ctx.beginPath();
            ctx.moveTo(cx + perp.x * 100, cy + perp.y * 100);
            ctx.lineTo(cx - perp.x * 100, cy - perp.y * 100);
            ctx.lineTo(cx - perp.x * 100 + normX * stripeWidth, cy - perp.y * 100 + normY * stripeWidth);
            ctx.lineTo(cx + perp.x * 100 + normX * stripeWidth, cy + perp.y * 100 + normY * stripeWidth);
            ctx.closePath();
            ctx.fill();
          }
        }
        ctx.restore();

        // Stylized tee box - oval shape with stripes
        ctx.save();
        ctx.translate(hole.teePosition.x, hole.teePosition.y);

        // Tee box shadow
        ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
        ctx.beginPath();
        ctx.ellipse(4, 6, 55, 35, 0, 0, Math.PI * 2);
        ctx.fill();

        // Tee box base
        const teeGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, 50);
        teeGradient.addColorStop(0, theme.tee.gradient[0]);
        teeGradient.addColorStop(1, theme.tee.gradient[1]);
        ctx.fillStyle = teeGradient;
        ctx.beginPath();
        ctx.ellipse(0, 0, 50, 30, 0, 0, Math.PI * 2);
        ctx.fill();

        // Tee box outline
        ctx.strokeStyle = theme.tee.outline;
        ctx.lineWidth = 3;
        ctx.stroke();

        // Tee markers (cartoon style)
        ctx.fillStyle = theme.tee.markers;
        ctx.beginPath();
        ctx.arc(-20, -5, 6, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = theme.tee.markerOutline;
        ctx.lineWidth = 2;
        ctx.stroke();

        ctx.fillStyle = theme.tee.markers;
        ctx.beginPath();
        ctx.arc(20, -5, 6, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();

        ctx.restore();

        // Approach collar - connects fairway/fringe to green seamlessly
        // Draw before green so green overlaps it
        const lastPathPoint = path[path.length - 1];
        const prevPoint = path.length > 1 ? path[path.length - 2] : path[0];
        const approachAngle = Math.atan2(lastPathPoint.y - prevPoint.y, lastPathPoint.x - prevPoint.x);

        // First cut collar extending from fairway to green
        ctx.save();
        ctx.translate(hole.greenPosition.x, hole.greenPosition.y);
        ctx.fillStyle = theme.fairway.fringe;
        ctx.beginPath();
        // Draw an extended ellipse in the direction the fairway comes from
        const collarExtend = 40;
        ctx.ellipse(
          Math.cos(approachAngle + Math.PI) * collarExtend * 0.5,
          Math.sin(approachAngle + Math.PI) * collarExtend * 0.5,
          110 + collarExtend * 0.3, 95 + collarExtend * 0.2,
          0, 0, Math.PI * 2
        );
        ctx.fill();
        ctx.restore();

        // Stylized putting green with contours
        ctx.save();
        ctx.translate(hole.greenPosition.x, hole.greenPosition.y);

        // Green shadow
        ctx.fillStyle = 'rgba(0, 0, 0, 0.15)';
        ctx.beginPath();
        ctx.ellipse(5, 8, 95, 75, 0, 0, Math.PI * 2);
        ctx.fill();

        // Outer fringe - larger to overlap with collar
        ctx.fillStyle = theme.fairway.fringe;
        ctx.beginPath();
        ctx.ellipse(0, 0, 105, 90, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = theme.tee.outline;
        ctx.lineWidth = 3;
        ctx.stroke();

        // Main green with gradient
        const greenGradient = ctx.createRadialGradient(-20, -20, 0, 0, 0, 80);
        greenGradient.addColorStop(0, theme.green.light);
        greenGradient.addColorStop(0.7, theme.green.main);
        greenGradient.addColorStop(1, theme.tee.gradient[1]);
        ctx.fillStyle = greenGradient;
        ctx.beginPath();
        ctx.ellipse(0, 0, 85, 70, 0, 0, Math.PI * 2);
        ctx.fill();

        // Putting surface (smoothest part)
        const puttingGradient = ctx.createRadialGradient(-10, -10, 0, 0, 0, 50);
        puttingGradient.addColorStop(0, theme.green.light);
        puttingGradient.addColorStop(1, theme.green.main);
        ctx.fillStyle = puttingGradient;
        ctx.beginPath();
        ctx.ellipse(0, 0, 55, 45, 0, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();

        // Stylized hole
        const hx = hole.holePosition.x;
        const hy = hole.holePosition.y;

        // Hole shadow/depth
        ctx.fillStyle = '#1a1a1a';
        ctx.beginPath();
        ctx.ellipse(hx, hy + 2, 18, 14, 0, 0, Math.PI * 2);
        ctx.fill();

        // Hole opening with gradient for depth
        const holeGradient = ctx.createRadialGradient(hx, hy, 0, hx, hy, 15);
        holeGradient.addColorStop(0, '#000000');
        holeGradient.addColorStop(0.7, '#1a1a1a');
        holeGradient.addColorStop(1, '#333333');
        ctx.fillStyle = holeGradient;
        ctx.beginPath();
        ctx.ellipse(hx, hy, 15, 12, 0, 0, Math.PI * 2);
        ctx.fill();

        // Hole rim (white cup edge)
        ctx.strokeStyle = '#FFFFFF';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.ellipse(hx, hy, 15, 12, 0, 0, Math.PI * 2);
        ctx.stroke();

        // Stylized flagstick with cartoon 3D effect
        // Flagstick shadow
        ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
        ctx.lineWidth = 6;
        ctx.beginPath();
        ctx.moveTo(hx + 3, hy);
        ctx.lineTo(hx + 3, hy - 70);
        ctx.stroke();

        // Main flagstick
        const poleGradient = ctx.createLinearGradient(hx - 3, 0, hx + 3, 0);
        poleGradient.addColorStop(0, '#FFE4B5');
        poleGradient.addColorStop(0.5, '#FAFAD2');
        poleGradient.addColorStop(1, '#DAA520');
        ctx.strokeStyle = poleGradient;
        ctx.lineWidth = 5;
        ctx.lineCap = 'round';
        ctx.beginPath();
        ctx.moveTo(hx, hy);
        ctx.lineTo(hx, hy - 75);
        ctx.stroke();

        // Stylized flag with animated wave effect - follows wind direction
        ctx.save();
        ctx.translate(hx, hy - 75);

        // Get wind direction and flip flag accordingly
        const windDir = WindSystem.direction || 0;
        const windSpeed = WindSystem.speed || 0;
        const windX = Math.cos(windDir);
        const flipFlag = windX < 0; // Flip if wind blowing left

        // Scale wave amplitude by wind speed (more wind = more wave)
        const baseAmplitude = 2;
        const windAmplitude = Math.min(windSpeed / 5, 3); // Max extra 3px from wind
        const waveAmplitude = baseAmplitude + windAmplitude;

        // Wave animation parameters
        const waveSpeed = 3 + windSpeed * 0.2; // Faster wave with more wind
        const wave1 = Math.sin(animationTime * waveSpeed * Math.PI * 2) * waveAmplitude;
        const wave2 = Math.sin(animationTime * waveSpeed * Math.PI * 2 + 1) * waveAmplitude;
        const wave3 = Math.sin(animationTime * waveSpeed * Math.PI * 2 + 2) * waveAmplitude;

        // Flip flag based on wind direction
        if (flipFlag) {
          ctx.scale(-1, 1);
        }

        // Flag shadow (with wave)
        ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
        ctx.beginPath();
        ctx.moveTo(2, 2);
        ctx.quadraticCurveTo(18, 8 + wave1 * 0.5, 30 + wave2, 4 + wave1);
        ctx.quadraticCurveTo(22, 17 + wave2 * 0.5, 30 + wave3, 27 + wave2);
        ctx.quadraticCurveTo(15, 22 + wave3 * 0.5, 2, 27);
        ctx.closePath();
        ctx.fill();

        // Flag main color with gradient
        const flagGradient = ctx.createLinearGradient(0, 0, 28, 25);
        flagGradient.addColorStop(0, '#FF4757');
        flagGradient.addColorStop(0.5, '#FF6B81');
        flagGradient.addColorStop(1, '#EE3B4D');
        ctx.fillStyle = flagGradient;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.quadraticCurveTo(15, 5 + wave1 * 0.5, 28 + wave2, 2 + wave1);
        ctx.quadraticCurveTo(20, 15 + wave2 * 0.5, 28 + wave3, 25 + wave2);
        ctx.quadraticCurveTo(12, 20 + wave3 * 0.5, 0, 25);
        ctx.closePath();
        ctx.fill();

        // Flag outline
        ctx.strokeStyle = '#CC2936';
        ctx.lineWidth = 2;
        ctx.stroke();

        // Flag highlight (with wave)
        ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
        ctx.beginPath();
        ctx.moveTo(3, 3);
        ctx.quadraticCurveTo(12, 6 + wave1 * 0.3, 20 + wave2 * 0.5, 4 + wave1 * 0.5);
        ctx.quadraticCurveTo(14, 10 + wave2 * 0.3, 8, 12);
        ctx.quadraticCurveTo(5, 8, 3, 3);
        ctx.fill();

        // Ball on top of flagstick
        ctx.beginPath();
        ctx.arc(0, -3, 4, 0, Math.PI * 2);
        ctx.fillStyle = '#FFD700';
        ctx.fill();
        ctx.strokeStyle = '#DAA520';
        ctx.lineWidth = 1;
        ctx.stroke();

        ctx.restore();
      },

      drawHole(holePosition, animationTime) {
        const ctx = this.ctx;
        const hx = holePosition.x;
        const hy = holePosition.y;

        // Hole shadow/depth
        ctx.fillStyle = '#1a1a1a';
        ctx.beginPath();
        ctx.ellipse(hx, hy + 2, 18, 14, 0, 0, Math.PI * 2);
        ctx.fill();

        // Hole opening with gradient for depth
        const holeGradient = ctx.createRadialGradient(hx, hy, 0, hx, hy, 15);
        holeGradient.addColorStop(0, '#000000');
        holeGradient.addColorStop(0.7, '#1a1a1a');
        holeGradient.addColorStop(1, '#333333');
        ctx.fillStyle = holeGradient;
        ctx.beginPath();
        ctx.ellipse(hx, hy, 15, 12, 0, 0, Math.PI * 2);
        ctx.fill();

        // Hole rim (white cup edge)
        ctx.strokeStyle = '#FFFFFF';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.ellipse(hx, hy, 15, 12, 0, 0, Math.PI * 2);
        ctx.stroke();

        // Stylized flagstick with cartoon 3D effect
        // Flagstick shadow
        ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
        ctx.lineWidth = 6;
        ctx.beginPath();
        ctx.moveTo(hx + 3, hy);
        ctx.lineTo(hx + 3, hy - 70);
        ctx.stroke();

        // Main flagstick
        const poleGradient = ctx.createLinearGradient(hx - 3, 0, hx + 3, 0);
        poleGradient.addColorStop(0, '#FFE4B5');
        poleGradient.addColorStop(0.5, '#FAFAD2');
        poleGradient.addColorStop(1, '#DAA520');
        ctx.strokeStyle = poleGradient;
        ctx.lineWidth = 5;
        ctx.lineCap = 'round';
        ctx.beginPath();
        ctx.moveTo(hx, hy);
        ctx.lineTo(hx, hy - 75);
        ctx.stroke();

        // Stylized flag with animated wave effect
        ctx.save();
        ctx.translate(hx, hy - 75);

        // Get wind direction and flip flag accordingly
        const windDir = WindSystem.direction || 0;
        const windSpeed = WindSystem.speed || 0;
        const windX = Math.cos(windDir);
        const flipFlag = windX < 0;

        // Wave animation
        const baseAmplitude = 2;
        const windAmplitude = Math.min(windSpeed / 5, 3);
        const waveAmplitude = baseAmplitude + windAmplitude;
        const waveSpeed = 3 + windSpeed * 0.2;
        const wave1 = Math.sin(animationTime * waveSpeed * Math.PI * 2) * waveAmplitude;
        const wave2 = Math.sin(animationTime * waveSpeed * Math.PI * 2 + 1) * waveAmplitude;
        const wave3 = Math.sin(animationTime * waveSpeed * Math.PI * 2 + 2) * waveAmplitude;

        if (flipFlag) {
          ctx.scale(-1, 1);
        }

        // Flag shadow
        ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
        ctx.beginPath();
        ctx.moveTo(2, 2);
        ctx.quadraticCurveTo(18, 8 + wave1 * 0.5, 30 + wave2, 4 + wave1);
        ctx.quadraticCurveTo(22, 17 + wave2 * 0.5, 30 + wave3, 27 + wave2);
        ctx.quadraticCurveTo(15, 22 + wave3 * 0.5, 2, 27);
        ctx.closePath();
        ctx.fill();

        // Flag main color with gradient
        const flagGradient = ctx.createLinearGradient(0, 0, 28, 25);
        flagGradient.addColorStop(0, '#FF4757');
        flagGradient.addColorStop(0.5, '#FF6B81');
        flagGradient.addColorStop(1, '#EE3B4D');
        ctx.fillStyle = flagGradient;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.quadraticCurveTo(15, 5 + wave1 * 0.5, 28 + wave2, 2 + wave1);
        ctx.quadraticCurveTo(20, 15 + wave2 * 0.5, 28 + wave3, 25 + wave2);
        ctx.quadraticCurveTo(12, 20 + wave3 * 0.5, 0, 25);
        ctx.closePath();
        ctx.fill();

        // Flag outline
        ctx.strokeStyle = '#CC2936';
        ctx.lineWidth = 2;
        ctx.stroke();

        // Flag highlight
        ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
        ctx.beginPath();
        ctx.moveTo(3, 3);
        ctx.quadraticCurveTo(12, 6 + wave1 * 0.3, 20 + wave2 * 0.5, 4 + wave1 * 0.5);
        ctx.quadraticCurveTo(14, 10 + wave2 * 0.3, 8, 12);
        ctx.quadraticCurveTo(5, 8, 3, 3);
        ctx.fill();

        // Ball on top of flagstick
        ctx.beginPath();
        ctx.arc(0, -3, 4, 0, Math.PI * 2);
        ctx.fillStyle = '#FFD700';
        ctx.fill();
        ctx.strokeStyle = '#DAA520';
        ctx.lineWidth = 1;
        ctx.stroke();

        ctx.restore();
      },

      drawCrowd(hole) {
        const ctx = this.ctx;
        const canvasW = this.canvas.width;
        const canvasH = this.canvas.height;

        // Crowd colors (muted, tournament-appropriate)
        const shirtColors = ['#3A5A8B', '#8B4A4A', '#4A7A4A', '#7A6A4A', '#5A4A7A', '#4A6A7A'];
        const skinTones = ['#FFDAB9', '#DEB887', '#CD853F', '#A0522D'];

        // Draw spectators along a horizontal line at screen edge
        const drawEdgeCrowd = (startX, endX, y, rowCount, seedBase, facingUp) => {
          const spacing = 12;
          const count = Math.floor((endX - startX) / spacing);

          for (let row = 0; row < rowCount; row++) {
            const rowY = facingUp ? y - row * 10 : y + row * 10;
            const scale = 0.7 - row * 0.08;

            for (let i = 0; i < count; i++) {
              const seed = (seedBase + row * 100 + i * 13) % 1000;
              const x = startX + i * spacing + (row % 2) * 6;

              if (x > endX - 5) continue;

              // Simple spectator - just head and shoulders
              ctx.fillStyle = shirtColors[seed % shirtColors.length];
              const bodyH = 8 * scale;
              const bodyW = 6 * scale;
              ctx.fillRect(x - bodyW/2, rowY, bodyW, bodyH);

              // Head
              ctx.fillStyle = skinTones[(seed * 3) % skinTones.length];
              ctx.beginPath();
              ctx.arc(x, rowY - 2 * scale, 4 * scale, 0, Math.PI * 2);
              ctx.fill();
            }
          }
        };

        // Draw rope barrier
        const drawRope = (x1, y1, x2, y2) => {
          // Rope posts
          ctx.fillStyle = '#8B4513';
          ctx.fillRect(x1 - 2, y1 - 15, 4, 20);
          ctx.fillRect(x2 - 2, y2 - 15, 4, 20);

          // Rope
          ctx.strokeStyle = '#DAA520';
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.moveTo(x1, y1 - 8);
          // Slight sag in the rope
          const midX = (x1 + x2) / 2;
          const midY = ((y1 + y2) / 2) - 5 + 8;
          ctx.quadraticCurveTo(midX, midY, x2, y2 - 8);
          ctx.stroke();
        };

        // Top edge crowd (behind rope)
        const topY = 25;
        drawRope(20, topY + 20, canvasW - 20, topY + 20);
        drawEdgeCrowd(25, canvasW - 25, topY, 2, 123, false);

        // Bottom edge crowd (behind rope)
        const bottomY = canvasH - 15;
        drawRope(20, bottomY - 15, canvasW - 20, bottomY - 15);
        drawEdgeCrowd(25, canvasW - 25, bottomY, 2, 456, true);
      },

      drawObstacles(obstacles) {
        const ctx = this.ctx;
        const theme = ShopSystem.getSelectedTheme();

        for (const obstacle of obstacles) {
          if (obstacle.type === 'sand') {
            // Stylized sand bunker with organic shape - uses theme colors
            ctx.save();
            ctx.translate(obstacle.x, obstacle.y);

            // Bunker shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
            ctx.beginPath();
            ctx.ellipse(4, 5, obstacle.radius * 1.1, obstacle.radius * 0.85, 0.1, 0, Math.PI * 2);
            ctx.fill();

            // Bunker rim (darker edge)
            ctx.fillStyle = theme.sand.dark;
            ctx.beginPath();
            ctx.ellipse(0, 0, obstacle.radius * 1.05, obstacle.radius * 0.8, 0.1, 0, Math.PI * 2);
            ctx.fill();

            // Main sand with gradient
            const sandGradient = ctx.createRadialGradient(-5, -5, 0, 0, 0, obstacle.radius);
            sandGradient.addColorStop(0, theme.sand.light);
            sandGradient.addColorStop(0.5, theme.sand.main);
            sandGradient.addColorStop(1, theme.sand.dark);
            ctx.fillStyle = sandGradient;
            ctx.beginPath();
            ctx.ellipse(0, 0, obstacle.radius * 0.95, obstacle.radius * 0.7, 0.1, 0, Math.PI * 2);
            ctx.fill();

            // Sand texture - small dots
            ctx.fillStyle = 'rgba(139, 119, 101, 0.4)';
            for (let i = 0; i < 12; i++) {
              const seed = (i * 137 + Math.floor(obstacle.x)) % 100;
              const angle = (seed / 100) * Math.PI * 2;
              const dist = ((i * 73) % 70) / 100 * obstacle.radius * 0.7;
              const dotX = Math.cos(angle) * dist;
              const dotY = Math.sin(angle) * dist * 0.7;
              const dotSize = 2 + (i % 3);
              ctx.beginPath();
              ctx.arc(dotX, dotY, dotSize, 0, Math.PI * 2);
              ctx.fill();
            }

            // Highlight
            ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.beginPath();
            ctx.ellipse(-obstacle.radius * 0.3, -obstacle.radius * 0.2, obstacle.radius * 0.4, obstacle.radius * 0.25, -0.3, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();

          } else if (obstacle.type === 'water') {
            // Stylized water hazard with cartoon look - uses theme colors
            ctx.save();

            const cx = obstacle.x + obstacle.width / 2;
            const cy = obstacle.y + obstacle.height / 2;

            // Water shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
            ctx.beginPath();
            ctx.ellipse(cx + 4, cy + 5, obstacle.width / 2 + 5, obstacle.height / 2 + 3, 0, 0, Math.PI * 2);
            ctx.fill();

            // Water base with gradient - uses theme water colors
            const waterGradient = ctx.createRadialGradient(cx - 10, cy - 10, 0, cx, cy, obstacle.width / 2);
            waterGradient.addColorStop(0, theme.water.light);
            waterGradient.addColorStop(0.6, theme.water.main);
            waterGradient.addColorStop(1, theme.water.dark);
            ctx.fillStyle = waterGradient;
            ctx.beginPath();
            ctx.ellipse(cx, cy, obstacle.width / 2, obstacle.height / 2, 0, 0, Math.PI * 2);
            ctx.fill();

            // Water outline
            ctx.strokeStyle = theme.water.dark;
            ctx.lineWidth = 3;
            ctx.stroke();

            // Cartoon sparkle/reflection
            ctx.fillStyle = theme.water.highlight;
            ctx.beginPath();
            ctx.ellipse(cx - obstacle.width * 0.2, cy - obstacle.height * 0.15, obstacle.width * 0.15, obstacle.height * 0.1, -0.4, 0, Math.PI * 2);
            ctx.fill();

            // Small sparkle
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.beginPath();
            ctx.arc(cx - obstacle.width * 0.25, cy - obstacle.height * 0.2, 3, 0, Math.PI * 2);
            ctx.fill();

            // Ripple lines
            ctx.strokeStyle = theme.water.highlight;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.ellipse(cx + 5, cy + 5, obstacle.width * 0.25, obstacle.height * 0.15, 0, 0, Math.PI * 2);
            ctx.stroke();

            ctx.restore();

          } else if (obstacle.type === 'tree') {
            // Themed tree rendering
            ctx.save();
            ctx.translate(obstacle.x, obstacle.y);

            const r = obstacle.radius;
            const treeStyle = theme.tree || { type: 'oak', trunk: { main: '#8B5A2B', dark: '#5D4037', outline: '#3E2723' }, foliage: { light: '#81C784', mid: '#66BB6A', dark: '#2E7D32', outline: '#1B5E20' } };

            // Shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
            ctx.beginPath();
            ctx.ellipse(10, 20, r * 1.2, r * 0.45, 0.1, 0, Math.PI * 2);
            ctx.fill();

            if (treeStyle.type === 'palm' || treeStyle.type === 'tropicalPalm') {
              // PALM TREE
              // Curved trunk
              ctx.strokeStyle = treeStyle.trunk.outline;
              ctx.lineWidth = 14;
              ctx.beginPath();
              ctx.moveTo(0, 30);
              ctx.quadraticCurveTo(-8, 0, 5, -r * 0.5);
              ctx.stroke();

              ctx.strokeStyle = treeStyle.trunk.main;
              ctx.lineWidth = 10;
              ctx.beginPath();
              ctx.moveTo(0, 30);
              ctx.quadraticCurveTo(-8, 0, 5, -r * 0.5);
              ctx.stroke();

              // Trunk rings
              ctx.strokeStyle = treeStyle.trunk.dark;
              ctx.lineWidth = 2;
              for (let i = 0; i < 5; i++) {
                const t = i / 5;
                const tx = -8 * (1 - t) * (1 - t) + 5 * t;
                const ty = 30 - 30 * t - r * 0.5 * t;
                ctx.beginPath();
                ctx.arc(tx, ty, 5, 0, Math.PI);
                ctx.stroke();
              }

              // Palm fronds
              const frondColors = [treeStyle.foliage.dark, treeStyle.foliage.mid, treeStyle.foliage.light];
              for (let i = 0; i < 7; i++) {
                const angle = (i / 7) * Math.PI * 2 - Math.PI / 2;
                const frondLength = r * 1.2;
                ctx.strokeStyle = frondColors[i % 3];
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.moveTo(5, -r * 0.5);
                const endX = 5 + Math.cos(angle) * frondLength;
                const endY = -r * 0.5 + Math.sin(angle) * frondLength * 0.6;
                const ctrlX = 5 + Math.cos(angle) * frondLength * 0.6;
                const ctrlY = -r * 0.5 + Math.sin(angle) * frondLength * 0.3 - 10;
                ctx.quadraticCurveTo(ctrlX, ctrlY, endX, endY);
                ctx.stroke();

                // Frond leaves
                ctx.fillStyle = frondColors[i % 3];
                for (let j = 0; j < 5; j++) {
                  const lt = (j + 1) / 6;
                  const lx = 5 + (ctrlX - 5) * lt + (endX - ctrlX) * lt * lt;
                  const ly = -r * 0.5 + (ctrlY + r * 0.5) * lt + (endY - ctrlY) * lt * lt;
                  ctx.beginPath();
                  ctx.ellipse(lx, ly, 8, 3, angle, 0, Math.PI * 2);
                  ctx.fill();
                }
              }

              // Coconuts for tropical
              if (treeStyle.type === 'tropicalPalm') {
                ctx.fillStyle = '#8B4513';
                ctx.beginPath();
                ctx.arc(2, -r * 0.45, 5, 0, Math.PI * 2);
                ctx.arc(8, -r * 0.48, 5, 0, Math.PI * 2);
                ctx.arc(5, -r * 0.4, 5, 0, Math.PI * 2);
                ctx.fill();
              }

            } else if (treeStyle.type === 'pine') {
              // PINE TREE
              // Trunk
              ctx.fillStyle = treeStyle.trunk.main;
              ctx.beginPath();
              ctx.moveTo(-5, 30);
              ctx.lineTo(-4, -r * 0.3);
              ctx.lineTo(4, -r * 0.3);
              ctx.lineTo(5, 30);
              ctx.closePath();
              ctx.fill();
              ctx.strokeStyle = treeStyle.trunk.outline;
              ctx.lineWidth = 2;
              ctx.stroke();

              // Pine layers (triangular)
              const layers = 4;
              for (let i = layers - 1; i >= 0; i--) {
                const layerY = -r * 0.2 - i * r * 0.35;
                const layerWidth = r * (0.9 - i * 0.15);
                const layerHeight = r * 0.5;

                ctx.fillStyle = i % 2 === 0 ? treeStyle.foliage.mid : treeStyle.foliage.dark;
                ctx.beginPath();
                ctx.moveTo(0, layerY - layerHeight);
                ctx.lineTo(-layerWidth, layerY);
                ctx.lineTo(layerWidth, layerY);
                ctx.closePath();
                ctx.fill();
                ctx.strokeStyle = treeStyle.foliage.outline;
                ctx.lineWidth = 2;
                ctx.stroke();
              }

              // Snow on pine if enabled
              if (treeStyle.snow) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                for (let i = 0; i < layers; i++) {
                  const layerY = -r * 0.2 - i * r * 0.35;
                  const layerWidth = r * (0.9 - i * 0.15);
                  ctx.beginPath();
                  ctx.moveTo(-layerWidth * 0.7, layerY - r * 0.15);
                  ctx.quadraticCurveTo(0, layerY - r * 0.35, layerWidth * 0.7, layerY - r * 0.15);
                  ctx.quadraticCurveTo(layerWidth * 0.3, layerY - r * 0.2, 0, layerY - r * 0.25);
                  ctx.quadraticCurveTo(-layerWidth * 0.3, layerY - r * 0.2, -layerWidth * 0.7, layerY - r * 0.15);
                  ctx.fill();
                }
              }

            } else {
              // OAK/STANDARD TREE
              // Ground dirt patch
              ctx.fillStyle = 'rgba(101, 67, 33, 0.4)';
              ctx.beginPath();
              ctx.ellipse(0, 28, 18, 8, 0, 0, Math.PI * 2);
              ctx.fill();

              // Trunk
              const trunkGradient = ctx.createLinearGradient(-8, 0, 8, 0);
              trunkGradient.addColorStop(0, treeStyle.trunk.main);
              trunkGradient.addColorStop(0.5, treeStyle.trunk.main);
              trunkGradient.addColorStop(1, treeStyle.trunk.dark);
              ctx.fillStyle = trunkGradient;
              ctx.beginPath();
              ctx.moveTo(-6, 0);
              ctx.lineTo(-10, 28);
              ctx.lineTo(10, 28);
              ctx.lineTo(6, 0);
              ctx.closePath();
              ctx.fill();
              ctx.strokeStyle = treeStyle.trunk.outline;
              ctx.lineWidth = 2;
              ctx.stroke();

              // Foliage layers
              const foliageGradient1 = ctx.createRadialGradient(-5, -r - 5, 0, 0, -r / 2, r * 1.2);
              foliageGradient1.addColorStop(0, treeStyle.foliage.mid);
              foliageGradient1.addColorStop(1, treeStyle.foliage.dark);
              ctx.fillStyle = foliageGradient1;
              ctx.beginPath();
              ctx.arc(-8, -r * 0.6, r * 0.7, 0, Math.PI * 2);
              ctx.arc(10, -r * 0.5, r * 0.65, 0, Math.PI * 2);
              ctx.fill();

              const foliageGradient2 = ctx.createRadialGradient(-3, -r - 3, 0, 0, -r / 2, r);
              foliageGradient2.addColorStop(0, treeStyle.foliage.light);
              foliageGradient2.addColorStop(1, treeStyle.foliage.mid);
              ctx.fillStyle = foliageGradient2;
              ctx.beginPath();
              ctx.arc(0, -r * 0.8, r * 0.85, 0, Math.PI * 2);
              ctx.fill();

              ctx.strokeStyle = treeStyle.foliage.outline;
              ctx.lineWidth = 2;
              ctx.stroke();

              // Highlight
              ctx.fillStyle = 'rgba(255, 255, 255, 0.25)';
              ctx.beginPath();
              ctx.arc(-r * 0.3, -r * 1.1, r * 0.2, 0, Math.PI * 2);
              ctx.fill();
            }

            ctx.restore();

          } else if (obstacle.type === 'rock') {
            // Themed rock rendering
            ctx.save();
            ctx.translate(obstacle.x, obstacle.y);

            const r = obstacle.radius;
            const rockStyle = theme.rock || { type: 'standard', colors: { light: '#A0A0A0', mid: '#787878', dark: '#4A4A4A', outline: '#2A2A2A' }, moss: 'rgba(85, 107, 47, 0.4)' };

            // Shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.25)';
            ctx.beginPath();
            ctx.ellipse(6, r * 0.9, r * 1.1, r * 0.4, 0.1, 0, Math.PI * 2);
            ctx.fill();

            // Ground around base (skip for icy rocks)
            if (rockStyle.type !== 'icy') {
              ctx.fillStyle = 'rgba(101, 67, 33, 0.35)';
              ctx.beginPath();
              ctx.ellipse(0, r * 0.6, r * 0.8, r * 0.3, 0, 0, Math.PI * 2);
              ctx.fill();
            }

            // Main rock gradient
            const rockGradient = ctx.createRadialGradient(-r * 0.3, -r * 0.3, 0, 0, 0, r * 1.2);
            rockGradient.addColorStop(0, rockStyle.colors.light);
            rockGradient.addColorStop(0.5, rockStyle.colors.mid);
            rockGradient.addColorStop(1, rockStyle.colors.dark);
            ctx.fillStyle = rockGradient;

            // Rock shape varies by type
            if (rockStyle.type === 'sandstone') {
              // Rounder, smoother sandstone shape
              ctx.beginPath();
              ctx.moveTo(-r * 0.7, r * 0.3);
              ctx.quadraticCurveTo(-r * 0.9, -r * 0.2, -r * 0.5, -r * 0.6);
              ctx.quadraticCurveTo(0, -r * 0.8, r * 0.5, -r * 0.55);
              ctx.quadraticCurveTo(r * 0.85, -r * 0.2, r * 0.7, r * 0.35);
              ctx.quadraticCurveTo(r * 0.3, r * 0.55, 0, r * 0.5);
              ctx.quadraticCurveTo(-r * 0.4, r * 0.5, -r * 0.7, r * 0.3);
              ctx.closePath();
              ctx.fill();

              // Wind erosion lines
              ctx.strokeStyle = rockStyle.colors.dark;
              ctx.lineWidth = 1;
              for (let i = 0; i < 4; i++) {
                const y = -r * 0.4 + i * r * 0.2;
                ctx.beginPath();
                ctx.moveTo(-r * 0.5, y);
                ctx.quadraticCurveTo(0, y - 5, r * 0.5, y);
                ctx.stroke();
              }

            } else if (rockStyle.type === 'volcanic') {
              // Jagged volcanic rock
              ctx.beginPath();
              ctx.moveTo(-r * 0.8, r * 0.3);
              ctx.lineTo(-r * 0.9, -r * 0.2);
              ctx.lineTo(-r * 0.7, -r * 0.5);
              ctx.lineTo(-r * 0.3, -r * 0.75);
              ctx.lineTo(0, -r * 0.85);
              ctx.lineTo(r * 0.4, -r * 0.7);
              ctx.lineTo(r * 0.7, -r * 0.4);
              ctx.lineTo(r * 0.85, 0);
              ctx.lineTo(r * 0.75, r * 0.35);
              ctx.lineTo(r * 0.3, r * 0.5);
              ctx.lineTo(-r * 0.2, r * 0.45);
              ctx.closePath();
              ctx.fill();

              // Lava cracks with glow effect
              const lavaColor = rockStyle.lava || '#FF5722';
              const glowColor = rockStyle.lavaGlow || 'rgba(255, 87, 34, 0.3)';

              // Glow circles around crack intersections
              ctx.fillStyle = glowColor;
              ctx.beginPath();
              ctx.arc(-r * 0.2, -r * 0.5, r * 0.18, 0, Math.PI * 2);
              ctx.fill();
              ctx.beginPath();
              ctx.arc(0, r * 0.1, r * 0.18, 0, Math.PI * 2);
              ctx.fill();
              ctx.beginPath();
              ctx.arc(r * 0.2, -r * 0.2, r * 0.18, 0, Math.PI * 2);
              ctx.fill();
              ctx.beginPath();
              ctx.arc(-r * 0.4, r * 0.2, r * 0.15, 0, Math.PI * 2);
              ctx.fill();

              // Main lava cracks
              ctx.strokeStyle = lavaColor;
              ctx.lineWidth = 3;
              ctx.lineCap = 'round';
              ctx.beginPath();
              ctx.moveTo(-r * 0.2, -r * 0.5);
              ctx.lineTo(0, r * 0.1);
              ctx.lineTo(r * 0.2, -r * 0.2);
              ctx.stroke();
              ctx.beginPath();
              ctx.moveTo(-r * 0.4, r * 0.2);
              ctx.lineTo(r * 0.3, -r * 0.1);
              ctx.stroke();
              ctx.lineCap = 'butt';

            } else if (rockStyle.type === 'icy') {
              // Crystalline ice rock
              ctx.beginPath();
              ctx.moveTo(-r * 0.6, r * 0.4);
              ctx.lineTo(-r * 0.8, 0);
              ctx.lineTo(-r * 0.5, -r * 0.6);
              ctx.lineTo(0, -r * 0.75);
              ctx.lineTo(r * 0.5, -r * 0.5);
              ctx.lineTo(r * 0.75, -r * 0.1);
              ctx.lineTo(r * 0.6, r * 0.4);
              ctx.lineTo(0, r * 0.5);
              ctx.closePath();
              ctx.fill();

              // Ice shine
              ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
              ctx.beginPath();
              ctx.moveTo(-r * 0.4, -r * 0.3);
              ctx.lineTo(-r * 0.1, -r * 0.55);
              ctx.lineTo(r * 0.2, -r * 0.4);
              ctx.lineTo(r * 0.1, -r * 0.1);
              ctx.closePath();
              ctx.fill();

              // Snow on top
              ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
              ctx.beginPath();
              ctx.ellipse(0, -r * 0.5, r * 0.4, r * 0.15, 0, 0, Math.PI * 2);
              ctx.fill();

            } else {
              // Standard irregular rock shape
              ctx.beginPath();
              ctx.moveTo(-r * 0.8, r * 0.4);
              ctx.lineTo(-r * 0.95, -r * 0.1);
              ctx.lineTo(-r * 0.6, -r * 0.65);
              ctx.lineTo(-r * 0.1, -r * 0.8);
              ctx.lineTo(r * 0.5, -r * 0.7);
              ctx.lineTo(r * 0.85, -r * 0.3);
              ctx.lineTo(r * 0.9, r * 0.2);
              ctx.lineTo(r * 0.5, r * 0.55);
              ctx.lineTo(-r * 0.3, r * 0.6);
              ctx.closePath();
              ctx.fill();
            }

            // Rock outline
            ctx.strokeStyle = rockStyle.colors.outline;
            ctx.lineWidth = 2;
            ctx.stroke();

            // Highlight (skip for volcanic)
            if (rockStyle.type !== 'volcanic') {
              ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
              ctx.beginPath();
              ctx.moveTo(-r * 0.5, -r * 0.35);
              ctx.lineTo(-r * 0.25, -r * 0.6);
              ctx.lineTo(r * 0.15, -r * 0.55);
              ctx.lineTo(r * 0.05, -r * 0.2);
              ctx.lineTo(-r * 0.35, -r * 0.1);
              ctx.closePath();
              ctx.fill();
            }

            // Moss/lichen patches
            if (rockStyle.moss) {
              ctx.fillStyle = rockStyle.moss;
              ctx.beginPath();
              ctx.arc(-r * 0.4, r * 0.1, r * 0.15, 0, Math.PI * 2);
              ctx.fill();
              ctx.beginPath();
              ctx.arc(r * 0.3, -r * 0.15, r * 0.12, 0, Math.PI * 2);
              ctx.fill();
            }

            ctx.restore();

          } else if (obstacle.type === 'windmill') {
            // Windmill obstacle with rotating blades
            ctx.save();
            ctx.translate(obstacle.x, obstacle.y);

            const r = obstacle.radius;

            // Shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
            ctx.beginPath();
            ctx.ellipse(5, 8, r * 0.6, r * 0.25, 0, 0, Math.PI * 2);
            ctx.fill();

            // Base/stand
            ctx.fillStyle = '#8B4513';
            ctx.beginPath();
            ctx.moveTo(-8, 0);
            ctx.lineTo(-12, 25);
            ctx.lineTo(12, 25);
            ctx.lineTo(8, 0);
            ctx.closePath();
            ctx.fill();
            ctx.strokeStyle = '#5D3010';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Center hub
            ctx.fillStyle = '#D4A574';
            ctx.beginPath();
            ctx.arc(0, 0, 12, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#8B4513';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Rotating blades
            const bladeAngle = obstacle.angle || 0;
            ctx.save();
            ctx.rotate(bladeAngle);

            // Draw 4 blades
            for (let i = 0; i < 4; i++) {
              ctx.save();
              ctx.rotate((i * Math.PI) / 2);

              // Blade
              ctx.fillStyle = '#E8D4B8';
              ctx.beginPath();
              ctx.moveTo(-4, -8);
              ctx.lineTo(-6, -r);
              ctx.lineTo(0, -r - 5);
              ctx.lineTo(6, -r);
              ctx.lineTo(4, -8);
              ctx.closePath();
              ctx.fill();

              // Blade outline
              ctx.strokeStyle = '#8B4513';
              ctx.lineWidth = 1.5;
              ctx.stroke();

              // Blade detail lines
              ctx.strokeStyle = '#C4A574';
              ctx.lineWidth = 1;
              ctx.beginPath();
              ctx.moveTo(0, -12);
              ctx.lineTo(0, -r);
              ctx.stroke();

              ctx.restore();
            }
            ctx.restore();

            // Center bolt
            ctx.fillStyle = '#4A4A4A';
            ctx.beginPath();
            ctx.arc(0, 0, 5, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();

          } else if (obstacle.type === 'movingRock') {
            // Moving rock - glowing rock that moves
            ctx.save();
            ctx.translate(obstacle.x, obstacle.y);

            const r = obstacle.radius;

            // Glow effect
            ctx.fillStyle = 'rgba(255, 100, 100, 0.3)';
            ctx.beginPath();
            ctx.arc(0, 0, r * 1.4, 0, Math.PI * 2);
            ctx.fill();

            // Shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
            ctx.beginPath();
            ctx.ellipse(4, r * 0.6, r * 0.9, r * 0.35, 0, 0, Math.PI * 2);
            ctx.fill();

            // Rock body with reddish tint
            const rockGrad = ctx.createRadialGradient(-r * 0.2, -r * 0.2, 0, 0, 0, r);
            rockGrad.addColorStop(0, '#B85450');
            rockGrad.addColorStop(0.5, '#8B3A36');
            rockGrad.addColorStop(1, '#5C2622');
            ctx.fillStyle = rockGrad;

            ctx.beginPath();
            ctx.moveTo(-r * 0.7, r * 0.3);
            ctx.lineTo(-r * 0.85, -r * 0.2);
            ctx.lineTo(-r * 0.4, -r * 0.7);
            ctx.lineTo(r * 0.3, -r * 0.75);
            ctx.lineTo(r * 0.8, -r * 0.2);
            ctx.lineTo(r * 0.7, r * 0.4);
            ctx.lineTo(0, r * 0.5);
            ctx.closePath();
            ctx.fill();

            ctx.strokeStyle = '#3D1815';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Motion lines
            const moveDir = obstacle.moveDir || 1;
            ctx.strokeStyle = 'rgba(255, 150, 150, 0.5)';
            ctx.lineWidth = 2;
            for (let i = 0; i < 3; i++) {
              const lineX = -moveDir * (r + 5 + i * 6);
              ctx.beginPath();
              ctx.moveTo(lineX, -r * 0.3 + i * r * 0.3);
              ctx.lineTo(lineX - moveDir * 8, -r * 0.3 + i * r * 0.3);
              ctx.stroke();
            }

            ctx.restore();

          } else if (obstacle.type === 'teleporter') {
            // Teleporter portal
            ctx.save();
            ctx.translate(obstacle.x, obstacle.y);

            const r = obstacle.radius;
            const time = Date.now() / 1000;

            // Outer glow
            const glowSize = r * 1.5 + Math.sin(time * 3) * 5;
            const portalColor = obstacle.portalColor || '#8B5CF6';
            ctx.fillStyle = `${portalColor}33`;
            ctx.beginPath();
            ctx.arc(0, 0, glowSize, 0, Math.PI * 2);
            ctx.fill();

            // Portal ring
            ctx.strokeStyle = portalColor;
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.arc(0, 0, r, 0, Math.PI * 2);
            ctx.stroke();

            // Inner swirl effect
            const innerGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, r);
            innerGrad.addColorStop(0, `${portalColor}CC`);
            innerGrad.addColorStop(0.5, `${portalColor}66`);
            innerGrad.addColorStop(1, `${portalColor}00`);
            ctx.fillStyle = innerGrad;
            ctx.beginPath();
            ctx.arc(0, 0, r - 2, 0, Math.PI * 2);
            ctx.fill();

            // Spinning particles
            ctx.fillStyle = '#FFFFFF';
            for (let i = 0; i < 6; i++) {
              const angle = time * 2 + (i * Math.PI) / 3;
              const dist = r * 0.6;
              const px = Math.cos(angle) * dist;
              const py = Math.sin(angle) * dist;
              ctx.beginPath();
              ctx.arc(px, py, 3, 0, Math.PI * 2);
              ctx.fill();
            }

            // Center dot
            ctx.fillStyle = '#FFFFFF';
            ctx.beginPath();
            ctx.arc(0, 0, 4, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();
          }
        }
      },

      drawBall(ball) {
        const ctx = this.ctx;
        // Check both standard and premium colors
        const colors = BallColors[ball.color] || PremiumBallColors[ball.color] || BallColors.white;
        const isAnimated = PremiumBallColors[ball.color]?.animated;

        // Calculate shadow properties based on airborne state
        const baseHeight = ball.isAirborne ? 1.5 : 0;
        const heightFactor = baseHeight + (ball.isAirborne ? Math.abs(ball.velocityY || 0) / 400 : 0);
        const shadowOffset = 4 + heightFactor * 3;
        const shadowScale = 1 + heightFactor * 0.5;
        const shadowOpacity = Math.max(0.1, 0.35 - heightFactor * 0.1);

        if (ball.inHole && ball.holeProgress !== undefined) {
          const fadeProgress = ball.holeProgress;
          if (fadeProgress >= 1) return;

          // Draw shadow (fading with ball)
          ctx.save();
          ctx.globalAlpha = (1 - fadeProgress) * shadowOpacity;
          ctx.fillStyle = 'rgba(0, 0, 0, 1)';
          ctx.beginPath();
          ctx.ellipse(ball.x + shadowOffset, ball.y + shadowOffset, 8 * shadowScale, 5 * shadowScale, 0, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();

          ctx.save();
          ctx.globalAlpha = 1 - fadeProgress;
          ctx.translate(ball.x, ball.y);
          ctx.rotate(ball.rotation);

          const scale = 1 - (fadeProgress * 0.5);
          ctx.scale(scale, scale);

          let holeGradient;
          if (isAnimated) {
            const time = Date.now() / 1000;
            if (isAnimated === 'galaxy') {
              holeGradient = ctx.createRadialGradient(-2, -2, 0, 0, 0, 8);
              const hue = (time * 30) % 360;
              holeGradient.addColorStop(0, `hsl(${hue}, 70%, 70%)`);
              holeGradient.addColorStop(0.5, `hsl(${(hue + 60) % 360}, 80%, 40%)`);
              holeGradient.addColorStop(1, `hsl(${(hue + 120) % 360}, 90%, 20%)`);
            } else if (isAnimated === 'fire') {
              const flicker = Math.sin(time * 10) * 0.2 + 0.8;
              holeGradient = ctx.createRadialGradient(-2, -2, 0, 0, 0, 8);
              holeGradient.addColorStop(0, `rgba(255, 255, 100, ${flicker})`);
              holeGradient.addColorStop(0.4, '#FF6347');
              holeGradient.addColorStop(1, '#8B0000');
            } else if (isAnimated === 'rainbow') {
              const hue = (time * 50) % 360;
              holeGradient = ctx.createRadialGradient(-2, -2, 0, 0, 0, 8);
              holeGradient.addColorStop(0, `hsl(${hue}, 100%, 80%)`);
              holeGradient.addColorStop(1, `hsl(${(hue + 180) % 360}, 100%, 50%)`);
            }
          } else {
            holeGradient = ctx.createRadialGradient(-2, -2, 0, 0, 0, 8);
            holeGradient.addColorStop(0, colors.highlight);
            holeGradient.addColorStop(1, colors.base);
          }

          ctx.fillStyle = holeGradient;
          ctx.beginPath();
          ctx.arc(0, 0, 8, 0, Math.PI * 2);
          ctx.fill();

          ctx.strokeStyle = colors.stroke;
          ctx.lineWidth = 0.5;
          ctx.stroke();

          ctx.restore();
          return;
        }

        // Draw ball shadow (ellipse offset to bottom-right for 3D effect)
        ctx.save();
        ctx.globalAlpha = shadowOpacity;
        ctx.fillStyle = 'rgba(0, 0, 0, 1)';
        ctx.beginPath();
        ctx.ellipse(ball.x + shadowOffset, ball.y + shadowOffset, 8 * shadowScale, 5 * shadowScale, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();

        // Draw ball
        ctx.save();
        ctx.translate(ball.x, ball.y);
        ctx.rotate(ball.rotation);

        let gradient;
        if (isAnimated) {
          // Animated ball effects
          const time = Date.now() / 1000;
          if (isAnimated === 'galaxy') {
            // Rotating galaxy swirl effect
            gradient = ctx.createRadialGradient(-2, -2, 0, 0, 0, 8);
            const hue = (time * 30) % 360;
            gradient.addColorStop(0, `hsl(${hue}, 70%, 70%)`);
            gradient.addColorStop(0.5, `hsl(${(hue + 60) % 360}, 80%, 40%)`);
            gradient.addColorStop(1, `hsl(${(hue + 120) % 360}, 90%, 20%)`);
          } else if (isAnimated === 'fire') {
            // Flickering fire effect
            const flicker = Math.sin(time * 10) * 0.2 + 0.8;
            gradient = ctx.createRadialGradient(-2, -2, 0, 0, 0, 8);
            gradient.addColorStop(0, `rgba(255, 255, 100, ${flicker})`);
            gradient.addColorStop(0.4, '#FF6347');
            gradient.addColorStop(1, '#8B0000');
          } else if (isAnimated === 'rainbow') {
            // Shifting rainbow
            const hue = (time * 50) % 360;
            gradient = ctx.createRadialGradient(-2, -2, 0, 0, 0, 8);
            gradient.addColorStop(0, `hsl(${hue}, 100%, 80%)`);
            gradient.addColorStop(1, `hsl(${(hue + 180) % 360}, 100%, 50%)`);
          }
        } else {
          // Standard ball gradient
          gradient = ctx.createRadialGradient(-2, -2, 0, 0, 0, 8);
          gradient.addColorStop(0, colors.highlight);
          gradient.addColorStop(1, colors.base);
        }

        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(0, 0, 8, 0, Math.PI * 2);
        ctx.fill();

        ctx.strokeStyle = colors.stroke;
        ctx.lineWidth = 0.5;
        ctx.stroke();

        ctx.restore();
      },

      drawGuideArrow(swingPreview, ball, selectedClub) {
        const ctx = this.ctx;
        const dx = swingPreview.current.x - swingPreview.start.x;
        const dy = swingPreview.current.y - swingPreview.start.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        const swingPower = Math.min(distance / 150, 1.0); // User's swing 0-100%

        const club = ClubSystem.getClub(selectedClub || 'driver');
        const effectivePower = swingPower * club.maxPower; // Actual ball power

        const arrowLength = effectivePower * 150;
        const angle = Math.atan2(dy, dx) + Math.PI;

        const endX = ball.x + Math.cos(angle) * arrowLength;
        const endY = ball.y + Math.sin(angle) * arrowLength;

        // Color based on user's swing power (0-100%), not club-adjusted power
        const arrowColor = swingPower > 0.8 ? [255, 100, 0] :
                          swingPower > 0.5 ? [255, 200, 0] : [100, 200, 255];

        ctx.strokeStyle = `rgba(${arrowColor[0]}, ${arrowColor[1]}, ${arrowColor[2]}, ${0.4 + effectivePower * 0.4})`;
        ctx.lineWidth = 3 + effectivePower * 5;
        ctx.setLineDash([5, 5]);

        ctx.beginPath();
        ctx.moveTo(ball.x, ball.y);
        ctx.lineTo(endX, endY);
        ctx.stroke();

        ctx.setLineDash([]);

        const arrowSize = 12 + effectivePower * 12;
        ctx.fillStyle = `rgba(${arrowColor[0]}, ${arrowColor[1]}, ${arrowColor[2]}, ${0.6 + effectivePower * 0.4})`;
        ctx.beginPath();
        ctx.moveTo(endX, endY);
        ctx.lineTo(
          endX - arrowSize * Math.cos(angle - Math.PI / 6),
          endY - arrowSize * Math.sin(angle - Math.PI / 6)
        );
        ctx.lineTo(
          endX - arrowSize * Math.cos(angle + Math.PI / 6),
          endY - arrowSize * Math.sin(angle + Math.PI / 6)
        );
        ctx.closePath();
        ctx.fill();

        ctx.font = 'bold 16px Arial';
        ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
        ctx.fillText(`Power: ${Math.round(swingPower * 100)}%`, ball.x + 15, ball.y - 15);
        ctx.fillText(`${club.name}`, ball.x + 15, ball.y - 35);

        const powerBarWidth = 100;
        const powerBarHeight = 10;
        const powerBarX = ball.x - powerBarWidth / 2;
        const powerBarY = ball.y - 55;

        ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
        ctx.fillRect(powerBarX, powerBarY, powerBarWidth, powerBarHeight);

        ctx.fillStyle = `rgba(${arrowColor[0]}, ${arrowColor[1]}, ${arrowColor[2]}, 0.8)`;
        ctx.fillRect(powerBarX, powerBarY, powerBarWidth * swingPower, powerBarHeight);

        ctx.strokeStyle = 'rgba(0, 0, 0, 0.6)';
        ctx.lineWidth = 2;
        ctx.strokeRect(powerBarX, powerBarY, powerBarWidth, powerBarHeight);
      },

      drawStrikeFlash(ball, strikeFlash) {
        const ctx = this.ctx;
        const progress = strikeFlash.progress;
        const alpha = 1 - progress;
        const radius = 15 + progress * 20;

        ctx.save();
        ctx.globalAlpha = alpha * 0.6;

        const gradient = ctx.createRadialGradient(ball.x, ball.y, 0, ball.x, ball.y, radius);
        gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
        gradient.addColorStop(0.5, 'rgba(255, 200, 0, 0.8)');
        gradient.addColorStop(1, 'rgba(255, 100, 0, 0)');

        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(ball.x, ball.y, radius, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();
      },

      drawGolfer(ball, swingPreview, followThrough = false) {
        const ctx = this.ctx;

        // Get character from career mode if available, otherwise use defaults
        const career = typeof CareerSystem !== 'undefined' && CareerSystem.activeCareer;
        const char = career?.character || {};

        // Robust color extraction with correct property names from character creator
        // skinHex contains the hex color, skinTone is just the index
        const skinTone = char.skinHex || '#DEB887';
        const hairColor = char.hairColor || '#4A3728';
        // Character uses outfitShirt and outfitPants
        const shirtColor = char.outfitShirt || '#E53935';
        const pantsColor = char.outfitPants || '#1565C0';

        // Position golfer ABOVE the ball so it looks like they're swinging at it
        const golferX = ball.x - 10;     // Slightly left of ball center
        const golferY = ball.y - 50;     // Above the ball
        const scale = 1.0;

        // Check if player is currently swinging (dragging)
        const isSwinging = typeof InputHandler !== 'undefined' && InputHandler.isSwinging;

        // Calculate swing phase based on drag distance
        // 0 = address, 1 = backswing, 2 = follow-through
        let swingPhase = followThrough ? 2 : 0;
        let swingAngle = 0;
        if (isSwinging && InputHandler.touchStartPos && InputHandler.currentTouchPos) {
          const dx = InputHandler.currentTouchPos.x - InputHandler.touchStartPos.x;
          const dy = InputHandler.currentTouchPos.y - InputHandler.touchStartPos.y;
          const dragDist = Math.sqrt(dx * dx + dy * dy);
          swingAngle = Math.min(dragDist / 150, 1) * 0.7;
          swingPhase = 1;
        }

        ctx.save();
        ctx.translate(golferX, golferY);

        // Shadow on ground (positioned at ball level)
        ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
        ctx.beginPath();
        ctx.ellipse(10, 50, 15 * scale, 5 * scale, 0, 0, Math.PI * 2);
        ctx.fill();

        // === DRAW GOLFER FACING THE BALL (top-down golf stance) ===

        // Golf shoes (white golf shoes)
        ctx.fillStyle = '#FFFFFF';
        ctx.beginPath();
        ctx.ellipse(-6 * scale, 32 * scale, 5 * scale, 3 * scale, 0.2, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.ellipse(6 * scale, 32 * scale, 5 * scale, 3 * scale, -0.2, 0, Math.PI * 2);
        ctx.fill();
        // Shoe soles
        ctx.fillStyle = '#555';
        ctx.beginPath();
        ctx.ellipse(-6 * scale, 34 * scale, 4 * scale, 1.5 * scale, 0.2, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.ellipse(6 * scale, 34 * scale, 4 * scale, 1.5 * scale, -0.2, 0, Math.PI * 2);
        ctx.fill();

        // Legs (golf stance - slightly bent)
        ctx.fillStyle = pantsColor;
        ctx.beginPath();
        ctx.ellipse(-5 * scale, 22 * scale, 4 * scale, 10 * scale, 0.1, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.ellipse(5 * scale, 22 * scale, 4 * scale, 10 * scale, -0.1, 0, Math.PI * 2);
        ctx.fill();

        // Body/Torso - rotate during swing
        ctx.save();
        if (swingPhase === 1) {
          ctx.rotate(-swingAngle * 0.25);
        }
        ctx.fillStyle = shirtColor;
        ctx.beginPath();
        ctx.ellipse(0, 5 * scale, 10 * scale, 12 * scale, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();

        // Arms and club
        ctx.fillStyle = skinTone;

        if (swingPhase === 1) {
          // Backswing pose
          ctx.save();
          ctx.rotate(-swingAngle);

          // Arms together raised
          ctx.beginPath();
          ctx.ellipse(-6 * scale, -8 * scale, 3.5 * scale, 7 * scale, 0.6, 0, Math.PI * 2);
          ctx.fill();
          ctx.beginPath();
          ctx.ellipse(0 * scale, -10 * scale, 3.5 * scale, 6 * scale, 0.3, 0, Math.PI * 2);
          ctx.fill();

          // Hands
          ctx.beginPath();
          ctx.arc(-8 * scale, -14 * scale, 3 * scale, 0, Math.PI * 2);
          ctx.fill();

          // Golf club raised
          ctx.strokeStyle = '#888';
          ctx.lineWidth = 2.5;
          ctx.beginPath();
          ctx.moveTo(-8 * scale, -14 * scale);
          ctx.lineTo(-30 * scale, -35 * scale);
          ctx.stroke();
          // Club head
          ctx.fillStyle = '#444';
          ctx.beginPath();
          ctx.ellipse(-33 * scale, -38 * scale, 5 * scale, 2.5 * scale, -0.5, 0, Math.PI * 2);
          ctx.fill();

          ctx.restore();
        } else if (swingPhase === 2) {
          // Follow-through pose - club swung through, arms extended upward
          ctx.save();
          ctx.rotate(0.5); // Slight rotation to show follow-through

          // Arms extended up and through
          ctx.fillStyle = skinTone;
          ctx.beginPath();
          ctx.ellipse(6 * scale, -10 * scale, 3.5 * scale, 7 * scale, -0.5, 0, Math.PI * 2);
          ctx.fill();
          ctx.beginPath();
          ctx.ellipse(2 * scale, -12 * scale, 3.5 * scale, 6 * scale, -0.3, 0, Math.PI * 2);
          ctx.fill();

          // Hands up high
          ctx.beginPath();
          ctx.arc(10 * scale, -16 * scale, 3 * scale, 0, Math.PI * 2);
          ctx.fill();

          // Golf club extended through - wrapping around body
          ctx.strokeStyle = '#888';
          ctx.lineWidth = 2.5;
          ctx.beginPath();
          ctx.moveTo(10 * scale, -16 * scale);
          ctx.quadraticCurveTo(25 * scale, -25 * scale, 20 * scale, -40 * scale);
          ctx.stroke();
          // Club head wrapped around
          ctx.fillStyle = '#444';
          ctx.beginPath();
          ctx.ellipse(18 * scale, -43 * scale, 5 * scale, 2.5 * scale, 0.8, 0, Math.PI * 2);
          ctx.fill();

          ctx.restore();
        } else {
          // Address position - ready to swing, club pointing at ball
          ctx.fillStyle = skinTone;

          // Left arm
          ctx.beginPath();
          ctx.ellipse(-8 * scale, 0 * scale, 3.5 * scale, 7 * scale, 0.4, 0, Math.PI * 2);
          ctx.fill();
          // Right arm
          ctx.beginPath();
          ctx.ellipse(8 * scale, -2 * scale, 3.5 * scale, 7 * scale, -0.3, 0, Math.PI * 2);
          ctx.fill();

          // Hands together
          ctx.beginPath();
          ctx.arc(0 * scale, 8 * scale, 3.5 * scale, 0, Math.PI * 2);
          ctx.fill();

          // Golf club pointing down at ball
          ctx.strokeStyle = '#888';
          ctx.lineWidth = 2.5;
          ctx.beginPath();
          ctx.moveTo(0 * scale, 8 * scale);
          ctx.lineTo(12 * scale, 48 * scale);  // Points toward ball
          ctx.stroke();
          // Club head near ball
          ctx.fillStyle = '#444';
          ctx.beginPath();
          ctx.ellipse(14 * scale, 50 * scale, 5 * scale, 2.5 * scale, 0.5, 0, Math.PI * 2);
          ctx.fill();
        }

        // Head - rotate slightly during swing
        ctx.save();
        if (swingPhase === 1) {
          ctx.rotate(-swingAngle * 0.15);
        }
        ctx.fillStyle = skinTone;
        ctx.beginPath();
        ctx.arc(0, -12 * scale, 10 * scale, 0, Math.PI * 2);
        ctx.fill();

        // Hair
        ctx.fillStyle = hairColor;
        ctx.beginPath();
        ctx.arc(0, -14 * scale, 9 * scale, Math.PI, 0);
        ctx.fill();

        // Eyes - looking down at ball
        ctx.fillStyle = '#333';
        ctx.beginPath();
        ctx.arc(-3 * scale, -10 * scale, 2 * scale, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(4 * scale, -10 * scale, 2 * scale, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();

        // Facial hair (boys only)
        if (char.facialHair && char.gender !== 'girl') {
          let facialHairColor;
          if (char.beardColor) {
            facialHairColor = char.beardColor;
          } else {
            const hc = hairColor.replace('#', '');
            const num = parseInt(hc, 16);
            const r = Math.max(0, (num >> 16) - 10);
            const g = Math.max(0, ((num >> 8) & 0x00FF) - 10);
            const b = Math.max(0, (num & 0x0000FF) - 10);
            facialHairColor = '#' + (r << 16 | g << 8 | b).toString(16).padStart(6, '0');
          }

          ctx.fillStyle = facialHairColor;
          ctx.strokeStyle = facialHairColor;
          const mouthY = -5 * scale;

          if (char.facialHair === 'stubble') {
            ctx.globalAlpha = 0.55;
            const stubblePoints = [
              [-5, 1], [-3, 0], [-1, 1], [1, 0], [3, 1], [5, 0],
              [-4, 3], [-2, 2], [0, 3], [2, 2], [4, 3],
              [-3, 5], [-1, 4], [1, 5], [3, 4]
            ];
            stubblePoints.forEach(([px, py]) => {
              ctx.beginPath();
              ctx.arc(px * scale * 0.8, mouthY + py * scale * 0.8, 0.5 * scale, 0, Math.PI * 2);
              ctx.fill();
            });
            ctx.globalAlpha = 1;
          } else if (char.facialHair === 'beard') {
            ctx.beginPath();
            ctx.moveTo(-6 * scale, mouthY - 1 * scale);
            ctx.quadraticCurveTo(-7 * scale, mouthY + 4 * scale, -5 * scale, mouthY + 7 * scale);
            ctx.quadraticCurveTo(0, mouthY + 10 * scale, 5 * scale, mouthY + 7 * scale);
            ctx.quadraticCurveTo(7 * scale, mouthY + 4 * scale, 6 * scale, mouthY - 1 * scale);
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(-5 * scale, mouthY);
            ctx.quadraticCurveTo(0, mouthY - 2 * scale, 5 * scale, mouthY);
            ctx.quadraticCurveTo(0, mouthY + 1 * scale, -5 * scale, mouthY);
            ctx.fill();
          } else if (char.facialHair === 'goatee') {
            ctx.beginPath();
            ctx.moveTo(-3 * scale, mouthY + 2 * scale);
            ctx.quadraticCurveTo(-3 * scale, mouthY + 5 * scale, 0, mouthY + 8 * scale);
            ctx.quadraticCurveTo(3 * scale, mouthY + 5 * scale, 3 * scale, mouthY + 2 * scale);
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(-3 * scale, mouthY + 1 * scale);
            ctx.quadraticCurveTo(0, mouthY - 1 * scale, 3 * scale, mouthY + 1 * scale);
            ctx.quadraticCurveTo(0, mouthY + 2 * scale, -3 * scale, mouthY + 1 * scale);
            ctx.fill();
          } else if (char.facialHair === 'mustache') {
            ctx.beginPath();
            ctx.moveTo(-5 * scale, mouthY + 1 * scale);
            ctx.quadraticCurveTo(-3 * scale, mouthY - 1 * scale, 0, mouthY);
            ctx.quadraticCurveTo(3 * scale, mouthY - 1 * scale, 5 * scale, mouthY + 1 * scale);
            ctx.quadraticCurveTo(3 * scale, mouthY + 2 * scale, 0, mouthY + 1 * scale);
            ctx.quadraticCurveTo(-3 * scale, mouthY + 2 * scale, -5 * scale, mouthY + 1 * scale);
            ctx.fill();
          } else if (char.facialHair === 'soulpatch') {
            ctx.beginPath();
            ctx.moveTo(-1 * scale, mouthY + 3 * scale);
            ctx.quadraticCurveTo(0, mouthY + 6 * scale, 1 * scale, mouthY + 3 * scale);
            ctx.quadraticCurveTo(0, mouthY + 3.5 * scale, -1 * scale, mouthY + 3 * scale);
            ctx.fill();
          }
        }

        // Hat if equipped
        const equippedHat = char.equippedHat;
        if (equippedHat) {
          ctx.fillStyle = equippedHat.includes('blue') ? '#1976D2' :
                          equippedHat.includes('red') ? '#D32F2F' :
                          equippedHat === 'crown' ? '#FFD700' :
                          equippedHat === 'cowboy' ? '#8B4513' : '#FFFFFF';
          ctx.beginPath();
          ctx.arc(0, -20 * scale, 7 * scale, Math.PI, 0);
          ctx.fill();
          if (equippedHat.includes('cap') || equippedHat === 'visor') {
            ctx.beginPath();
            ctx.ellipse(5 * scale, -14 * scale, 9 * scale, 3 * scale, 0.2, Math.PI, 0);
            ctx.fill();
          }
        }

        // Glasses if equipped
        const equippedGlasses = char.equippedGlasses;
        if (equippedGlasses) {
          ctx.fillStyle = equippedGlasses === 'star_glasses' ? '#FFD700' : '#1a1a1a';
          ctx.beginPath();
          ctx.ellipse(-3 * scale, -10 * scale, 3 * scale, 2 * scale, 0, 0, Math.PI * 2);
          ctx.fill();
          ctx.beginPath();
          ctx.ellipse(4 * scale, -10 * scale, 3 * scale, 2 * scale, 0, 0, Math.PI * 2);
          ctx.fill();
        }

        ctx.restore();
      }
    };

    // === Pro Swing Timing Meter Module ===
    const TimingMeter = {
      overlay: null,
      marker: null,
      isActive: false,
      animationId: null,
      markerPosition: 0,
      markerDirection: 1,
      markerSpeed: 2.5, // Percentage per frame
      pendingSwing: null,
      gameEngine: null,
      onComplete: null,

      init(gameEngine) {
        this.gameEngine = gameEngine;
        this.overlay = document.getElementById('timing-meter-overlay');
        this.marker = this.overlay.querySelector('.timing-meter-marker');

        // Listen for tap/click to confirm timing
        this.overlay.addEventListener('click', (e) => this.onTap(e));
        this.overlay.addEventListener('touchstart', (e) => {
          e.preventDefault();
          this.onTap(e);
        }, { passive: false });
      },

      show(swingVector, onComplete) {
        this.pendingSwing = swingVector;
        this.onComplete = onComplete;
        this.markerPosition = 0;
        this.markerDirection = 1;
        this.isActive = true;
        this.overlay.classList.remove('hidden');
        this.animate();
      },

      hide() {
        this.isActive = false;
        this.overlay.classList.add('hidden');
        if (this.animationId) {
          cancelAnimationFrame(this.animationId);
          this.animationId = null;
        }
      },

      animate() {
        if (!this.isActive) return;

        // Move marker back and forth (0 to 100)
        this.markerPosition += this.markerDirection * this.markerSpeed;

        if (this.markerPosition >= 100) {
          this.markerPosition = 100;
          this.markerDirection = -1;
        } else if (this.markerPosition <= 0) {
          this.markerPosition = 0;
          this.markerDirection = 1;
        }

        // Update marker visual position
        this.marker.style.left = this.markerPosition + '%';

        this.animationId = requestAnimationFrame(() => this.animate());
      },

      onTap(e) {
        if (!this.isActive || !this.pendingSwing) return;

        // Calculate accuracy based on marker position
        // Sweet spot is at 50% (center), perfect = 0 deviation
        const distanceFromCenter = Math.abs(this.markerPosition - 50);
        const accuracy = 1 - (distanceFromCenter / 50); // 1 = perfect, 0 = worst

        // Calculate angle deviation based on accuracy
        // Miss left (< 50) = hook, miss right (> 50) = slice
        const maxDeviation = Math.PI / 6; // 30 degrees max deviation
        let angleDeviation = 0;

        if (accuracy < 1) {
          const deviationAmount = (1 - accuracy) * maxDeviation;
          // Left of center = positive deviation (hook), right = negative (slice)
          angleDeviation = this.markerPosition < 50 ? deviationAmount : -deviationAmount;
        }

        // Also reduce power slightly for bad timing
        const powerMultiplier = 0.7 + (accuracy * 0.3); // 70% to 100% power

        // Modify the swing vector
        const modifiedSwing = {
          power: this.pendingSwing.power * powerMultiplier,
          angle: this.pendingSwing.angle + angleDeviation,
          timingAccuracy: accuracy
        };

        this.hide();

        // Execute the swing with modified values
        if (this.onComplete) {
          this.onComplete(modifiedSwing);
        }
      },

      isProMode() {
        const settings = StorageManager.loadSettings();
        return settings.swingMode === 'pro';
      }
    };

    // === InputHandler Module (T010 + Mouse Support) ===
    const InputHandler = {
      canvas: null,
      gameEngine: null,
      touchStartPos: null,
      currentTouchPos: null,
      isSwinging: false,
      waitingForTiming: false,

      init(canvas, gameEngine) {
        this.canvas = canvas;
        this.gameEngine = gameEngine;

        // Initialize timing meter
        TimingMeter.init(gameEngine);

        canvas.addEventListener('touchstart', (e) => this.onTouchStart(e), { passive: false });
        canvas.addEventListener('touchmove', (e) => this.onTouchMove(e), { passive: false });
        canvas.addEventListener('touchend', (e) => this.onTouchEnd(e), { passive: false });

        canvas.addEventListener('mousedown', (e) => this.onMouseDown(e));
        canvas.addEventListener('mousemove', (e) => this.onMouseMove(e));
        canvas.addEventListener('mouseup', (e) => this.onMouseUp(e));

        const resetBtn = document.getElementById('reset-shot-btn');
        resetBtn.addEventListener('click', () => this.resetShot());
      },

      resetShot() {
        this.touchStartPos = null;
        this.currentTouchPos = null;
        this.isSwinging = false;
        document.getElementById('reset-shot-btn').classList.add('hidden');
      },

      onTouchStart(e) {
        e.preventDefault();
        if (this.gameEngine && this.gameEngine.gameState && this.gameEngine.gameState.ball && this.gameEngine.gameState.ball.isMoving) {
          return;
        }
        // Prevent swinging if minigame round is over (waiting for endGame timeout)
        if (this.gameEngine && this.gameEngine.gameState && this.gameEngine.gameState.isMiniGame && !MiniGameManager.isActive) {
          return;
        }
        const touch = e.touches[0];
        const rect = this.canvas.getBoundingClientRect();
        this.touchStartPos = {
          x: touch.clientX - rect.left,
          y: touch.clientY - rect.top
        };
        this.isSwinging = true;
      },

      onTouchMove(e) {
        e.preventDefault();
        if (!this.isSwinging) return;

        const touch = e.touches[0];
        const rect = this.canvas.getBoundingClientRect();
        this.currentTouchPos = {
          x: touch.clientX - rect.left,
          y: touch.clientY - rect.top
        };

        document.getElementById('reset-shot-btn').classList.remove('hidden');
      },

      onTouchEnd(e) {
        e.preventDefault();
        if (!this.isSwinging) return;

        document.getElementById('reset-shot-btn').classList.add('hidden');

        try {
          const swingVector = this.calculateSwingVector();
          if (swingVector && this.gameEngine) {
            // Check if pro mode - show timing meter instead of immediate swing
            // Skip timing meter for minigames (especially putting) - direct swing
            const isMiniGame = this.gameEngine.gameState.isMiniGame;
            if (TimingMeter.isProMode() && !this.gameEngine.gameState.isTutorial && !isMiniGame) {
              this.waitingForTiming = true;
              TimingMeter.show(swingVector, (modifiedSwing) => {
                this.waitingForTiming = false;
                this.gameEngine.executeSwing(modifiedSwing);
              });
            } else {
              this.gameEngine.executeSwing(swingVector);
            }
          }
        } catch (err) {
          console.error('Swing error:', err);
        }

        // Always cleanup state, even if swing failed
        this.touchStartPos = null;
        this.currentTouchPos = null;
        this.isSwinging = false;
      },

      onMouseDown(e) {
        if (this.gameEngine && this.gameEngine.gameState && this.gameEngine.gameState.ball && this.gameEngine.gameState.ball.isMoving) {
          return;
        }
        // Prevent swinging if minigame round is over (waiting for endGame timeout)
        if (this.gameEngine && this.gameEngine.gameState && this.gameEngine.gameState.isMiniGame && !MiniGameManager.isActive) {
          return;
        }
        const rect = this.canvas.getBoundingClientRect();
        this.touchStartPos = {
          x: e.clientX - rect.left,
          y: e.clientY - rect.top
        };
        this.isSwinging = true;
      },

      onMouseMove(e) {
        if (!this.isSwinging) return;

        const rect = this.canvas.getBoundingClientRect();
        this.currentTouchPos = {
          x: e.clientX - rect.left,
          y: e.clientY - rect.top
        };

        document.getElementById('reset-shot-btn').classList.remove('hidden');
      },

      onMouseUp(e) {
        if (!this.isSwinging) return;

        document.getElementById('reset-shot-btn').classList.add('hidden');

        try {
          const swingVector = this.calculateSwingVector();
          if (swingVector && this.gameEngine) {
            // Check if pro mode - show timing meter instead of immediate swing
            // Skip timing meter for minigames (especially putting) - direct swing
            const isMiniGame = this.gameEngine.gameState.isMiniGame;
            if (TimingMeter.isProMode() && !this.gameEngine.gameState.isTutorial && !isMiniGame) {
              this.waitingForTiming = true;
              TimingMeter.show(swingVector, (modifiedSwing) => {
                this.waitingForTiming = false;
                this.gameEngine.executeSwing(modifiedSwing);
              });
            } else {
              this.gameEngine.executeSwing(swingVector);
            }
          }
        } catch (err) {
          console.error('Swing error:', err);
        }

        // Always cleanup state, even if swing failed
        this.touchStartPos = null;
        this.currentTouchPos = null;
        this.isSwinging = false;
      },

      calculateSwingVector() {
        if (!this.touchStartPos || !this.currentTouchPos) return null;

        const dx = this.currentTouchPos.x - this.touchStartPos.x;
        const dy = this.currentTouchPos.y - this.touchStartPos.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        const angle = Math.atan2(dy, dx);

        return {
          power: Math.min(distance / 150, 1.0),
          angle: angle
        };
      },

      getSwingPreview() {
        return this.currentTouchPos && this.touchStartPos ? {
          start: this.touchStartPos,
          current: this.currentTouchPos
        } : null;
      }
    };

    // === WindSystem Module ===
    const WindSystem = {
      direction: 0,      // Angle in radians (0 = right, PI/2 = down, PI = left, etc)
      speed: 0,          // Wind speed in mph
      gustTimer: 0,      // Timer for wind gusts
      gustIntensity: 0,  // Current gust multiplier

      // Generate new wind for a hole
      generateWind(holeNumber) {
        // Wind gets stronger on later holes
        const baseSpeed = 2 + (holeNumber * 0.8);
        const maxSpeed = Math.min(5 + holeNumber * 1.5, 25);

        this.speed = baseSpeed + Math.random() * (maxSpeed - baseSpeed);
        this.direction = Math.random() * Math.PI * 2;
        this.gustTimer = 0;
        this.gustIntensity = 0;

        this.updateUI();
      },

      // Update wind (called each frame for gusts)
      update(deltaTime) {
        // Random gusts
        this.gustTimer -= deltaTime;
        if (this.gustTimer <= 0) {
          this.gustTimer = 2 + Math.random() * 4; // Gust every 2-6 seconds
          this.gustIntensity = Math.random() * 0.5; // Up to 50% stronger
        }

        // Decay gust
        this.gustIntensity *= 0.95;
      },

      // Get wind force to apply to ball
      getWindForce() {
        const effectiveSpeed = this.speed * (1 + this.gustIntensity);
        // Convert mph to pixels/second force (tuned for gameplay)
        const force = effectiveSpeed * 3;

        return {
          x: Math.cos(this.direction) * force,
          y: Math.sin(this.direction) * force
        };
      },

      // Update the wind indicator UI
      updateUI() {
        const indicator = document.getElementById('wind-indicator');
        if (!indicator) return;

        indicator.classList.remove('hidden');

        // Update arrow rotation (rotate to point in wind direction)
        const arrow = indicator.querySelector('.wind-arrow');
        const degrees = (this.direction * 180 / Math.PI);
        arrow.style.transform = `rotate(${degrees}deg)`;

        // Update speed text
        const speedEl = indicator.querySelector('.wind-speed');
        speedEl.textContent = `${Math.round(this.speed)} mph`;

        // Update color class based on speed
        indicator.classList.remove('wind-calm', 'wind-light', 'wind-moderate', 'wind-strong', 'wind-extreme');
        if (this.speed < 5) {
          indicator.classList.add('wind-calm');
        } else if (this.speed < 10) {
          indicator.classList.add('wind-light');
        } else if (this.speed < 15) {
          indicator.classList.add('wind-moderate');
        } else if (this.speed < 20) {
          indicator.classList.add('wind-strong');
        } else {
          indicator.classList.add('wind-extreme');
        }
      },

      // Hide wind indicator
      hide() {
        const indicator = document.getElementById('wind-indicator');
        if (indicator) indicator.classList.add('hidden');
      }
    };

    // === BallTrail System ===
    const BallTrail = {
      positions: [],
      maxLength: 20,
      lastBallPos: null,

      update(ball) {
        if (!ball || !ball.isMoving) {
          // Clear trail when ball stops
          this.positions = [];
          this.lastBallPos = null;
          return;
        }

        // Only add position if ball moved enough
        const minDist = 8;
        if (this.lastBallPos) {
          const dx = ball.x - this.lastBallPos.x;
          const dy = ball.y - this.lastBallPos.y;
          if (dx * dx + dy * dy < minDist * minDist) {
            return;
          }
        }

        this.positions.push({
          x: ball.x,
          y: ball.y,
          age: 0,
          color: ball.color || 'white'
        });

        // Trim to max length
        if (this.positions.length > this.maxLength) {
          this.positions.shift();
        }

        this.lastBallPos = { x: ball.x, y: ball.y };

        // Age all positions
        for (const pos of this.positions) {
          pos.age++;
        }
      },

      draw(ctx) {
        if (this.positions.length < 2) return;

        ctx.save();

        for (let i = 0; i < this.positions.length; i++) {
          const pos = this.positions[i];
          const progress = i / this.positions.length;

          // Fade out and shrink based on age
          const alpha = progress * 0.6;
          const radius = 4 + progress * 6;

          ctx.globalAlpha = alpha;
          ctx.fillStyle = pos.color === 'white' ? '#ffffff' : pos.color;
          ctx.beginPath();
          ctx.arc(pos.x, pos.y, radius, 0, Math.PI * 2);
          ctx.fill();
        }

        ctx.restore();
      },

      clear() {
        this.positions = [];
        this.lastBallPos = null;
      }
    };

    // === Shop System (Golf Bucks & Club Tiers) ===
    const ShopSystem = {
      golfBucks: 0,
      ownedClubs: {}, // { 'driver': 1, 'wood3': 1, ... } - tier level owned (1-3)

      // Tier multipliers for club power
      tierMultipliers: {
        1: 0.7,   // Basic: 70% distance
        2: 0.85,  // Standard: 85% distance
        3: 1.0    // Pro: 100% distance (current clubs)
      },

      // Club tier stats (Power, Accuracy, Forgiveness)
      tierStats: {
        1: { power: 0.70, accuracy: 0.80, forgiveness: 0.70 },  // Basic: 70% power, 80% accuracy, 70% forgiveness
        2: { power: 0.85, accuracy: 0.90, forgiveness: 0.85 },  // Standard: 85% all-around
        3: { power: 1.00, accuracy: 1.00, forgiveness: 1.00 }   // Pro: Full stats
      },

      // Prices for each club tier upgrade
      clubPrices: {
        driver: { 2: 400, 3: 800 },
        wood3:  { 2: 350, 3: 700 },
        wood5:  { 2: 300, 3: 600 },
        iron4:  { 2: 250, 3: 500 },
        iron5:  { 2: 250, 3: 500 },
        iron6:  { 2: 200, 3: 400 },
        iron7:  { 2: 200, 3: 400 },
        iron8:  { 2: 150, 3: 300 },
        iron9:  { 2: 150, 3: 300 },
        wedge:  { 2: 200, 3: 400 },
        putter: { 2: 300, 3: 600 }
      },

      // Club display names for shop UI
      clubNames: {
        driver: 'Driver',
        wood3: '3 Wood',
        wood5: '5 Wood',
        iron4: '4 Iron',
        iron5: '5 Iron',
        iron6: '6 Iron',
        iron7: '7 Iron',
        iron8: '8 Iron',
        iron9: '9 Iron',
        wedge: 'Wedge',
        putter: 'Putter'
      },

      // Ball skins - free colors are always owned
      ownedBallSkins: ['white', 'yellow', 'orange', 'pink', 'red', 'blue', 'green', 'purple'],

      // Ball skin prices (only premium colors)
      ballSkinPrices: {
        gold: 200,
        chrome: 150,
        neon: 175,
        midnight: 225,
        rose: 175,
        galaxy: 500,
        fire: 500,
        rainbow: 750
      },

      // Ball skin display names
      ballSkinNames: {
        white: 'White', yellow: 'Yellow', orange: 'Orange', pink: 'Pink',
        red: 'Red', blue: 'Blue', green: 'Green', purple: 'Purple',
        gold: 'Gold', chrome: 'Chrome', neon: 'Neon Green', midnight: 'Midnight',
        rose: 'Rose', galaxy: 'Galaxy Swirl', fire: 'Fire Trail', rainbow: 'Rainbow Shift'
      },

      // Club skins - default is always owned
      ownedClubSkins: ['default'],
      selectedClubSkin: 'default',

      // Club skin prices
      clubSkinPrices: {
        carbon: 300,
        camo: 250,
        chrome: 350,
        redsteel: 275,
        ocean: 300,
        fire: 600,
        ice: 600,
        lightning: 750,
        galaxy: 800
      },

      // Club skin display names
      clubSkinNames: {
        default: 'Default',
        carbon: 'Carbon Fiber',
        camo: 'Camo',
        chrome: 'Chrome',
        redsteel: 'Red Steel',
        ocean: 'Ocean Blue',
        fire: 'Inferno',
        ice: 'Frost',
        lightning: 'Lightning',
        galaxy: 'Galaxy'
      },

      // Club skin visual definitions
      clubSkinStyles: {
        default: { type: 'solid', headColor: null, shaftColor: null }, // Uses tier colors
        carbon: { type: 'pattern', pattern: 'carbon', headColor: '#1a1a1a', shaftColor: '#2d2d2d', accent: '#444' },
        camo: { type: 'pattern', pattern: 'camo', headColor: '#4a5d23', shaftColor: '#3d4d1f', accent: '#6b7d3a' },
        chrome: { type: 'solid', headColor: '#c0c0c0', shaftColor: '#a8a8a8', accent: '#e8e8e8', shine: true },
        redsteel: { type: 'solid', headColor: '#8b0000', shaftColor: '#5c0000', accent: '#ff4444' },
        ocean: { type: 'gradient', headColors: ['#006994', '#00ced1'], shaftColor: '#005577', accent: '#40e0d0' },
        fire: { type: 'animated', animation: 'fire', headColors: ['#ff4500', '#ff6600', '#ff8c00'], shaftColor: '#cc3300', accent: '#ffcc00' },
        ice: { type: 'animated', animation: 'ice', headColors: ['#87ceeb', '#b0e0e6', '#e0ffff'], shaftColor: '#5f9ea0', accent: '#ffffff' },
        lightning: { type: 'animated', animation: 'lightning', headColors: ['#ffff00', '#ffd700', '#ffffff'], shaftColor: '#4169e1', accent: '#00ffff' },
        galaxy: { type: 'animated', animation: 'galaxy', headColors: ['#4b0082', '#8a2be2', '#9400d3'], shaftColor: '#2e0854', accent: '#ff69b4' }
      },

      init() {
        this.load();
      },

      load() {
        const data = localStorage.getItem('golf-shop-data');
        if (data) {
          const parsed = JSON.parse(data);
          this.golfBucks = parsed.golfBucks || 0;
          this.ownedClubs = parsed.ownedClubs || {};
          // Load owned ball skins, default to free colors
          if (parsed.ownedBallSkins && parsed.ownedBallSkins.length > 0) {
            this.ownedBallSkins = parsed.ownedBallSkins;
          }
          // Load club skins
          if (parsed.ownedClubSkins && parsed.ownedClubSkins.length > 0) {
            this.ownedClubSkins = parsed.ownedClubSkins;
          }
          if (parsed.selectedClubSkin) {
            this.selectedClubSkin = parsed.selectedClubSkin;
          }
          // Load course themes
          if (parsed.ownedThemes && parsed.ownedThemes.length > 0) {
            this.ownedThemes = parsed.ownedThemes;
          }
          if (parsed.selectedTheme) {
            this.selectedTheme = parsed.selectedTheme;
          }
        }
        // Initialize all clubs to tier 1 if not owned
        const allClubIds = Object.keys(this.clubPrices);
        for (const clubId of allClubIds) {
          if (!this.ownedClubs[clubId]) {
            this.ownedClubs[clubId] = 1;
          }
        }
        this.save();
      },

      save() {
        localStorage.setItem('golf-shop-data', JSON.stringify({
          golfBucks: this.golfBucks,
          ownedClubs: this.ownedClubs,
          ownedBallSkins: this.ownedBallSkins,
          ownedClubSkins: this.ownedClubSkins,
          selectedClubSkin: this.selectedClubSkin,
          ownedThemes: this.ownedThemes,
          selectedTheme: this.selectedTheme
        }));
      },

      getBalance() {
        return this.golfBucks;
      },

      addBucks(amount, reason = '') {
        // Apply 25% bonus for Pro swing mode
        const settings = StorageManager.loadSettings();
        let finalAmount = amount;
        let bonusText = '';
        if (settings.swingMode === 'pro') {
          const bonus = Math.floor(amount * 0.25);
          finalAmount = amount + bonus;
          bonusText = ' (+25% Pro)';
        }
        this.golfBucks += finalAmount;
        this.save();
        this.showEarningsPopup(finalAmount, reason + bonusText);
        this.updateBalanceDisplay();
      },

      spendBucks(amount) {
        if (this.golfBucks >= amount) {
          this.golfBucks -= amount;
          this.save();
          this.updateBalanceDisplay();
          return true;
        }
        return false;
      },

      canAfford(cost) {
        return this.golfBucks >= cost;
      },

      getOwnedTier(clubId) {
        return this.ownedClubs[clubId] || 1;
      },

      getTierMultiplier(clubId) {
        const tier = this.getOwnedTier(clubId);
        return this.tierMultipliers[tier];
      },

      getTierStats(clubId) {
        const tier = this.getOwnedTier(clubId);
        return this.tierStats[tier] || this.tierStats[1];
      },

      getAccuracy(clubId) {
        return this.getTierStats(clubId).accuracy;
      },

      getForgiveness(clubId) {
        return this.getTierStats(clubId).forgiveness;
      },

      getClubPrice(clubId, tier) {
        if (this.clubPrices[clubId] && this.clubPrices[clubId][tier]) {
          return this.clubPrices[clubId][tier];
        }
        return 0;
      },

      getNextTierPrice(clubId) {
        const currentTier = this.getOwnedTier(clubId);
        if (currentTier >= 3) return null; // Already maxed
        return this.getClubPrice(clubId, currentTier + 1);
      },

      purchaseClub(clubId) {
        const currentTier = this.getOwnedTier(clubId);
        if (currentTier >= 3) return false; // Already maxed

        const nextTier = currentTier + 1;
        const price = this.getClubPrice(clubId, nextTier);

        if (this.spendBucks(price)) {
          this.ownedClubs[clubId] = nextTier;
          this.save();
          if (AudioManager.playAchievement) AudioManager.playAchievement();

          // Track purchase achievement
          AchievementManager.onPurchase(price);

          // Show upgrade notification
          const tierName = nextTier === 2 ? 'Standard' : 'Pro';
          this.showUpgradePopup(this.clubNames[clubId], tierName);

          return true;
        }
        return false;
      },

      // Called directly from button onclick
      upgradeClub(clubId) {
        if (this.purchaseClub(clubId)) {
          this.renderShop();
        }
      },

      // Called directly from button onclick
      buyBallSkin(skinId) {
        if (this.purchaseBallSkin(skinId)) {
          this.renderShop();
        }
      },

      showUpgradePopup(clubName, tierName) {
        const popup = document.createElement('div');
        popup.className = 'upgrade-popup';
        popup.innerHTML = `<span>â¬†ï¸</span> ${clubName} upgraded to <strong>${tierName}</strong>!`;
        document.body.appendChild(popup);

        setTimeout(() => popup.classList.add('show'), 10);
        setTimeout(() => {
          popup.classList.remove('show');
          setTimeout(() => popup.remove(), 500);
        }, 2500);

      },

      showEarningsPopup(amount, reason) {
        // Create a brief popup showing earnings
        const popup = document.createElement('div');
        popup.className = 'golf-bucks-popup';
        popup.innerHTML = `+${amount} Golf Bucks${reason ? '<br><small>' + reason + '</small>' : ''}`;
        document.body.appendChild(popup);

        // Animate and remove
        setTimeout(() => popup.classList.add('show'), 10);
        setTimeout(() => {
          popup.classList.remove('show');
          setTimeout(() => popup.remove(), 500);
        }, 2000);

        // Add to mailbox only for large amounts (500+)
        if (typeof MailboxManager !== 'undefined' && amount >= 500) {
          MailboxManager.addNotification('earnings', `+${amount} Golf Bucks`, reason || 'Earned from playing');
        }
      },

      // Ball skin methods
      ownsBallSkin(skinId) {
        return this.ownedBallSkins.includes(skinId);
      },

      getBallSkinPrice(skinId) {
        return this.ballSkinPrices[skinId] || 0;
      },

      purchaseBallSkin(skinId) {
        if (this.ownsBallSkin(skinId)) return false; // Already owned

        const price = this.getBallSkinPrice(skinId);
        if (price === 0) return false; // Invalid skin or free

        if (this.spendBucks(price)) {
          this.ownedBallSkins.push(skinId);
          this.save();
          if (AudioManager.playAchievement) AudioManager.playAchievement();

          // Track purchase achievement
          AchievementManager.onPurchase(price);

          // Show unlock notification
          const skinName = this.ballSkinNames[skinId] || skinId;
          this.showBallSkinUnlockPopup(skinName);
          return true;
        }
        return false;
      },

      showBallSkinUnlockPopup(skinName) {
        const popup = document.createElement('div');
        popup.className = 'upgrade-popup';
        popup.innerHTML = `<span>ðŸŽ±</span> Unlocked <strong>${skinName}</strong> ball!`;
        document.body.appendChild(popup);

        setTimeout(() => popup.classList.add('show'), 10);
        setTimeout(() => {
          popup.classList.remove('show');
          setTimeout(() => popup.remove(), 500);
        }, 2500);

      },

      // Club skin methods
      ownsClubSkin(skinId) {
        return this.ownedClubSkins.includes(skinId);
      },

      getClubSkinPrice(skinId) {
        return this.clubSkinPrices[skinId] || 0;
      },

      purchaseClubSkin(skinId) {
        if (this.ownsClubSkin(skinId)) return false;

        const price = this.getClubSkinPrice(skinId);
        if (price === 0) return false;

        if (this.spendBucks(price)) {
          this.ownedClubSkins.push(skinId);
          this.selectedClubSkin = skinId; // Auto-select on purchase
          this.lastUnlockedClubSkin = skinId; // For animation
          this.save();
          if (AudioManager.playAchievement) AudioManager.playAchievement();

          // Track purchase achievement
          AchievementManager.onPurchase(price);

          const skinName = this.clubSkinNames[skinId] || skinId;
          this.showClubSkinUnlockPopup(skinName);
          return true;
        }
        return false;
      },

      buyClubSkin(skinId) {
        if (this.purchaseClubSkin(skinId)) {
          this.renderShop();
        }
      },

      selectClubSkin(skinId) {
        if (this.ownsClubSkin(skinId)) {
          this.selectedClubSkin = skinId;
          this.save();
          this.renderShop();
          // Update in-game club visuals if playing
          this.updateClubSelectorSkins();
        }
      },

      showClubSkinUnlockPopup(skinName) {
        const popup = document.createElement('div');
        popup.className = 'upgrade-popup';
        popup.innerHTML = `<span>ðŸŒï¸</span> Unlocked <strong>${skinName}</strong> club skin!`;
        document.body.appendChild(popup);

        setTimeout(() => popup.classList.add('show'), 10);
        setTimeout(() => {
          popup.classList.remove('show');
          setTimeout(() => popup.remove(), 500);
        }, 2500);

      },

      getSelectedClubSkinStyle() {
        return this.clubSkinStyles[this.selectedClubSkin] || this.clubSkinStyles.default;
      },

      updateClubSelectorSkins() {
        // This will be called to refresh club visuals when skin changes
        const clubSlots = document.querySelectorAll('.club-slot');
        clubSlots.forEach(slot => {
          this.applyClubSkinToElement(slot);
        });
      },

      applyClubSkinToElement(slotElement) {
        const skinStyle = this.getSelectedClubSkinStyle();
        const clubHead = slotElement.querySelector('.club-head');
        const clubShaft = slotElement.querySelector('.club-shaft');
        if (!clubHead || !clubShaft) return;

        // Remove any existing skin classes
        slotElement.classList.remove('skin-animated', 'skin-fire', 'skin-ice', 'skin-lightning', 'skin-galaxy');

        if (skinStyle.type === 'solid' && skinStyle.headColor === null) {
          // Default skin - clear custom styles, let tier colors show
          clubHead.style.removeProperty('background');
          clubShaft.style.removeProperty('background');
          return;
        }

        // Apply skin colors/effects
        if (skinStyle.type === 'animated') {
          slotElement.classList.add('skin-animated', `skin-${this.selectedClubSkin}`);
        }

        if (skinStyle.headColor) {
          clubHead.style.setProperty('background', `linear-gradient(135deg, ${skinStyle.accent || skinStyle.headColor} 0%, ${skinStyle.headColor} 50%, ${skinStyle.headColor} 100%)`, 'important');
        }
        if (skinStyle.headColors) {
          clubHead.style.setProperty('background', `linear-gradient(135deg, ${skinStyle.headColors.join(', ')})`, 'important');
        }
        if (skinStyle.shaftColor) {
          clubShaft.style.setProperty('background', `linear-gradient(to right, ${skinStyle.shaftColor}, ${skinStyle.accent || skinStyle.shaftColor}, ${skinStyle.shaftColor})`, 'important');
        }
      },

      updateBalanceDisplay() {
        const balanceEl = document.getElementById('shop-balance');
        if (balanceEl) {
          balanceEl.textContent = this.golfBucks;
        }
        const menuBalanceAmountEl = document.getElementById('menu-balance-amount');
        if (menuBalanceAmountEl) {
          menuBalanceAmountEl.textContent = this.golfBucks;
        }
      },

      renderShop() {
        const container = document.getElementById('shop-clubs-grid');
        if (!container) return;

        container.innerHTML = '';
        const clubOrder = ['driver', 'wood3', 'wood5', 'iron4', 'iron5', 'iron6', 'iron7', 'iron8', 'iron9', 'wedge', 'putter'];

        // Base max distances at tier 3 (pro level)
        const baseDistances = {
          driver: 280, wood3: 252, wood5: 238, iron4: 224, iron5: 210,
          iron6: 196, iron7: 182, iron8: 168, iron9: 154, wedge: 140, putter: 84
        };

        for (const clubId of clubOrder) {
          const tier = this.getOwnedTier(clubId);
          const nextPrice = this.getNextTierPrice(clubId);
          const canBuy = nextPrice !== null && this.canAfford(nextPrice);
          const isMaxed = tier >= 3;

          const card = document.createElement('div');
          let tierClass = '';
          if (tier === 2) tierClass = ' tier-2';
          if (isMaxed) tierClass = ' maxed';
          card.className = 'shop-club-card' + tierClass;
          card.dataset.club = clubId;

          // Tier stars
          const stars = 'â˜…'.repeat(tier) + 'â˜†'.repeat(3 - tier);

          // Calculate current max distance based on tier
          const currentDist = Math.round(baseDistances[clubId] * this.tierMultipliers[tier]);

          // Get tier stats
          const stats = this.tierStats[tier];

          // Get short label
          let label = clubId.charAt(0).toUpperCase();
          if (clubId === 'driver') label = 'D';
          else if (clubId === 'wood3') label = '3W';
          else if (clubId === 'wood5') label = '5W';
          else if (clubId === 'wedge') label = 'W';
          else if (clubId === 'putter') label = 'P';
          else if (clubId.startsWith('iron')) label = clubId.replace('iron', '');

          card.innerHTML = `
            <div class="shop-club-icon">${label}</div>
            <div class="shop-club-name">${this.clubNames[clubId]}</div>
            <div class="shop-club-tier">${stars}</div>
            <div class="shop-club-distance">${currentDist} yds</div>
            <div class="shop-club-stats">
              <div class="stat-bar"><span class="stat-label">PWR</span><div class="stat-bar-bg"><div class="stat-fill" style="width: ${stats.power * 100}%"></div></div><span class="stat-value">${Math.round(stats.power * 100)}</span></div>
            </div>
            <div class="shop-club-price">${isMaxed ? 'âœ“ MAX' : nextPrice + ' Golf Bucks'}</div>
            ${isMaxed ? '' : `<button class="shop-buy-btn ${canBuy ? '' : 'disabled'}" data-club="${clubId}" ${canBuy ? '' : 'disabled'}>Upgrade</button>`}
          `;

          container.appendChild(card);
        }

        // Click handlers are set up via event delegation in main init

        // Add animation to just-upgraded club
        if (this.lastUpgradedClub) {
          const upgradedCard = container.querySelector(`[data-club="${this.lastUpgradedClub}"]`);
          if (upgradedCard) {
            upgradedCard.classList.add('just-upgraded');
            setTimeout(() => {
              upgradedCard.classList.remove('just-upgraded');
            }, 600);
          }
          this.lastUpgradedClub = null;
        }

        this.updateBalanceDisplay();
        this.renderBallSkins();
        this.renderClubSkins();
        this.renderThemes();
      },

      renderBallSkins() {
        const container = document.getElementById('shop-balls-grid');
        if (!container) return;

        container.innerHTML = '';

        // All ball skins: free colors first, then premium
        const freeSkins = ['white', 'yellow', 'orange', 'pink', 'red', 'blue', 'green', 'purple'];
        const premiumSkins = Object.keys(this.ballSkinPrices);
        const allSkins = [...freeSkins, ...premiumSkins];

        for (const skinId of allSkins) {
          const isFree = freeSkins.includes(skinId);
          const isOwned = this.ownsBallSkin(skinId);
          const price = isFree ? 0 : this.getBallSkinPrice(skinId);
          const canBuy = !isOwned && this.canAfford(price);
          const isAnimated = PremiumBallColors[skinId]?.animated;

          const card = document.createElement('div');
          let cardClass = 'shop-ball-card';
          if (isOwned) cardClass += ' owned';
          if (isAnimated) cardClass += ' animated';
          card.className = cardClass;
          card.dataset.skin = skinId;

          // Get colors for preview
          const colors = PremiumBallColors[skinId] || BallColors[skinId] || BallColors.white;
          const gradientStyle = `background: radial-gradient(circle at 30% 30%, ${colors.highlight}, ${colors.base})`;

          const name = this.ballSkinNames[skinId] || skinId;

          card.innerHTML = `
            <div class="shop-ball-preview" style="${gradientStyle}">
              ${isAnimated ? '<div class="animated-indicator">âœ¨</div>' : ''}
            </div>
            <div class="shop-ball-name">${name}</div>
            <div class="shop-ball-price">${isOwned ? 'âœ“ OWNED' : (isFree ? 'FREE' : price + ' Golf Bucks')}</div>
            ${!isOwned && !isFree ? `<button class="shop-buy-btn ${canBuy ? '' : 'disabled'}" data-skin="${skinId}" ${canBuy ? '' : 'disabled'} onclick="ShopSystem.buyBallSkin('${skinId}')">Buy</button>` : ''}
          `;

          container.appendChild(card);
        }

        // Click handlers are set up via event delegation in main init

        // Add animation to just-unlocked skin
        if (this.lastUnlockedSkin) {
          const unlockedCard = container.querySelector(`[data-skin="${this.lastUnlockedSkin}"]`);
          if (unlockedCard) {
            unlockedCard.classList.add('just-upgraded');
            setTimeout(() => unlockedCard.classList.remove('just-upgraded'), 600);
          }
          this.lastUnlockedSkin = null;
        }
      },

      renderClubSkins() {
        const container = document.getElementById('shop-club-skins-grid');
        if (!container) return;

        container.innerHTML = '';

        // All club skins
        const allSkins = ['default', ...Object.keys(this.clubSkinPrices)];

        for (const skinId of allSkins) {
          const isDefault = skinId === 'default';
          const isOwned = this.ownsClubSkin(skinId);
          const isSelected = this.selectedClubSkin === skinId;
          const price = isDefault ? 0 : this.getClubSkinPrice(skinId);
          const canBuy = !isOwned && this.canAfford(price);
          const skinStyle = this.clubSkinStyles[skinId];
          const isAnimated = skinStyle?.type === 'animated';

          const card = document.createElement('div');
          let cardClass = 'shop-club-skin-card';
          if (isOwned) cardClass += ' owned';
          if (isSelected) cardClass += ' selected';
          if (isAnimated) cardClass += ' animated';
          card.className = cardClass;
          card.dataset.skin = skinId;

          // Generate preview colors
          let previewColor = '#666';
          if (skinStyle.headColor) {
            previewColor = skinStyle.headColor;
          } else if (skinStyle.headColors) {
            previewColor = `linear-gradient(135deg, ${skinStyle.headColors.join(', ')})`;
          }

          const name = this.clubSkinNames[skinId] || skinId;
          const animatedBadge = isAnimated ? '<span class="skin-animated-badge">âœ¨ Animated</span>' : '';

          card.innerHTML = `
            <div class="shop-club-skin-preview ${isAnimated ? 'anim-' + skinId : ''}" style="background: ${previewColor}">
              <div class="club-skin-shaft-preview" style="background: ${skinStyle.shaftColor || '#888'}"></div>
            </div>
            <div class="shop-club-skin-name">${name}</div>
            ${animatedBadge}
            <div class="shop-club-skin-price">${isSelected ? 'âœ“ EQUIPPED' : (isOwned ? 'OWNED' : (isDefault ? 'FREE' : price + ' Golf Bucks'))}</div>
            ${!isOwned && !isDefault ? `<button class="shop-buy-btn ${canBuy ? '' : 'disabled'}" ${canBuy ? '' : 'disabled'} onclick="ShopSystem.buyClubSkin('${skinId}')">Buy</button>` : ''}
            ${isOwned && !isSelected ? `<button class="shop-equip-btn" onclick="ShopSystem.selectClubSkin('${skinId}')">Equip</button>` : ''}
          `;

          container.appendChild(card);
        }

        // Add animation to just-unlocked skin
        if (this.lastUnlockedClubSkin) {
          const unlockedCard = container.querySelector(`[data-skin="${this.lastUnlockedClubSkin}"]`);
          if (unlockedCard) {
            unlockedCard.classList.add('just-upgraded');
            setTimeout(() => unlockedCard.classList.remove('just-upgraded'), 600);
          }
          this.lastUnlockedClubSkin = null;
        }
      },

      renderThemes() {
        const container = document.getElementById('shop-themes-grid');
        if (!container) return;

        container.innerHTML = '';

        // All themes
        const allThemes = ['classic', 'desert', 'snow', 'tropical'];

        for (const themeId of allThemes) {
          const isClassic = themeId === 'classic';
          const isOwned = this.ownsTheme(themeId);
          const isSelected = this.selectedTheme === themeId;
          const price = isClassic ? 0 : this.themePrices[themeId];
          const canBuy = !isOwned && this.canAfford(price);
          const themeData = CourseThemes.themes[themeId];

          const card = document.createElement('div');
          let cardClass = 'shop-theme-card';
          if (isOwned) cardClass += ' owned';
          if (isSelected) cardClass += ' selected';
          card.className = cardClass;
          card.dataset.theme = themeId;

          const name = this.themeNames[themeId] || themeId;

          // Physics info
          const physics = themeData.physics;
          let physicsDesc = '';
          if (physics.frictionMod < 1.0) {
            physicsDesc = 'Ball slides more';
          } else if (physics.frictionMod > 1.0) {
            physicsDesc = 'More grip';
          }

          card.innerHTML = `
            <div class="shop-theme-preview">
              <div class="theme-preview-rough" style="background: ${themeData.rough.gradient[0]}"></div>
              <div class="theme-preview-fairway" style="background: ${themeData.fairway.main}"></div>
              <div class="theme-preview-green" style="background: ${themeData.green.main}"></div>
            </div>
            <div class="shop-theme-name">${name}</div>
            ${physicsDesc ? `<div class="shop-theme-physics">${physicsDesc}</div>` : ''}
            <div class="shop-theme-price">${isSelected ? 'âœ“ ACTIVE' : (isOwned ? 'OWNED' : (isClassic ? 'FREE' : price + ' Golf Bucks'))}</div>
            ${!isOwned && !isClassic ? `<button class="shop-buy-btn ${canBuy ? '' : 'disabled'}" ${canBuy ? '' : 'disabled'} onclick="ShopSystem.buyTheme('${themeId}')">Buy</button>` : ''}
            ${isOwned && !isSelected ? `<button class="shop-equip-btn" onclick="ShopSystem.selectTheme('${themeId}'); ShopSystem.renderThemes();">Select</button>` : ''}
          `;

          container.appendChild(card);
        }

        // Add animation to just-unlocked theme
        if (this.lastUnlockedTheme) {
          const unlockedCard = container.querySelector(`[data-theme="${this.lastUnlockedTheme}"]`);
          if (unlockedCard) {
            unlockedCard.classList.add('just-upgraded');
            setTimeout(() => unlockedCard.classList.remove('just-upgraded'), 600);
          }
          this.lastUnlockedTheme = null;
        }
      },

      buyTheme(themeId) {
        if (this.purchaseTheme(themeId)) {
          this.lastUnlockedTheme = themeId;
          this.renderThemes();
          this.updateBalanceDisplay();
          this.showThemeUnlockPopup(this.themeNames[themeId]);
        }
      },

      showThemeUnlockPopup(themeName) {
        const popup = document.createElement('div');
        popup.className = 'unlock-popup';
        popup.innerHTML = `
          <div class="unlock-popup-content">
            <div class="unlock-icon">ðŸŒ</div>
            <div class="unlock-text">Theme Unlocked!</div>
            <div class="unlock-name">${themeName}</div>
          </div>
        `;
        document.body.appendChild(popup);

        setTimeout(() => popup.classList.add('show'), 10);
        setTimeout(() => {
          popup.classList.remove('show');
          setTimeout(() => popup.remove(), 300);
        }, 2000);
      },

      lastUpgradedClub: null,
      lastUnlockedSkin: null,
      lastUnlockedClubSkin: null,
      lastUnlockedTheme: null,

      // Course theme methods
      ownedThemes: ['classic'],
      selectedTheme: 'classic',

      themePrices: {
        desert: 500,
        snow: 500,
        tropical: 600
      },

      themeNames: {
        classic: 'Classic',
        desert: 'Desert Dunes',
        snow: 'Winter Frost',
        tropical: 'Tropical Paradise'
      },

      ownsTheme(themeId) {
        return this.ownedThemes.includes(themeId);
      },

      purchaseTheme(themeId) {
        if (this.ownsTheme(themeId)) return false;
        const price = this.themePrices[themeId];
        if (!price) return false;

        if (this.spendBucks(price)) {
          this.ownedThemes.push(themeId);
          this.selectedTheme = themeId;
          this.save();
          if (AudioManager.playAchievement) AudioManager.playAchievement();

          // Track purchase achievement
          AchievementManager.onPurchase(price);

          return true;
        }
        return false;
      },

      selectTheme(themeId) {
        if (this.ownsTheme(themeId)) {
          this.selectedTheme = themeId;
          this.save();
        }
      },

      getSelectedTheme() {
        // Tournament theme override takes priority
        if (TournamentSystem.isInTournament()) {
          const tournamentTheme = TournamentSystem.getCourseTheme();
          return CourseThemes.themes[tournamentTheme] || CourseThemes.themes.classic;
        }
        return CourseThemes.themes[this.selectedTheme] || CourseThemes.themes.classic;
      }
    };

    // === Course Themes System ===
    const CourseThemes = {
      themes: {
        classic: {
          name: 'Classic',
          // Rough colors
          rough: {
            gradient: ['#5A7A42', '#6B8850', '#5A7540', '#4A6535'],
            grassDark: 'rgba(50, 70, 30, 0.7)',
            grassMed: 'rgba(70, 90, 40, 0.6)',
            grassLight: 'rgba(85, 105, 50, 0.5)'
          },
          // Fairway colors
          fairway: {
            main: '#5DBF50',
            fringe: '#4A9A40',
            stripe: 'rgba(130, 220, 110, 0.4)'
          },
          // Tee box
          tee: {
            gradient: ['#3CB371', '#2E8B57'],
            outline: '#228B22',
            markers: '#FF6B6B',
            markerOutline: '#CC5555'
          },
          // Green
          green: {
            main: '#3CB371',
            light: '#4DD588',
            contour: 'rgba(30, 100, 50, 0.15)'
          },
          // Hazards
          water: {
            main: '#4A90B8',
            light: '#6BB8E0',
            dark: '#2A5070',
            highlight: 'rgba(255, 255, 255, 0.3)'
          },
          sand: {
            main: '#E8D4A0',
            light: '#F5E6C0',
            dark: '#C4A060'
          },
          // Physics modifiers
          physics: {
            frictionMod: 1.0,
            bounceMod: 1.0
          },
          // Tree style - Lush oak with vibrant greens
          tree: {
            type: 'oak',
            trunk: { main: '#8B4513', dark: '#5D4037', outline: '#3E2723' },
            foliage: { light: '#7CB342', mid: '#689F38', dark: '#558B2F', outline: '#33691E' }
          },
          // Rock style - Classic boulder with moss
          rock: {
            type: 'standard',
            colors: { light: '#9E9E9E', mid: '#757575', dark: '#424242', outline: '#212121' },
            moss: 'rgba(56, 142, 60, 0.5)'
          },
          // Special hazards for this theme
          specialHazards: []
        },

        desert: {
          name: 'Desert Dunes',
          rough: {
            gradient: ['#C4A35A', '#D4B36A', '#B89040', '#A07830'],
            grassDark: 'rgba(160, 120, 48, 0.7)',
            grassMed: 'rgba(180, 144, 64, 0.6)',
            grassLight: 'rgba(200, 160, 80, 0.5)'
          },
          fairway: {
            main: '#8DB860',
            fringe: '#7AA050',
            stripe: 'rgba(160, 200, 120, 0.3)'
          },
          tee: {
            gradient: ['#7AA050', '#5A8030'],
            outline: '#4A6A28',
            markers: '#FF8C42',
            markerOutline: '#CC6A30'
          },
          green: {
            main: '#6AAA50',
            light: '#7CC060',
            contour: 'rgba(60, 100, 30, 0.15)'
          },
          water: {
            main: '#5A9AB8',
            light: '#7AC0E0',
            dark: '#3A6A80',
            highlight: 'rgba(255, 255, 255, 0.25)'
          },
          sand: {
            main: '#F0D890',
            light: '#FFF0B0',
            dark: '#D0A850'
          },
          physics: {
            frictionMod: 0.9, // Ball rolls further on hard ground
            bounceMod: 1.1
          },
          // Tree style - Desert palm trees
          tree: {
            type: 'palm',
            trunk: { main: '#C68E17', dark: '#875F00', outline: '#5D4037' },
            foliage: { light: '#7CB342', mid: '#558B2F', dark: '#388E3C', outline: '#2E7D32' }
          },
          // Rock style - Weathered sandstone
          rock: {
            type: 'sandstone',
            colors: { light: '#D2B48C', mid: '#C68E17', dark: '#8B4513', outline: '#5D4037' },
            moss: 'rgba(160, 120, 80, 0.3)'
          },
          specialHazards: ['quicksand', 'cactus']
        },

        snow: {
          name: 'Winter Frost',
          rough: {
            gradient: ['#E8F0F8', '#D0E0F0', '#B8D0E8', '#A0C0E0'],
            grassDark: 'rgba(160, 180, 200, 0.5)',
            grassMed: 'rgba(180, 200, 220, 0.4)',
            grassLight: 'rgba(200, 220, 240, 0.3)'
          },
          fairway: {
            main: '#C8E0C0',
            fringe: '#B0D0A8',
            stripe: 'rgba(220, 240, 220, 0.4)'
          },
          tee: {
            gradient: ['#A8D0A0', '#88B080'],
            outline: '#689068',
            markers: '#4A90D0',
            markerOutline: '#3070A0'
          },
          green: {
            main: '#90C888',
            light: '#A8D8A0',
            contour: 'rgba(100, 140, 100, 0.15)'
          },
          water: {
            main: '#88C8E8',
            light: '#B0E0F8',
            dark: '#5090B0',
            highlight: 'rgba(255, 255, 255, 0.5)'
          },
          sand: {
            main: '#F8F8F8',
            light: '#FFFFFF',
            dark: '#D0D8E0'
          },
          physics: {
            frictionMod: 0.7, // Icy = less friction, ball slides more
            bounceMod: 0.8
          },
          // Tree style - Snow-covered pine trees
          tree: {
            type: 'pine',
            trunk: { main: '#8B4513', dark: '#5D4037', outline: '#3E2723' },
            foliage: { light: '#4CAF50', mid: '#388E3C', dark: '#2E7D32', outline: '#1B5E20' },
            snow: true
          },
          // Rock style - Icy crystalline rocks
          rock: {
            type: 'icy',
            colors: { light: '#E0F7FA', mid: '#B0BEC5', dark: '#78909C', outline: '#546E7A' },
            moss: 'rgba(224, 247, 250, 0.6)'
          },
          specialHazards: ['ice', 'snowdrift']
        },

        tropical: {
          name: 'Tropical Paradise',
          rough: {
            gradient: ['#2A8040', '#3A9050', '#2A7030', '#1A6020'],
            grassDark: 'rgba(20, 80, 30, 0.7)',
            grassMed: 'rgba(40, 100, 50, 0.6)',
            grassLight: 'rgba(60, 120, 70, 0.5)'
          },
          fairway: {
            main: '#40C050',
            fringe: '#30A040',
            stripe: 'rgba(100, 220, 120, 0.4)'
          },
          tee: {
            gradient: ['#30B048', '#20A038'],
            outline: '#108028',
            markers: '#FF6090',
            markerOutline: '#D04070'
          },
          green: {
            main: '#28B840',
            light: '#40D058',
            contour: 'rgba(20, 100, 40, 0.15)'
          },
          water: {
            main: '#20A0C0',
            light: '#40C8E8',
            dark: '#107090',
            highlight: 'rgba(255, 255, 255, 0.35)'
          },
          sand: {
            main: '#F8E8C0',
            light: '#FFF8D8',
            dark: '#E0C890'
          },
          physics: {
            frictionMod: 1.1, // Lush grass = more friction
            bounceMod: 0.9
          },
          // Tree style - Lush tropical palm trees with coconuts
          tree: {
            type: 'tropicalPalm',
            trunk: { main: '#A0522D', dark: '#6B3218', outline: '#4E342E' },
            foliage: { light: '#66BB6A', mid: '#4CAF50', dark: '#388E3C', outline: '#2E7D32' }
          },
          // Rock style - Dark volcanic rocks with lava glow
          rock: {
            type: 'volcanic',
            colors: { light: '#424242', mid: '#303030', dark: '#212121', outline: '#000000' },
            lava: '#FF5722',
            lavaGlow: 'rgba(255, 87, 34, 0.3)',
            moss: 'rgba(50, 150, 100, 0.3)'
          },
          specialHazards: ['palmTree', 'tidalPool']
        }
      },

      getTheme(themeId) {
        return this.themes[themeId] || this.themes.classic;
      }
    };

    // === Daily Challenge System ===
    const DailyChallengeSystem = {
      // All possible challenge types
      challengeTypes: {
        birdie: { name: 'Birdie Hunter', desc: 'Score a birdie', icon: 'ðŸ¦', reward: 25 },
        eagle: { name: 'Eagle Eye', desc: 'Score an eagle or better', icon: 'ðŸ¦…', reward: 50 },
        holeInOne: { name: 'Ace Master', desc: 'Get a hole in one', icon: 'ðŸŽ¯', reward: 100 },
        underPar: { name: 'Under Par Pro', desc: 'Finish a round under par', icon: 'ðŸ“Š', reward: 40 },
        parStreak: { name: 'Consistent', desc: 'Get par or better on 3 consecutive holes', icon: 'â­', reward: 30 },
        longDrive: { name: 'Big Hitter', desc: 'Hit a drive over 260 yards', icon: 'ðŸ’ª', reward: 20 },
        noBunker: { name: 'Sand Dodger', desc: 'Complete a hole without hitting a bunker', icon: 'ðŸ–ï¸', reward: 15 },
        noWater: { name: 'Water Walker', desc: 'Complete 3 holes without hitting water', icon: 'ðŸŒŠ', reward: 20 },
        onePutt: { name: 'Putting Pro', desc: 'One-putt 2 greens in a round', icon: 'ðŸŽ±', reward: 25 },
        complete5: { name: 'Grinder', desc: 'Complete 5 holes today', icon: 'â›³', reward: 15 },
        complete9: { name: 'Full Round', desc: 'Complete a full 9-hole round', icon: 'ðŸ†', reward: 40 }
      },

      // Current daily challenges (3 per day)
      currentChallenges: [],
      challengeProgress: {},
      lastGeneratedDate: null,

      init() {
        this.load();
        this.checkAndGenerateDaily();
      },

      load() {
        const data = localStorage.getItem('golf-daily-challenges');
        if (data) {
          try {
            const parsed = JSON.parse(data);
            this.currentChallenges = parsed.challenges || [];
            this.challengeProgress = parsed.progress || {};
            this.lastGeneratedDate = parsed.date || null;
          } catch (e) {
            console.error('Failed to load daily challenges:', e);
          }
        }
      },

      save() {
        localStorage.setItem('golf-daily-challenges', JSON.stringify({
          challenges: this.currentChallenges,
          progress: this.challengeProgress,
          date: this.lastGeneratedDate
        }));
      },

      getTodayString() {
        const today = new Date();
        return `${today.getFullYear()}-${today.getMonth() + 1}-${today.getDate()}`;
      },

      checkAndGenerateDaily() {
        const today = this.getTodayString();
        if (this.lastGeneratedDate !== today) {
          this.generateDailyChallenges();
        }
      },

      generateDailyChallenges() {
        // Use date as seed for consistent challenges per day
        const today = this.getTodayString();
        const seed = today.split('-').reduce((a, b) => a * 31 + parseInt(b), 0);

        // Simple seeded random
        let rng = seed;
        const random = () => {
          rng = (rng * 1103515245 + 12345) & 0x7fffffff;
          return rng / 0x7fffffff;
        };

        // Pick 3 unique challenges
        const types = Object.keys(this.challengeTypes);
        const selected = [];
        while (selected.length < 3) {
          const idx = Math.floor(random() * types.length);
          const type = types[idx];
          if (!selected.includes(type)) {
            selected.push(type);
          }
        }

        this.currentChallenges = selected;
        this.challengeProgress = {};
        for (const type of selected) {
          this.challengeProgress[type] = { completed: false, progress: 0 };
        }
        this.lastGeneratedDate = today;
        this.save();
      },

      getChallenges() {
        this.checkAndGenerateDaily();
        return this.currentChallenges.map(type => ({
          type,
          ...this.challengeTypes[type],
          progress: this.challengeProgress[type] || { completed: false, progress: 0 }
        }));
      },

      // Called when various game events happen
      onBirdie() {
        this.trackProgress('birdie', 1, 1);
      },

      onEagle() {
        this.trackProgress('eagle', 1, 1);
        this.trackProgress('birdie', 1, 1); // Eagle counts as birdie too
      },

      onHoleInOne() {
        this.trackProgress('holeInOne', 1, 1);
        this.trackProgress('eagle', 1, 1);
        this.trackProgress('birdie', 1, 1);
      },

      onRoundComplete(scoreRelativeToPar) {
        if (scoreRelativeToPar < 0) {
          this.trackProgress('underPar', 1, 1);
        }
        this.trackProgress('complete9', 1, 1);
      },

      onParStreak(count) {
        if (count >= 3) {
          this.trackProgress('parStreak', 1, 1);
        }
      },

      onLongDrive(yards) {
        if (yards >= 260) {
          this.trackProgress('longDrive', 1, 1);
        }
      },

      onHoleComplete(hitBunker, hitWater) {
        this.trackProgress('complete5', 1, 5);
        if (!hitBunker) {
          this.trackProgress('noBunker', 1, 1);
        }
        if (!hitWater) {
          this.challengeProgress.noWaterStreak = (this.challengeProgress.noWaterStreak || 0) + 1;
          if (this.challengeProgress.noWaterStreak >= 3) {
            this.trackProgress('noWater', 1, 1);
          }
        } else {
          this.challengeProgress.noWaterStreak = 0;
        }
      },

      onOnePutt() {
        this.trackProgress('onePutt', 1, 2);
      },

      trackProgress(challengeType, amount, target) {
        if (!this.currentChallenges.includes(challengeType)) return;

        const progress = this.challengeProgress[challengeType];
        if (!progress || progress.completed) return;

        progress.progress += amount;
        if (progress.progress >= target) {
          progress.completed = true;
          this.awardChallenge(challengeType);
        }
        this.save();
        this.updateUI();
      },

      awardChallenge(challengeType) {
        const challenge = this.challengeTypes[challengeType];
        if (!challenge) return;

        ShopSystem.addBucks(challenge.reward, `Daily: ${challenge.name}`);
        this.showCompletionPopup(challenge);
      },

      showCompletionPopup(challenge) {
        const popup = document.createElement('div');
        popup.className = 'daily-challenge-popup';
        popup.innerHTML = `
          <div class="daily-challenge-popup-content">
            <div class="daily-icon">${challenge.icon}</div>
            <div class="daily-text">Daily Challenge Complete!</div>
            <div class="daily-name">${challenge.name}</div>
            <div class="daily-reward">+${challenge.reward} Golf Bucks</div>
          </div>
        `;
        document.body.appendChild(popup);

        setTimeout(() => popup.classList.add('show'), 10);
        setTimeout(() => {
          popup.classList.remove('show');
          setTimeout(() => popup.remove(), 300);
        }, 2500);
      },

      updateUI() {
        const container = document.getElementById('daily-challenges-list');
        if (!container) return;

        const challenges = this.getChallenges();
        container.innerHTML = challenges.map(c => `
          <div class="daily-challenge-item ${c.progress.completed ? 'completed' : ''}">
            <span class="daily-challenge-icon">${c.icon}</span>
            <div class="daily-challenge-info">
              <div class="daily-challenge-name">${c.name}</div>
              <div class="daily-challenge-desc">${c.desc}</div>
            </div>
            <div class="daily-challenge-reward">${c.progress.completed ? 'âœ“' : `+${c.reward}`}</div>
          </div>
        `).join('');
      },

      getAllCompleted() {
        return this.currentChallenges.every(type =>
          this.challengeProgress[type]?.completed
        );
      }
    };

    // === Tournament System ===
    const TournamentSystem = {
      // Constants
      TOTAL_PLAYERS: 25,
      PRIZE_PLACES: 10,
      COOLDOWN_MS: 30000, // 30 second cooldown between tournaments

      // Cooldown tracking
      lastTournamentEndTime: 0,
      cooldownInterval: null,

      // Tournament configurations with prize pools based on entry fees
      // All tournaments are single round - 9 holes, then compare scores
      tournaments: {
        weekend: {
          name: 'Weekend Classic',
          entryFee: 0,
          // Free tournament - smaller prizes funded by the club
          prizePool: [300, 200, 150, 100, 75, 50, 40, 30, 20, 10]
        },
        pro: {
          name: 'Pro Tournament',
          entryFee: 100,
          // 25 players Ã— 100 = 2500 total pool
          // Top 5 profit, 6-10 get partial refund but still lose
          prizePool: [800, 550, 400, 275, 175, 90, 75, 60, 45, 30]
        },
        championship: {
          name: 'Championship',
          entryFee: 500,
          // 25 players Ã— 500 = 12500 total pool
          // Top 5 profit, 6-10 get partial refund but still lose
          prizePool: [4000, 2750, 2000, 1375, 875, 450, 375, 300, 225, 150]
        }
      },

      // Available course themes for random selection
      courseThemes: ['classic', 'desert', 'winter', 'tropical'],

      // Current tournament state
      activeTournament: null,
      queuedTournament: null,
      queueTimer: null,

      init() {
        this.load();
      },

      load() {
        const data = localStorage.getItem('golf-tournament-data');
        if (data) {
          try {
            const parsed = JSON.parse(data);
            this.activeTournament = parsed.activeTournament || null;
            this.queuedTournament = parsed.queuedTournament || null;
            this.lastTournamentEndTime = parsed.lastTournamentEndTime || 0;
          } catch (e) {
            console.error('Failed to load tournament data:', e);
          }
        }
      },

      save() {
        localStorage.setItem('golf-tournament-data', JSON.stringify({
          activeTournament: this.activeTournament,
          queuedTournament: this.queuedTournament,
          lastTournamentEndTime: this.lastTournamentEndTime
        }));
      },

      isInTournament() {
        return this.activeTournament !== null && this.activeTournament.started;
      },

      isInQueue() {
        return this.queuedTournament !== null || (this.activeTournament && !this.activeTournament.started);
      },

      isOnCooldown() {
        if (this.lastTournamentEndTime === 0) return false;
        return Date.now() - this.lastTournamentEndTime < this.COOLDOWN_MS;
      },

      getCooldownRemaining() {
        if (!this.isOnCooldown()) return 0;
        return Math.ceil((this.COOLDOWN_MS - (Date.now() - this.lastTournamentEndTime)) / 1000);
      },

      // Join tournament queue
      joinQueue(tournamentType) {
        // Check cooldown first
        if (this.isOnCooldown()) {
          return false;
        }

        const config = this.tournaments[tournamentType];
        if (!config) return false;

        // Check entry fee
        if (config.entryFee > 0 && !ShopSystem.canAfford(config.entryFee)) {
          return false;
        }

        // Deduct entry fee immediately
        if (config.entryFee > 0) {
          ShopSystem.spendBucks(config.entryFee);
        }

        // Pick random course theme for the tournament
        const randomTheme = this.courseThemes[Math.floor(Math.random() * this.courseThemes.length)];

        this.activeTournament = {
          type: tournamentType,
          name: config.name,
          entryFee: config.entryFee,
          courseTheme: randomTheme,
          seed: Date.now(),
          started: false,
          completed: false,
          playersJoined: 1, // You're the first
          queueStartTime: Date.now(),
          finalScore: null,
          totalStrokes: null
        };
        this.save();
        return true;
      },

      // Simulate queue filling up (returns time until full in ms)
      simulateQueueFill() {
        if (!this.activeTournament || this.activeTournament.started) return 0;

        // Simulate 3-8 seconds for queue to fill
        const waitTime = 3000 + Math.random() * 5000;
        return waitTime;
      },

      // Start the tournament after queue is full
      startTournament() {
        if (!this.activeTournament) return false;

        this.activeTournament.started = true;
        this.activeTournament.playersJoined = this.TOTAL_PLAYERS;
        this.activeTournament.startTime = Date.now();
        this.save();
        return true;
      },

      // Record final score when round completes
      recordScore(scoreRelativeToPar, totalStrokes) {
        if (!this.activeTournament) return;

        this.activeTournament.finalScore = scoreRelativeToPar;
        this.activeTournament.totalStrokes = totalStrokes;
        this.activeTournament.completed = true;
        this.save();
      },

      getScore() {
        if (!this.activeTournament) return 0;
        return this.activeTournament.finalScore || 0;
      },

      getTotalStrokes() {
        if (!this.activeTournament) return 0;
        return this.activeTournament.totalStrokes || 0;
      },

      isTournamentComplete() {
        if (!this.activeTournament) return false;
        return this.activeTournament.completed === true;
      },

      getCourseTheme() {
        if (!this.activeTournament) return 'classic';
        return this.activeTournament.courseTheme || 'classic';
      },

      completeTournament() {
        if (!this.activeTournament || !this.isTournamentComplete()) return null;

        const config = this.tournaments[this.activeTournament.type];
        const playerScore = this.getScore();

        // Generate 24 AI competitors (you are the 25th)
        const competitors = this.generateCompetitors(24);
        competitors.push({ name: 'You', score: playerScore, isPlayer: true });
        competitors.sort((a, b) => a.score - b.score);

        const playerPosition = competitors.findIndex(c => c.isPlayer) + 1;
        let prize = 0;
        let lostEntry = false;

        if (playerPosition <= this.PRIZE_PLACES) {
          prize = config.prizePool[playerPosition - 1];
          ShopSystem.addBucks(prize, `${config.name} - ${this.getPositionText(playerPosition)} Place!`);
        } else {
          // Lost entry fee (no prize)
          lostEntry = true;
        }

        const result = {
          tournament: this.activeTournament.name,
          tournamentType: this.activeTournament.type,
          position: playerPosition,
          totalPlayers: this.TOTAL_PLAYERS,
          playerScore: playerScore,
          prize: prize,
          entryFee: this.activeTournament.entryFee,
          lostEntry: lostEntry,
          leaderboard: competitors // Show all 25
        };

        // Clear active tournament and set cooldown
        this.activeTournament = null;
        this.lastTournamentEndTime = Date.now();
        this.save();

        return result;
      },

      generateCompetitors(count) {
        const firstNames = ['Tiger', 'Rory', 'Jordan', 'Dustin', 'Brooks', 'Justin', 'Jon', 'Xander', 'Patrick', 'Collin', 'Viktor', 'Scottie', 'Cameron', 'Tony', 'Max', 'Phil', 'Rickie', 'Bubba', 'Adam', 'Jason', 'Hideki', 'Tommy', 'Matt', 'Shane'];
        const competitors = [];

        // Shuffle names
        const shuffled = [...firstNames].sort(() => Math.random() - 0.5);

        for (let i = 0; i < count; i++) {
          // Generate competitive scores for a single 9-hole round
          // These are skilled bots - hard to beat!
          let score = 0;
          const skillLevel = Math.random(); // 0 = best, 1 = worst

          if (skillLevel < 0.25) {
            // Elite tier (25%): -7 to -3 (very tough competitors)
            score = Math.floor(Math.random() * 5) - 7;
          } else if (skillLevel < 0.55) {
            // Strong tier (30%): -5 to -1 (solid players)
            score = Math.floor(Math.random() * 5) - 5;
          } else if (skillLevel < 0.85) {
            // Mid tier (30%): -3 to +2 (decent players)
            score = Math.floor(Math.random() * 6) - 3;
          } else {
            // Lower tier (15%): 0 to +5 (weaker players)
            score = Math.floor(Math.random() * 6);
          }

          competitors.push({
            name: shuffled[i % shuffled.length],
            score: score,
            isPlayer: false
          });
        }

        return competitors;
      },

      getPositionText(position) {
        if (position === 1) return '1st';
        if (position === 2) return '2nd';
        if (position === 3) return '3rd';
        return position + 'th';
      },

      abandonTournament() {
        // Entry fee is already lost
        this.activeTournament = null;
        this.queuedTournament = null;
        if (this.queueTimer) {
          clearTimeout(this.queueTimer);
          this.queueTimer = null;
        }
        this.save();
      },

      leaveQueue() {
        // Refund entry fee if leaving queue before tournament starts
        if (this.activeTournament && !this.activeTournament.started && this.activeTournament.entryFee > 0) {
          ShopSystem.addBucks(this.activeTournament.entryFee, 'Tournament queue refund');
        }
        this.activeTournament = null;
        if (this.queueTimer) {
          clearTimeout(this.queueTimer);
          this.queueTimer = null;
        }
        this.save();
      },

      renderUI() {
        const container = document.getElementById('tournament-content');
        if (!container) return;

        // Check if on cooldown
        if (this.isOnCooldown() && !this.activeTournament) {
          this.renderCooldownUI(container);
          return;
        }

        // Check if in queue (waiting for players)
        if (this.activeTournament && !this.activeTournament.started) {
          this.renderQueueUI(container);
          return;
        }

        // Check if there's an active tournament ready to play
        if (this.activeTournament && this.activeTournament.started && !this.activeTournament.completed) {
          const themeName = CourseThemes.getTheme(this.activeTournament.courseTheme).name;

          container.innerHTML = `
            <div class="tournament-progress">
              <h3>${this.activeTournament.name}</h3>
              <div class="tournament-course-theme">Course: ${themeName}</div>
              <div class="tournament-players-info">${this.TOTAL_PLAYERS} Players Competing</div>
              <div class="tournament-info-text">Play 9 holes - Best score wins!</div>
            </div>
            <button class="tournament-btn primary" id="continue-tournament-btn">Play Tournament</button>
            <button class="tournament-btn danger" id="abandon-tournament-btn">Abandon (Forfeit Entry)</button>
          `;
        } else {
          // Show tournament selection
          let html = '<div class="tournament-info-banner">25 Players | 9 Holes | Top 10 Win Prizes</div>';
          for (const [type, config] of Object.entries(this.tournaments)) {
            const canAfford = config.entryFee === 0 || ShopSystem.canAfford(config.entryFee);
            const lockedClass = canAfford ? '' : 'locked';
            const totalPool = config.prizePool.reduce((a, b) => a + b, 0);
            html += `
              <div class="tournament-card ${lockedClass}" data-tournament="${type}">
                <div class="tournament-name">${config.name}</div>
                <div class="tournament-details">
                  <span>9 Holes</span>
                  <span class="tournament-entry">${config.entryFee === 0 ? 'FREE ENTRY' : config.entryFee + ' Golf Bucks Entry'}</span>
                </div>
                <div class="tournament-pool">Prize Pool: ${totalPool} Golf Bucks</div>
                <div class="tournament-prizes-mini">
                  1st: ${config.prizePool[0]} | 2nd: ${config.prizePool[1]} | 3rd: ${config.prizePool[2]} Golf Bucks
                </div>
                <div class="tournament-warning">${config.entryFee > 0 ? 'Finish outside top 10 = lose entry fee' : 'No risk - free to enter!'}</div>
              </div>
            `;
          }
          container.innerHTML = html;
        }
      },

      renderCooldownUI(container) {
        const remaining = this.getCooldownRemaining();
        container.innerHTML = `
          <div class="tournament-cooldown">
            <h3>Tournament Cooldown</h3>
            <div class="cooldown-timer" id="cooldown-timer">${remaining}s</div>
            <div class="cooldown-message">Please wait before joining another tournament</div>
          </div>
        `;

        // Start countdown timer
        if (this.cooldownInterval) clearInterval(this.cooldownInterval);
        this.cooldownInterval = setInterval(() => {
          const newRemaining = this.getCooldownRemaining();
          const timerEl = document.getElementById('cooldown-timer');
          if (timerEl) {
            timerEl.textContent = newRemaining + 's';
          }
          if (newRemaining <= 0) {
            clearInterval(this.cooldownInterval);
            this.cooldownInterval = null;
            this.renderUI(); // Re-render to show tournament selection
          }
        }, 1000);
      },

      renderQueueUI(container) {
        const config = this.tournaments[this.activeTournament.type];
        const themeName = CourseThemes.getTheme(this.activeTournament.courseTheme).name;

        container.innerHTML = `
          <div class="tournament-queue">
            <h3>Joining ${this.activeTournament.name}</h3>
            <div class="queue-course">Course: ${themeName}</div>
            <div class="queue-animation">
              <div class="queue-spinner"></div>
            </div>
            <div class="queue-status">
              <span id="queue-player-count">${this.activeTournament.playersJoined}</span> / ${this.TOTAL_PLAYERS} Players
            </div>
            <div class="queue-message">Waiting for players to join...</div>
            <div class="queue-entry-info">${config.entryFee > 0 ? `Entry Fee: ${config.entryFee} Golf Bucks (paid)` : 'Free Entry'}</div>
          </div>
          <button class="tournament-btn danger" id="leave-queue-btn">${config.entryFee > 0 ? 'Leave Queue (Refund)' : 'Leave Queue'}</button>
        `;

        // Start queue simulation
        this.simulateQueueProgress(container);
      },

      simulateQueueProgress(container) {
        if (this.queueTimer) clearTimeout(this.queueTimer);

        const playerCountEl = document.getElementById('queue-player-count');
        const queueMessageEl = container.querySelector('.queue-message');
        let currentPlayers = this.activeTournament.playersJoined;

        const addPlayers = () => {
          if (!this.activeTournament || this.activeTournament.started) return;

          // Add 1-4 players at a time
          const toAdd = Math.min(Math.ceil(Math.random() * 4), this.TOTAL_PLAYERS - currentPlayers);
          currentPlayers += toAdd;
          this.activeTournament.playersJoined = currentPlayers;

          if (playerCountEl) {
            playerCountEl.textContent = currentPlayers;
          }

          if (currentPlayers >= this.TOTAL_PLAYERS) {
            // Queue is full - tournament starting!
            if (queueMessageEl) {
              queueMessageEl.textContent = 'Tournament Starting!';
              queueMessageEl.style.color = '#4CAF50';
            }

            // Start tournament after brief delay
            this.queueTimer = setTimeout(() => {
              this.startTournament();
              this.showTournamentReady();
            }, 1000);
          } else {
            // Continue adding players
            const delay = 400 + Math.random() * 800;
            this.queueTimer = setTimeout(addPlayers, delay);
          }
        };

        // Start adding players after initial delay
        this.queueTimer = setTimeout(addPlayers, 500);
      },

      showTournamentReady() {
        const container = document.getElementById('tournament-content');
        if (!container) return;

        const themeName = CourseThemes.getTheme(this.activeTournament.courseTheme).name;
        const config = this.tournaments[this.activeTournament.type];

        container.innerHTML = `
          <div class="tournament-ready">
            <div class="ready-icon">ðŸ†</div>
            <h3>${this.activeTournament.name}</h3>
            <div class="ready-message">Tournament is Ready!</div>
            <div class="ready-details">
              <div>${this.TOTAL_PLAYERS} Players Competing</div>
              <div>Course: ${themeName}</div>
              <div>9 Holes</div>
            </div>
            <div class="ready-prizes">
              Top 10 Win Prizes | 1st Place: ${config.prizePool[0]} Golf Bucks
            </div>
          </div>
          <button class="tournament-btn primary" id="start-tournament-btn">Start Tournament</button>
        `;
      },

      showResults(result) {
        const container = document.getElementById('tournament-content');
        if (!container) return;

        const positionClass = result.position === 1 ? 'gold' : (result.position === 2 ? 'silver' : (result.position === 3 ? 'bronze' : ''));
        const scoreText = result.playerScore === 0 ? 'E' : (result.playerScore > 0 ? '+' + result.playerScore : result.playerScore);
        const inMoney = result.position <= this.PRIZE_PLACES;
        const config = this.tournaments[result.tournamentType];

        container.innerHTML = `
          <div class="tournament-results">
            <h3>${result.tournament} Complete!</h3>
            <div class="tournament-position ${positionClass}">${this.getPositionText(result.position)}</div>
            <div style="color: rgba(255,255,255,0.7);">out of ${result.totalPlayers} players</div>
            <div style="color: #fff; margin: 10px 0;">Your Score: ${scoreText}</div>
            ${inMoney ?
              `<div class="tournament-prize">+${result.prize} Golf Bucks!</div>` :
              `<div class="tournament-lost">Finished outside top 10${result.entryFee > 0 ? ` - Lost ${result.entryFee} Golf Bucks entry` : ''}</div>`
            }

            <div class="tournament-leaderboard">
              <h4>Final Standings (All 25 Players)</h4>
              <div class="leaderboard-scroll">
                ${result.leaderboard.map((entry, i) => `
                  <div class="leaderboard-entry ${entry.isPlayer ? 'player' : ''} ${i < 10 ? 'in-money' : 'out-money'}">
                    <span class="lb-rank">${i + 1}.</span>
                    <span class="lb-name">${entry.name}</span>
                    <span class="lb-score">${entry.score === 0 ? 'E' : (entry.score > 0 ? '+' + entry.score : entry.score)}</span>
                    <span class="lb-prize">${i < 10 ? `+${config.prizePool[i]}` : '-'}</span>
                  </div>
                `).join('')}
              </div>
            </div>
          </div>
          <button class="tournament-btn primary" id="tournament-done-btn">Done</button>
        `;

        // Add tournament result to mailbox with leaderboard
        if (typeof MailboxManager !== 'undefined') {
          const prizeText = inMoney ? `Won ${result.prize} Golf Bucks!` : `Finished ${this.getPositionText(result.position)}`;
          MailboxManager.addNotification('tournament', `${result.tournament} Complete`,
            `${this.getPositionText(result.position)} place (${scoreText}). ${prizeText}`,
            { leaderboard: result.leaderboard, position: result.position, prize: result.prize, tournamentName: result.tournament }
          );
        }
      },

      updateIndicator() {
        const indicator = document.getElementById('tournament-indicator');
        const text = document.getElementById('tournament-indicator-text');
        if (!indicator || !text) return;

        if (this.activeTournament && this.activeTournament.started && !this.activeTournament.completed) {
          text.textContent = `${this.activeTournament.name} - In Progress`;
          indicator.classList.remove('hidden');
        } else if (this.activeTournament && !this.activeTournament.started) {
          text.textContent = `Queuing: ${this.activeTournament.name}...`;
          indicator.classList.remove('hidden');
        } else {
          indicator.classList.add('hidden');
        }
      }
    };

    // === Ghost Replay System ===
    const GhostSystem = {
      // Recording state
      isRecording: false,
      currentRecording: [],
      recordingStartTime: 0,
      sampleInterval: 50, // Sample position every 50ms
      recordingHole: 1,

      // Playback state
      isEnabled: true,
      ghostData: null, // Loaded ghost for current hole
      playbackStartTime: 0,
      currentGhostPosition: null,

      // Storage
      storageKey: 'golf-ghost-data',
      allGhosts: {},

      init() {
        this.load();
        const settings = StorageManager.loadSettings();
        this.isEnabled = settings.ghostEnabled !== false;
      },

      load() {
        const data = localStorage.getItem(this.storageKey);
        if (data) {
          try {
            this.allGhosts = JSON.parse(data);
          } catch (e) {
            console.error('Failed to load ghost data:', e);
            this.allGhosts = {};
          }
        } else {
          this.allGhosts = {};
        }
      },

      save() {
        localStorage.setItem(this.storageKey, JSON.stringify(this.allGhosts));
      },

      setEnabled(enabled) {
        this.isEnabled = enabled;
        const settings = StorageManager.loadSettings();
        settings.ghostEnabled = enabled;
        StorageManager.saveSettings(settings);
      },

      // Start recording for a hole
      startRecording(holeNumber) {
        this.isRecording = true;
        this.currentRecording = [];
        this.recordingStartTime = performance.now();
        this.recordingHole = holeNumber;
      },

      // Sample current ball position
      samplePosition(ball) {
        if (!this.isRecording || !ball) return;

        const elapsed = performance.now() - this.recordingStartTime;
        this.currentRecording.push({
          t: Math.round(elapsed),
          x: Math.round(ball.x),
          y: Math.round(ball.y),
          moving: ball.isMoving || false
        });
      },

      // Stop recording and save ghost
      stopRecording(strokes) {
        if (!this.isRecording) return;
        this.isRecording = false;

        // Only save if we have meaningful data
        if (this.currentRecording.length < 5) return;

        const ghostKey = `hole_${this.recordingHole}`;
        const existingGhost = this.allGhosts[ghostKey];

        // Only save if this is a better (fewer strokes) or first ghost
        if (!existingGhost || strokes < existingGhost.strokes) {
          this.allGhosts[ghostKey] = {
            strokes: strokes,
            positions: this.currentRecording,
            recordedAt: Date.now()
          };
          this.save();
          return true; // New best ghost saved
        }
        return false;
      },

      // Load ghost for a specific hole
      loadGhostForHole(holeNumber) {
        const ghostKey = `hole_${holeNumber}`;
        this.ghostData = this.allGhosts[ghostKey] || null;
        this.playbackStartTime = 0;
        this.currentGhostPosition = null;
      },

      // Start playback when player takes first shot
      startPlayback() {
        if (!this.isEnabled || !this.ghostData) return;
        this.playbackStartTime = performance.now();
      },

      // Get current ghost position for rendering
      getGhostPosition(currentTime) {
        if (!this.isEnabled || !this.ghostData || this.playbackStartTime === 0) {
          return null;
        }

        const elapsed = currentTime - this.playbackStartTime;
        const positions = this.ghostData.positions;

        // Find the appropriate position based on elapsed time
        let pos = null;
        for (let i = 0; i < positions.length; i++) {
          if (positions[i].t <= elapsed) {
            pos = positions[i];
          } else {
            // Interpolate between positions for smooth movement
            if (pos && positions[i]) {
              const prev = pos;
              const next = positions[i];
              const t = (elapsed - prev.t) / (next.t - prev.t);
              pos = {
                x: prev.x + (next.x - prev.x) * t,
                y: prev.y + (next.y - prev.y) * t
              };
            }
            break;
          }
        }

        // If we've passed all positions, use the last one
        if (!pos && positions.length > 0) {
          pos = positions[positions.length - 1];
        }

        this.currentGhostPosition = pos;
        return pos;
      },

      // Check if ghost has finished (reached hole)
      isGhostFinished(currentTime) {
        if (!this.ghostData || this.playbackStartTime === 0) return true;
        const elapsed = currentTime - this.playbackStartTime;
        const lastPos = this.ghostData.positions[this.ghostData.positions.length - 1];
        return lastPos && elapsed > lastPos.t;
      },

      // Get ghost strokes for comparison
      getGhostStrokes() {
        return this.ghostData ? this.ghostData.strokes : null;
      },

      // Clear ghost for a hole
      clearGhostForHole(holeNumber) {
        const ghostKey = `hole_${holeNumber}`;
        delete this.allGhosts[ghostKey];
        this.save();
      },

      // Clear all ghosts
      clearAllGhosts() {
        this.allGhosts = {};
        this.save();
      },

      // Render the ghost ball
      renderGhost(ctx, currentTime) {
        const pos = this.getGhostPosition(currentTime);
        if (!pos) return;

        // Draw ghost ball (semi-transparent blue)
        ctx.save();
        ctx.globalAlpha = 0.4;

        // Ghost ball gradient
        const gradient = ctx.createRadialGradient(pos.x - 3, pos.y - 3, 0, pos.x, pos.y, 10);
        gradient.addColorStop(0, '#87CEEB');
        gradient.addColorStop(0.5, '#4169E1');
        gradient.addColorStop(1, '#1E3A5F');

        ctx.beginPath();
        ctx.arc(pos.x, pos.y, 10, 0, Math.PI * 2);
        ctx.fillStyle = gradient;
        ctx.fill();

        // Ghost outline
        ctx.strokeStyle = 'rgba(65, 105, 225, 0.6)';
        ctx.lineWidth = 2;
        ctx.stroke();

        // Ghost trail effect
        ctx.globalAlpha = 0.2;
        ctx.beginPath();
        ctx.arc(pos.x, pos.y, 14, 0, Math.PI * 2);
        ctx.strokeStyle = '#87CEEB';
        ctx.lineWidth = 1;
        ctx.stroke();

        ctx.restore();
      }
    };

    // === Achievement System ===
    const AchievementManager = {
      achievements: {
        // Scoring achievements
        firstBirdie: { name: 'First Birdie!', desc: 'Score your first birdie', icon: 'ðŸ¦', unlocked: false },
        firstEagle: { name: 'Soaring Eagle', desc: 'Score an eagle or better', icon: 'ðŸ¦…', unlocked: false },
        holeInOne: { name: 'ACE!', desc: 'Get a hole in one', icon: 'ðŸŽ¯', unlocked: false },
        parStreak: { name: 'Par for the Course', desc: 'Get par or better on 3 holes in a row', icon: 'â­', unlocked: false },
        underPar: { name: 'Under Pressure', desc: 'Finish a round under par', icon: 'ðŸ†', unlocked: false },
        albatross: { name: 'Albatross!', desc: 'Score 3 under par on a single hole', icon: 'ðŸ¦¢', unlocked: false },
        fiveBirdies: { name: 'Birdie Bonanza', desc: 'Get 5 birdies in a single round', icon: 'ðŸ¦âœ¨', unlocked: false },
        bogeyFree: { name: 'Flawless', desc: 'Complete a round with no bogeys', icon: 'ðŸ’Ž', unlocked: false },
        wayUnderPar: { name: 'On Fire!', desc: 'Finish a round 5 or more under par', icon: 'ðŸ”¥', unlocked: false },

        // Progress achievements
        firstHole: { name: 'Getting Started', desc: 'Complete your first hole', icon: 'â›³', unlocked: false },
        halfway: { name: 'Halfway There', desc: 'Complete 5 holes', icon: 'ðŸŒŸ', unlocked: false },
        fullRound: { name: 'Full Round', desc: 'Complete all 9 holes', icon: 'ðŸŽ‰', unlocked: false },
        tenRounds: { name: 'Regular', desc: 'Complete 10 rounds', icon: 'ðŸ“…', unlocked: false },
        fiftyRounds: { name: 'Dedicated', desc: 'Complete 50 rounds', icon: 'ðŸŽ–ï¸', unlocked: false },
        hundredHoles: { name: 'Centurion', desc: 'Complete 100 holes total', icon: 'ðŸ’¯', unlocked: false },

        // Special achievements
        longDrive: { name: 'Big Hitter', desc: 'Hit a drive over 280 yards', icon: 'ðŸ’ª', unlocked: false },
        sandSave: { name: 'Sandy Save', desc: 'Get par after landing in a bunker', icon: 'ðŸ–ï¸', unlocked: false },
        waterRecovery: { name: 'Water Walker', desc: 'Get par after a water hazard', icon: 'ðŸŒŠ', unlocked: false },
        monsterDrive: { name: 'Monster Drive', desc: 'Hit a drive over 320 yards', icon: 'ðŸ‘¹', unlocked: false },

        // Streak achievements
        threePutts: { name: 'Putting Pro', desc: 'One-putt 3 greens in a round', icon: 'ðŸŽ±', unlocked: false },
        noDouble: { name: 'Steady Eddie', desc: 'Complete a round with no double bogeys', icon: 'ðŸ›¡ï¸', unlocked: false },
        fiveParStreak: { name: 'Consistency King', desc: 'Get par or better on 5 holes in a row', icon: 'ðŸ‘‘', unlocked: false },

        // Tournament achievements
        tournamentFirst: { name: 'Champion!', desc: 'Win a tournament', icon: 'ðŸ¥‡', unlocked: false },
        tournamentTop3: { name: 'Podium Finish', desc: 'Finish top 3 in a tournament', icon: 'ðŸ…', unlocked: false },
        tournamentMoney: { name: 'In the Money', desc: 'Finish in the prize spots', icon: 'ðŸ’°', unlocked: false },
        tournamentTen: { name: 'Tournament Regular', desc: 'Complete 10 tournaments', icon: 'ðŸŸï¸', unlocked: false },

        // Shopping achievements
        firstPurchase: { name: 'Shopper', desc: 'Buy something from the shop', icon: 'ðŸ›’', unlocked: false },
        bigSpender: { name: 'Big Spender', desc: 'Spend 1000 Golf Bucks total', icon: 'ðŸ’¸', unlocked: false }
      },

      // Track stats for achievements
      stats: {
        parStreak: 0,
        holesCompleted: 0,
        onePutts: 0,
        hadWater: false,
        hadSand: false,
        hasDoubleBogey: false,
        hasBogey: false,
        longestDrive: 0,
        birdiesThisRound: 0,
        // Persistent stats (saved to localStorage)
        totalHoles: 0,
        totalRounds: 0,
        tournamentsCompleted: 0,
        totalSpent: 0
      },

      popupQueue: [],
      isShowing: false,
      popupTimeout: null,

      init() {
        // Ensure popup is hidden on init
        const popup = document.getElementById('achievement-popup');
        if (popup) {
          popup.classList.remove('show');
        }
        this.isShowing = false;
        this.popupQueue = [];
        if (this.popupTimeout) {
          clearTimeout(this.popupTimeout);
          this.popupTimeout = null;
        }

        // Load unlocked achievements from localStorage
        const saved = localStorage.getItem('golf-achievements');
        if (saved) {
          try {
            const unlocked = JSON.parse(saved);
            for (const id of unlocked) {
              if (this.achievements[id]) {
                this.achievements[id].unlocked = true;
              }
            }
          } catch (e) {
            console.error('Failed to load achievements:', e);
          }
        }

        // Load persistent stats from localStorage
        const savedStats = localStorage.getItem('golf-achievement-stats');
        if (savedStats) {
          try {
            const stats = JSON.parse(savedStats);
            this.stats.totalHoles = stats.totalHoles || 0;
            this.stats.totalRounds = stats.totalRounds || 0;
            this.stats.tournamentsCompleted = stats.tournamentsCompleted || 0;
            this.stats.totalSpent = stats.totalSpent || 0;
          } catch (e) {
            console.error('Failed to load achievement stats:', e);
          }
        }
      },

      resetRoundStats() {
        this.stats.parStreak = 0;
        this.stats.holesCompleted = 0;
        this.stats.onePutts = 0;
        this.stats.hadWater = false;
        this.stats.hadSand = false;
        this.stats.hasDoubleBogey = false;
        this.stats.hasBogey = false;
        this.stats.birdiesThisRound = 0;
      },

      savePersistentStats() {
        const statsToSave = {
          totalHoles: this.stats.totalHoles,
          totalRounds: this.stats.totalRounds,
          tournamentsCompleted: this.stats.tournamentsCompleted,
          totalSpent: this.stats.totalSpent
        };
        localStorage.setItem('golf-achievement-stats', JSON.stringify(statsToSave));
      },

      unlock(achievementId) {
        const achievement = this.achievements[achievementId];
        if (!achievement || achievement.unlocked) return false;

        achievement.unlocked = true;
        this.saveToStorage();
        this.queuePopup(achievement);
        AudioManager.playAchievement();

        // Award Golf Bucks for achievement unlock
        ShopSystem.addBucks(100, 'Achievement');

        return true;
      },

      queuePopup(achievement) {
        this.popupQueue.push(achievement);
        if (!this.isShowing) {
          this.showNextPopup();
        }

        // Add to mailbox
        if (typeof MailboxManager !== 'undefined') {
          MailboxManager.addNotification('achievement', achievement.name, achievement.desc);
        }
      },

      showNextPopup() {
        if (this.popupQueue.length === 0) {
          this.isShowing = false;
          return;
        }

        this.isShowing = true;
        const achievement = this.popupQueue.shift();

        const popup = document.getElementById('achievement-popup');
        if (!popup) {
          this.isShowing = false;
          return;
        }

        popup.querySelector('.achievement-icon').textContent = achievement.icon;
        popup.querySelector('.achievement-name').textContent = achievement.name;
        popup.querySelector('.achievement-desc').textContent = achievement.desc;

        popup.classList.add('show');

        // Clear any existing timeout
        if (this.popupTimeout) {
          clearTimeout(this.popupTimeout);
        }

        this.popupTimeout = setTimeout(() => {
          popup.classList.remove('show');
          this.popupTimeout = setTimeout(() => this.showNextPopup(), 500);
        }, 3000);
      },

      saveToStorage() {
        const unlocked = Object.keys(this.achievements)
          .filter(id => this.achievements[id].unlocked);
        localStorage.setItem('golf-achievements', JSON.stringify(unlocked));
      },

      // Called when a hole is completed
      onHoleComplete(holeNumber, strokes, par, wasInWater, wasInSand, putts) {
        const score = strokes - par;

        // First hole
        if (!this.achievements.firstHole.unlocked) {
          this.unlock('firstHole');
        }

        this.stats.holesCompleted++;
        this.stats.totalHoles++;

        // Check total holes achievement
        if (this.stats.totalHoles >= 100) {
          this.unlock('hundredHoles');
        }

        // Halfway
        if (this.stats.holesCompleted >= 5) {
          this.unlock('halfway');
        }

        // Full round
        if (this.stats.holesCompleted >= 9) {
          this.unlock('fullRound');
        }

        // Hole in one
        if (strokes === 1) {
          this.unlock('holeInOne');
        }

        // Albatross (-3 or better on a hole, not counting hole in one on par 3)
        if (score <= -3) {
          this.unlock('albatross');
        }

        // Eagle or better
        if (score <= -2) {
          this.unlock('firstEagle');
        }

        // Birdie
        if (score === -1) {
          this.unlock('firstBirdie');
          this.stats.birdiesThisRound++;
        }

        // Also count eagles as birdies for the counter
        if (score <= -2) {
          this.stats.birdiesThisRound++;
        }

        // Par streak
        if (score <= 0) {
          this.stats.parStreak++;
          if (this.stats.parStreak >= 3) {
            this.unlock('parStreak');
          }
          if (this.stats.parStreak >= 5) {
            this.unlock('fiveParStreak');
          }
        } else {
          this.stats.parStreak = 0;
        }

        // Bogey check (for bogey-free round)
        if (score >= 1) {
          this.stats.hasBogey = true;
        }

        // Double bogey check
        if (score >= 2) {
          this.stats.hasDoubleBogey = true;
        }

        // One putt tracking
        if (putts === 1) {
          this.stats.onePutts++;
          if (this.stats.onePutts >= 3) {
            this.unlock('threePutts');
          }
        }

        // Water/Sand recovery
        if (wasInWater && score <= 0) {
          this.unlock('waterRecovery');
        }
        if (wasInSand && score <= 0) {
          this.unlock('sandSave');
        }

        // Save persistent stats
        this.savePersistentStats();
      },

      // Called when a drive is hit
      onDriveHit(distanceYards) {
        if (distanceYards > this.stats.longestDrive) {
          this.stats.longestDrive = distanceYards;
        }
        if (distanceYards >= 280) {
          this.unlock('longDrive');
        }
        if (distanceYards >= 320) {
          this.unlock('monsterDrive');
        }
      },

      // Called when round is complete
      onRoundComplete(totalScore) {
        this.stats.totalRounds++;

        // Under par achievements
        if (totalScore < 0) {
          this.unlock('underPar');
        }
        if (totalScore <= -5) {
          this.unlock('wayUnderPar');
        }

        // Consistency achievements
        if (!this.stats.hasDoubleBogey) {
          this.unlock('noDouble');
        }
        if (!this.stats.hasBogey) {
          this.unlock('bogeyFree');
        }

        // Birdie count achievement
        if (this.stats.birdiesThisRound >= 5) {
          this.unlock('fiveBirdies');
        }

        // Rounds milestones
        if (this.stats.totalRounds >= 10) {
          this.unlock('tenRounds');
        }
        if (this.stats.totalRounds >= 50) {
          this.unlock('fiftyRounds');
        }

        this.savePersistentStats();
      },

      // Called when a tournament is completed
      onTournamentComplete(position) {
        this.stats.tournamentsCompleted++;

        if (position === 1) {
          this.unlock('tournamentFirst');
        }
        if (position <= 3) {
          this.unlock('tournamentTop3');
        }
        if (position <= 10) {
          this.unlock('tournamentMoney');
        }
        if (this.stats.tournamentsCompleted >= 10) {
          this.unlock('tournamentTen');
        }

        this.savePersistentStats();
      },

      // Called when a purchase is made
      onPurchase(amount) {
        this.stats.totalSpent += amount;
        this.unlock('firstPurchase');

        if (this.stats.totalSpent >= 1000) {
          this.unlock('bigSpender');
        }

        this.savePersistentStats();
      }
    };

    // === CourseGenerator Module (T026-T029) ===
    const CourseGenerator = {
      holeTemplates: null,
      rng: null,

      init(seed) {
        this.rng = new SeededRandom(seed);
        this.holeTemplates = this.defineHoleTemplates();
      },

      defineHoleTemplates() {
        // Distances are now in YARDS (real golf distances)
        // Par 3: 150-220 yards, Par 4: 300-450 yards, Par 5: 450-550 yards
        // dogleg: 'none', 'left', 'right' - direction the fairway bends
        // doglegSharp: true for 90Â° turns, false for gentle curves
        return [
          { holeNumber: 1, par: 3, length: 'short', distanceYards: 185, dogleg: 'none' },
          { holeNumber: 2, par: 4, length: 'medium', distanceYards: 340, dogleg: 'left', doglegSharp: false },
          { holeNumber: 3, par: 3, length: 'short', distanceYards: 165, dogleg: 'none' },
          { holeNumber: 4, par: 5, length: 'long', distanceYards: 480, dogleg: 'right', doglegSharp: true },
          { holeNumber: 5, par: 4, length: 'medium', distanceYards: 295, dogleg: 'none' },
          { holeNumber: 6, par: 4, length: 'medium', distanceYards: 370, dogleg: 'right', doglegSharp: false },
          { holeNumber: 7, par: 3, length: 'short', distanceYards: 200, dogleg: 'none' },
          { holeNumber: 8, par: 5, length: 'long', distanceYards: 465, dogleg: 'left', doglegSharp: true },
          { holeNumber: 9, par: 4, length: 'medium', distanceYards: 355, dogleg: 'left', doglegSharp: false }
        ];
      },

      generateHole(holeNumber, canvasWidth, canvasHeight) {
        const template = this.holeTemplates[holeNumber - 1];

        // Initialize screen scale if not already done
        ScreenScale.init(canvasWidth);
        // Update legacy constant for backwards compatibility
        PIXELS_TO_YARDS = 1 / ScreenScale.pixelsPerYard;

        // Convert yards to pixels for positioning
        const distancePixels = ScreenScale.yardsToPixels(template.distanceYards);

        // Scale tee position margin based on screen size
        const teeMargin = Math.max(50, canvasWidth * 0.05);
        const teeX = teeMargin;
        const teeY = canvasHeight / 2 + this.rng.nextInt(-30, 30);

        // Calculate fairway path based on dogleg
        let fairwayPath = []; // Array of waypoints from tee to green
        let greenX, greenY;

        if (template.dogleg === 'none') {
          // Straight hole
          greenX = Math.min(teeX + distancePixels, canvasWidth - teeMargin);
          greenY = canvasHeight / 2 + this.rng.nextInt(-60, 60);
          fairwayPath = [
            { x: teeX, y: teeY },
            { x: greenX, y: greenY }
          ];
        } else {
          // Dogleg hole - create bend point
          const bendDistance = template.doglegSharp ? 0.45 : 0.55; // Where the turn happens
          const bendAmount = template.doglegSharp ? 120 : 70; // How far off-center
          const bendDir = template.dogleg === 'left' ? -1 : 1;

          // First segment goes mostly horizontal with slight vertical offset
          const bendX = teeX + distancePixels * bendDistance;
          const bendY = teeY + bendDir * bendAmount;

          // Clamp bend point to stay on screen
          const clampedBendY = Math.max(80, Math.min(canvasHeight - 80, bendY));

          // Green position - continue from bend
          greenX = Math.min(teeX + distancePixels, canvasWidth - teeMargin);
          // Green goes opposite direction from bend to create the turn
          greenY = clampedBendY - bendDir * (template.doglegSharp ? 60 : 30);
          greenY = Math.max(80, Math.min(canvasHeight - 80, greenY));

          fairwayPath = [
            { x: teeX, y: teeY },
            { x: bendX, y: clampedBendY },
            { x: greenX, y: greenY }
          ];
        }

        const hole = {
          holeNumber: template.holeNumber,
          par: template.par,
          length: template.length,
          distanceYards: template.distanceYards,
          dogleg: template.dogleg,
          doglegSharp: template.doglegSharp || false,
          fairwayPath: fairwayPath, // Waypoints for drawing curved fairway
          teePosition: { x: teeX, y: teeY },
          greenPosition: { x: greenX, y: greenY },
          holePosition: { x: greenX, y: greenY },
          obstacles: this.placeObstaclesWithDogleg(template, fairwayPath, canvasWidth, canvasHeight)
        };

        return hole;
      },

      placeObstacles(template, teeX, teeY, greenX, greenY, canvasWidth, canvasHeight) {
        const obstacles = [];

        // Calculate fairway direction and perpendicular
        const fairwayDx = greenX - teeX;
        const fairwayDy = greenY - teeY;
        const fairwayLength = Math.sqrt(fairwayDx * fairwayDx + fairwayDy * fairwayDy);
        const fairwayNormX = fairwayDx / fairwayLength;
        const fairwayNormY = fairwayDy / fairwayLength;

        // Perpendicular direction (for placing obstacles to sides of fairway)
        const perpX = -fairwayNormY;
        const perpY = fairwayNormX;

        // Helper to check if position overlaps existing obstacles
        const overlapsExisting = (x, y, radius) => {
          for (const obs of obstacles) {
            const obsRadius = obs.shape === 'rectangle'
              ? Math.max(obs.width, obs.height) / 2 + 10
              : obs.radius + 10;
            const dist = Math.sqrt((x - obs.x) ** 2 + (y - obs.y) ** 2);
            const minDist = radius + obsRadius + 15; // 15px buffer between obstacles
            if (dist < minDist) return true;
          }
          return false;
        };

        // Helper to check if position is valid (not too close to tee/green, on screen)
        const isValidPosition = (x, y, radius) => {
          const distFromTee = Math.sqrt((x - teeX) ** 2 + (y - teeY) ** 2);
          const distFromGreen = Math.sqrt((x - greenX) ** 2 + (y - greenY) ** 2);
          const margin = 50;
          return distFromTee > 80 &&
                 distFromGreen > 100 &&
                 x > margin && x < canvasWidth - margin &&
                 y > margin && y < canvasHeight - margin;
        };

        // Helper to try placing an obstacle of a specific type
        const tryPlaceObstacle = (type, minDist, maxDist, sideOnly, closerToCenter) => {
          for (let attempt = 0; attempt < 20; attempt++) {
            const distAlongFairway = minDist + this.rng.next() * (maxDist - minDist);
            const baseX = teeX + fairwayDx * distAlongFairway;
            const baseY = teeY + fairwayDy * distAlongFairway;

            let perpOffset;
            if (sideOnly) {
              perpOffset = (this.rng.next() < 0.5 ? -1 : 1) * (60 + this.rng.nextInt(0, 80));
            } else if (closerToCenter) {
              // Place closer to the fairway center line for more challenge
              perpOffset = this.rng.nextInt(-70, 70);
            } else {
              perpOffset = this.rng.nextInt(-100, 100);
            }

            const x = baseX + perpX * perpOffset;
            const y = baseY + perpY * perpOffset;

            let radius, width, height, shape;
            if (type === 'water') {
              width = this.rng.nextInt(80, 110);
              height = this.rng.nextInt(50, 70);
              radius = Math.max(width, height) / 2;
              shape = 'rectangle';
            } else if (type === 'sand') {
              // Variable bunker sizes - greenside bunkers (closer to green) are larger
              const isGreenside = distAlongFairway > 0.6;
              if (isGreenside) {
                radius = this.rng.nextInt(45, 70);  // Large greenside bunkers
              } else {
                radius = this.rng.nextInt(35, 55);  // Medium fairway bunkers
              }
              width = 0;
              height = 0;
              shape = 'circle';
            } else if (type === 'tree') {
              radius = this.rng.nextInt(24, 32);
              width = 0;
              height = 0;
              shape = 'circle';
            } else { // rock
              radius = this.rng.nextInt(16, 26);
              width = 0;
              height = 0;
              shape = 'circle';
            }

            if (isValidPosition(x, y, radius) && !overlapsExisting(x, y, radius)) {
              obstacles.push({ type, x, y, radius, width, height, shape });
              return true;
            }
          }
          return false;
        };

        // === GUARANTEED MINIMUM OBSTACLES ===

        // 2 trees minimum - one on each side of fairway in early-mid section
        tryPlaceObstacle('tree', 0.25, 0.45, true, false);  // Left or right side
        tryPlaceObstacle('tree', 0.35, 0.55, true, false);  // Other side

        // 2-3 rocks minimum - scattered along fairway
        tryPlaceObstacle('rock', 0.20, 0.40, false, false);
        tryPlaceObstacle('rock', 0.45, 0.65, false, true);  // Mid fairway, closer to center
        if (this.rng.next() < 0.6) {
          tryPlaceObstacle('rock', 0.55, 0.75, false, false);
        }

        // 1 sand bunker minimum - near the green approach
        tryPlaceObstacle('sand', 0.65, 0.85, false, true);  // Closer to center for challenge

        // === ADDITIONAL RANDOM OBSTACLES FOR DIFFICULTY ===

        // Extra obstacles based on hole length
        const extraCount = template.length === 'short' ? this.rng.nextInt(1, 2) :
                          template.length === 'medium' ? this.rng.nextInt(2, 3) :
                          this.rng.nextInt(2, 4);

        for (let i = 0; i < extraCount; i++) {
          const rand = this.rng.next();
          let type, minD, maxD, side, center;

          if (rand < 0.25) {
            // Extra tree
            type = 'tree';
            minD = 0.30;
            maxD = 0.70;
            side = this.rng.next() < 0.5;
            center = false;
          } else if (rand < 0.45) {
            // Extra rock in play area
            type = 'rock';
            minD = 0.35;
            maxD = 0.75;
            side = false;
            center = true;  // More challenging - in the way!
          } else if (rand < 0.70) {
            // Extra sand bunker
            type = 'sand';
            minD = 0.50;
            maxD = 0.80;
            side = false;
            center = this.rng.next() < 0.6;
          } else {
            // Water hazard - dangerous!
            type = 'water';
            minD = 0.40;
            maxD = 0.65;
            side = false;
            center = this.rng.next() < 0.4;  // Sometimes in the way
          }

          tryPlaceObstacle(type, minD, maxD, side, center);
        }

        // Sort obstacles for proper draw order (water first, then sand, then trees/rocks)
        const typeOrder = { water: 0, sand: 1, rock: 2, tree: 3 };
        obstacles.sort((a, b) => typeOrder[a.type] - typeOrder[b.type]);

        return obstacles;
      },

      // New obstacle placement that follows dogleg fairway path
      placeObstaclesWithDogleg(template, fairwayPath, canvasWidth, canvasHeight) {
        const obstacles = [];
        const tee = fairwayPath[0];
        const green = fairwayPath[fairwayPath.length - 1];
        const hasDogleg = fairwayPath.length > 2;
        const bend = hasDogleg ? fairwayPath[1] : null;

        // Helper to get point along fairway path at position t (0-1)
        const getPointOnFairway = (t) => {
          if (!hasDogleg) {
            return {
              x: tee.x + (green.x - tee.x) * t,
              y: tee.y + (green.y - tee.y) * t
            };
          }
          // Two segments: tee->bend (0 to 0.5), bend->green (0.5 to 1)
          if (t < 0.5) {
            const segT = t * 2;
            return {
              x: tee.x + (bend.x - tee.x) * segT,
              y: tee.y + (bend.y - tee.y) * segT
            };
          } else {
            const segT = (t - 0.5) * 2;
            return {
              x: bend.x + (green.x - bend.x) * segT,
              y: bend.y + (green.y - bend.y) * segT
            };
          }
        };

        // Helper to get perpendicular direction at point t
        const getPerpAtT = (t) => {
          let dx, dy;
          if (!hasDogleg) {
            dx = green.x - tee.x;
            dy = green.y - tee.y;
          } else if (t < 0.5) {
            dx = bend.x - tee.x;
            dy = bend.y - tee.y;
          } else {
            dx = green.x - bend.x;
            dy = green.y - bend.y;
          }
          const len = Math.sqrt(dx * dx + dy * dy);
          return { x: -dy / len, y: dx / len };
        };

        // Helper to check valid position
        const isValidPosition = (x, y, radius) => {
          const distFromTee = Math.sqrt((x - tee.x) ** 2 + (y - tee.y) ** 2);
          const distFromGreen = Math.sqrt((x - green.x) ** 2 + (y - green.y) ** 2);
          const margin = 40;
          return distFromTee > 70 &&
                 distFromGreen > 90 &&
                 x > margin && x < canvasWidth - margin &&
                 y > margin && y < canvasHeight - margin;
        };

        // Helper to check overlap
        const overlapsExisting = (x, y, radius) => {
          for (const obs of obstacles) {
            const obsRadius = obs.shape === 'rectangle'
              ? Math.max(obs.width, obs.height) / 2 + 10
              : obs.radius + 10;
            const dist = Math.sqrt((x - obs.x) ** 2 + (y - obs.y) ** 2);
            if (dist < radius + obsRadius + 12) return true;
          }
          return false;
        };

        // === STRATEGIC CORNER TREE at dogleg ===
        if (hasDogleg && template.dogleg !== 'none') {
          // Place tree at the inside corner of the dogleg to block shortcuts
          const cornerDir = template.dogleg === 'left' ? 1 : -1; // Inside of turn
          const cornerX = bend.x + cornerDir * 45;
          const cornerY = bend.y;
          if (isValidPosition(cornerX, cornerY, 30)) {
            obstacles.push({
              type: 'tree',
              x: cornerX,
              y: cornerY,
              radius: 28,
              width: 0,
              height: 0,
              shape: 'circle',
              isCornerTree: true // Mark as strategic corner tree
            });
          }
        }

        // Helper to place an obstacle
        const tryPlaceObstacle = (type, tMin, tMax, perpMin, perpMax) => {
          for (let attempt = 0; attempt < 15; attempt++) {
            const t = tMin + this.rng.next() * (tMax - tMin);
            const pt = getPointOnFairway(t);
            const perp = getPerpAtT(t);
            const perpOffset = perpMin + this.rng.next() * (perpMax - perpMin);
            const side = this.rng.next() < 0.5 ? 1 : -1;

            const x = pt.x + perp.x * perpOffset * side;
            const y = pt.y + perp.y * perpOffset * side;

            let radius;
            if (type === 'tree') radius = this.rng.nextInt(22, 30);
            else if (type === 'rock') radius = this.rng.nextInt(14, 22);
            else if (type === 'sand') radius = this.rng.nextInt(40, 60);
            else radius = 50; // water

            if (isValidPosition(x, y, radius) && !overlapsExisting(x, y, radius)) {
              if (type === 'water') {
                obstacles.push({
                  type, x, y: y,
                  radius: Math.max(70, 90) / 2,
                  width: this.rng.nextInt(70, 100),
                  height: this.rng.nextInt(45, 65),
                  shape: 'rectangle'
                });
              } else {
                obstacles.push({ type, x, y, radius, width: 0, height: 0, shape: 'circle' });
              }
              return true;
            }
          }
          return false;
        };

        // === PLACE OBSTACLES ===
        // Trees in rough only (perpOffset 65+ keeps them outside fairway)
        tryPlaceObstacle('tree', 0.2, 0.4, 70, 140);
        tryPlaceObstacle('tree', 0.4, 0.65, 75, 150);
        if (template.length !== 'short') {
          tryPlaceObstacle('tree', 0.55, 0.8, 80, 160);
        }

        // Rocks in rough only (perpOffset 65+ keeps them outside fairway)
        tryPlaceObstacle('rock', 0.25, 0.5, 70, 130);
        tryPlaceObstacle('rock', 0.5, 0.75, 65, 120);

        // Sand bunkers - can be on fairway edge or greenside
        tryPlaceObstacle('sand', 0.75, 0.92, 25, 55); // Greenside
        if (template.length !== 'short') {
          tryPlaceObstacle('sand', 0.4, 0.6, 40, 70); // Fairway bunker (edge of fairway)
        }

        // Water hazard on longer holes - off to the side
        if (template.length === 'long' && this.rng.next() < 0.6) {
          tryPlaceObstacle('water', 0.35, 0.55, 60, 120);
        }

        // === SPECIAL OBSTACLES (only on themed courses, not classic) ===
        const currentTheme = ShopSystem.selectedTheme || 'classic';
        const hasSpecialObstacles = currentTheme !== 'classic';

        // Windmill - 30% chance on medium/long holes (themed courses only)
        if (hasSpecialObstacles && template.length !== 'short' && this.rng.next() < 0.30) {
          for (let attempt = 0; attempt < 10; attempt++) {
            const t = 0.3 + this.rng.next() * 0.35; // Between 30-65% of fairway
            const pt = getPointOnFairway(t);
            const perp = getPerpAtT(t);
            const perpOffset = 50 + this.rng.next() * 60; // Near fairway edge
            const side = this.rng.next() < 0.5 ? 1 : -1;

            const x = pt.x + perp.x * perpOffset * side;
            const y = pt.y + perp.y * perpOffset * side;
            const radius = 35;

            if (isValidPosition(x, y, radius) && !overlapsExisting(x, y, radius)) {
              obstacles.push({
                type: 'windmill',
                x, y, radius,
                width: 0, height: 0,
                shape: 'circle',
                angle: this.rng.next() * Math.PI * 2,
                rotationSpeed: 1.2 + this.rng.next() * 0.8
              });
              break;
            }
          }
        }

        // Moving rock - 25% chance on medium/long holes (themed courses only)
        if (hasSpecialObstacles && template.length !== 'short' && this.rng.next() < 0.25) {
          for (let attempt = 0; attempt < 10; attempt++) {
            const t = 0.25 + this.rng.next() * 0.4; // Between 25-65% of fairway
            const pt = getPointOnFairway(t);
            const perp = getPerpAtT(t);
            const perpOffset = 30 + this.rng.next() * 50; // Can be near fairway
            const side = this.rng.next() < 0.5 ? 1 : -1;

            const x = pt.x + perp.x * perpOffset * side;
            const y = pt.y + perp.y * perpOffset * side;
            const radius = 18;

            if (isValidPosition(x, y, radius + 80) && !overlapsExisting(x, y, radius + 80)) {
              obstacles.push({
                type: 'movingRock',
                x, y, radius,
                width: 0, height: 0,
                shape: 'circle',
                moveSpeed: 40 + this.rng.next() * 40,
                moveRange: 60 + this.rng.next() * 40,
                moveDir: this.rng.next() < 0.5 ? 1 : -1
              });
              break;
            }
          }
        }

        // Teleporters - 20% chance, always come in pairs (themed courses only)
        if (hasSpecialObstacles && this.rng.next() < 0.20) {
          let teleporter1 = null;
          let teleporter2 = null;

          // First teleporter near tee area
          for (let attempt = 0; attempt < 10; attempt++) {
            const t = 0.15 + this.rng.next() * 0.2; // 15-35% of fairway
            const pt = getPointOnFairway(t);
            const perp = getPerpAtT(t);
            const perpOffset = 60 + this.rng.next() * 50;
            const side = this.rng.next() < 0.5 ? 1 : -1;

            const x = pt.x + perp.x * perpOffset * side;
            const y = pt.y + perp.y * perpOffset * side;
            const radius = 20;

            if (isValidPosition(x, y, radius) && !overlapsExisting(x, y, radius)) {
              teleporter1 = {
                type: 'teleporter',
                x, y, radius,
                width: 0, height: 0,
                shape: 'circle',
                portalColor: '#8B5CF6' // Purple
              };
              break;
            }
          }

          // Second teleporter near green area
          if (teleporter1) {
            for (let attempt = 0; attempt < 10; attempt++) {
              const t = 0.6 + this.rng.next() * 0.25; // 60-85% of fairway
              const pt = getPointOnFairway(t);
              const perp = getPerpAtT(t);
              const perpOffset = 50 + this.rng.next() * 50;
              const side = this.rng.next() < 0.5 ? 1 : -1;

              const x = pt.x + perp.x * perpOffset * side;
              const y = pt.y + perp.y * perpOffset * side;
              const radius = 20;

              if (isValidPosition(x, y, radius) && !overlapsExisting(x, y, radius)) {
                teleporter2 = {
                  type: 'teleporter',
                  x, y, radius,
                  width: 0, height: 0,
                  shape: 'circle',
                  portalColor: '#F59E0B' // Orange
                };
                break;
              }
            }
          }

          // Only add if both teleporters were placed successfully
          if (teleporter1 && teleporter2) {
            teleporter1.pairedWith = teleporter2;
            teleporter2.pairedWith = teleporter1;
            obstacles.push(teleporter1);
            obstacles.push(teleporter2);
          }
        }

        // Sort for draw order
        const typeOrder = { water: 0, sand: 1, teleporter: 2, rock: 3, movingRock: 3, tree: 4, windmill: 5 };
        obstacles.sort((a, b) => (typeOrder[a.type] || 0) - (typeOrder[b.type] || 0));

        return obstacles;
      }
    };

    // === ScoreKeeper Module (T022, T033, T057-T063) ===
    const ScoreKeeper = {
      recordStroke(round) {
        round.currentStrokeCount++;
        this.updateUI(round);
      },

      getCurrentStrokes(round) {
        return round.currentStrokeCount;
      },

      completeHole(round, hole) {
        const holeScore = {
          holeNumber: hole.holeNumber,
          strokes: round.currentStrokeCount,
          par: hole.par,
          scoreRelativeToPar: round.currentStrokeCount - hole.par
        };

        round.holeScores.push(holeScore);
        round.totalStrokes += round.currentStrokeCount;
        round.totalPar += hole.par;
        round.scoreRelativeToPar = round.totalStrokes - round.totalPar;

        return holeScore;
      },

      getRoundSummary(round) {
        return {
          totalStrokes: round.totalStrokes,
          totalPar: round.totalPar,
          scoreRelativeToPar: round.scoreRelativeToPar,
          holeScores: round.holeScores,
          completedHoles: round.holeScores.length,
          remainingHoles: 9 - round.holeScores.length
        };
      },

      updateUI(round) {
        document.getElementById('stroke-count').textContent = round.currentStrokeCount;
        document.getElementById('total-score').textContent = this.getScoreDisplay(round.scoreRelativeToPar);
      },

      getScoreDisplay(score) {
        if (score === 0) return 'E';
        if (score > 0) return `+${score}`;
        return `${score}`;
      },

      getScoreColor(scoreRelativeToPar) {
        if (scoreRelativeToPar <= -2) return '#FFD700';
        if (scoreRelativeToPar === -1) return '#4CAF50';
        if (scoreRelativeToPar === 0) return '#2196F3';
        if (scoreRelativeToPar === 1) return '#FF9800';
        return '#F44336';
      },

      getScoreName(scoreRelativeToPar) {
        if (scoreRelativeToPar <= -3) return 'Albatross!';
        if (scoreRelativeToPar === -2) return 'Eagle!';
        if (scoreRelativeToPar === -1) return 'Birdie!';
        if (scoreRelativeToPar === 0) return 'Par';
        if (scoreRelativeToPar === 1) return 'Bogey';
        if (scoreRelativeToPar === 2) return 'Double Bogey';
        return `+${scoreRelativeToPar}`;
      }
    };

    // === ClubSystem Module (T039-T043, T048-T049) ===
    const ClubSystem = {
      clubs: {
        driver: { id: 'driver', name: 'Driver', maxPower: 1.0, arcMultiplier: 1.0, spinMultiplier: 1.0 },
        wood3: { id: 'wood3', name: '3 Wood', maxPower: 0.9, arcMultiplier: 0.95, spinMultiplier: 0.95 },
        wood5: { id: 'wood5', name: '5 Wood', maxPower: 0.85, arcMultiplier: 0.9, spinMultiplier: 0.9 },
        iron4: { id: 'iron4', name: '4 Iron', maxPower: 0.8, arcMultiplier: 0.85, spinMultiplier: 1.1 },
        iron5: { id: 'iron5', name: '5 Iron', maxPower: 0.75, arcMultiplier: 0.8, spinMultiplier: 1.15 },
        iron6: { id: 'iron6', name: '6 Iron', maxPower: 0.7, arcMultiplier: 0.75, spinMultiplier: 1.2 },
        iron7: { id: 'iron7', name: '7 Iron', maxPower: 0.65, arcMultiplier: 0.7, spinMultiplier: 1.25 },
        iron8: { id: 'iron8', name: '8 Iron', maxPower: 0.6, arcMultiplier: 0.65, spinMultiplier: 1.3 },
        iron9: { id: 'iron9', name: '9 Iron', maxPower: 0.55, arcMultiplier: 0.6, spinMultiplier: 1.35 },
        wedge: { id: 'wedge', name: 'Wedge', maxPower: 0.5, arcMultiplier: 0.55, spinMultiplier: 1.5 },
        putter: { id: 'putter', name: 'Putter', maxPower: 0.3, arcMultiplier: 0.0, spinMultiplier: 0.0 }
      },

      getClub(clubId) {
        const baseClub = this.clubs[clubId] || this.clubs.driver;
        // Apply tier multiplier from ShopSystem
        const tierMultiplier = ShopSystem.getTierMultiplier(clubId);
        return {
          ...baseClub,
          maxPower: baseClub.maxPower * tierMultiplier
        };
      },

      // Get base club without tier modifier (for shop display)
      getBaseClub(clubId) {
        return this.clubs[clubId] || this.clubs.driver;
      },

      getAllClubs() {
        return Object.values(this.clubs);
      },

      getAvailableClubs(isFirstStroke) {
        // All clubs available on all shots (including tee shots)
        // On par 3s, players should use irons, not driver
        return this.getAllClubs();
      },

      applyClubToSwing(swingVector, clubId) {
        const club = this.getClub(clubId);
        return {
          power: swingVector.power * club.maxPower,
          angle: swingVector.angle,
          arc: club.arcMultiplier,
          spin: club.spinMultiplier
        };
      },

      getRecommendedClub(ball, holePosition, wind = null, lie = null) {
        // Use CaddieSystem if player has a caddie
        if (CaddieSystem.getOwnedTier() > 0) {
          const recommendation = CaddieSystem.getRecommendation(ball, holePosition, wind, lie);
          // For master tier, recommendation is an object; otherwise it's just a club ID string
          if (typeof recommendation === 'object' && recommendation !== null) {
            return recommendation;
          }
          return recommendation;
        }

        // No caddie - return null (no recommendation shown)
        return null;
      },

      // Calculate max distance for a club at 100% power (in yards)
      getMaxDistance(clubId) {
        const club = this.getClub(clubId);

        // Fixed max distance - driver at 100% = 280 yards
        const targetYards = 280;
        const targetPixels = targetYards * ScreenScale.pixelsPerYard;
        // Same velocity calculation as applySwing
        const maxVelocity = targetPixels * 1.2;

        const friction = 0.98;
        const thresholdYards = 2;
        const stopThreshold = thresholdYards * ScreenScale.pixelsPerYard;
        const deltaTime = 1/60; // 60 FPS

        // Simulate ball flight (in pixels)
        let velocityX = maxVelocity * club.maxPower;
        let distancePixels = 0;

        while (Math.abs(velocityX) > stopThreshold) {
          distancePixels += velocityX * deltaTime;
          velocityX *= friction;
        }

        // Convert pixels to yards using ScreenScale
        return Math.round(distancePixels / ScreenScale.pixelsPerYard);
      }
    };

    // === StorageManager Module (T064-T073) ===
    const StorageManager = {
      dbName: 'CartoonGolfDB',
      dbVersion: 1,
      storeName: 'gameStates',
      db: null,

      async init() {
        return new Promise((resolve, reject) => {
          const request = indexedDB.open(this.dbName, this.dbVersion);

          request.onerror = () => {
            console.error('IndexedDB error:', request.error);
            reject(request.error);
          };

          request.onsuccess = () => {
            this.db = request.result;
            resolve(this.db);
          };

          request.onupgradeneeded = (event) => {
            const db = event.target.result;

            if (!db.objectStoreNames.contains(this.storeName)) {
              const objectStore = db.createObjectStore(this.storeName, { keyPath: 'id' });
              objectStore.createIndex('timestamp', 'timestamp', { unique: false });
            }
          };
        });
      },

      async saveGameState(gameState) {
        try {
          if (!this.db) {
            await this.init();
          }

          const stateToSave = {
            id: 'current-game',
            timestamp: Date.now(),
            gameState: {
              currentHole: gameState.currentHole,
              round: gameState.round,
              ball: {
                x: gameState.ball.x,
                y: gameState.ball.y,
                velocityX: gameState.ball.velocityX,
                velocityY: gameState.ball.velocityY,
                spin: gameState.ball.spin,
                isAirborne: gameState.ball.isAirborne,
                isMoving: gameState.ball.isMoving,
                rotation: gameState.ball.rotation,
                groundY: gameState.ball.groundY,
                holePosition: gameState.ball.holePosition,
                distanceFromHole: gameState.ball.distanceFromHole,
                lastSafePosition: gameState.ball.lastSafePosition,
                waterPenalty: gameState.ball.waterPenalty,
                color: gameState.ball.color
              },
              selectedClub: gameState.selectedClub,
              seed: gameState.seed,
              ballColor: gameState.ballColor
            }
          };

          const transaction = this.db.transaction([this.storeName], 'readwrite');
          const objectStore = transaction.objectStore(this.storeName);
          const request = objectStore.put(stateToSave);

          return new Promise((resolve, reject) => {
            request.onsuccess = () => resolve(true);
            request.onerror = () => {
              console.error('Save error:', request.error);
              reject(request.error);
            };
          });
        } catch (error) {
          console.error('Failed to save game state:', error);
          return false;
        }
      },

      async loadGameState() {
        try {
          if (!this.db) {
            await this.init();
          }

          const transaction = this.db.transaction([this.storeName], 'readonly');
          const objectStore = transaction.objectStore(this.storeName);
          const request = objectStore.get('current-game');

          return new Promise((resolve, reject) => {
            request.onsuccess = () => {
              if (request.result) {
                resolve(request.result.gameState);
              } else {
                resolve(null);
              }
            };
            request.onerror = () => {
              console.error('Load error:', request.error);
              reject(request.error);
            };
          });
        } catch (error) {
          console.error('Failed to load game state:', error);
          return null;
        }
      },

      async clearGameState() {
        try {
          if (!this.db) {
            await this.init();
          }

          const transaction = this.db.transaction([this.storeName], 'readwrite');
          const objectStore = transaction.objectStore(this.storeName);
          const request = objectStore.delete('current-game');

          return new Promise((resolve, reject) => {
            request.onsuccess = () => resolve(true);
            request.onerror = () => {
              console.error('Clear error:', request.error);
              reject(request.error);
            };
          });
        } catch (error) {
          console.error('Failed to clear game state:', error);
          return false;
        }
      },

      async hasSavedGame() {
        try {
          const savedState = await this.loadGameState();
          return savedState !== null && !savedState.round.isComplete;
        } catch (error) {
          console.error('Error checking for saved game:', error);
          return false;
        }
      },

      saveSettings(settings) {
        try {
          localStorage.setItem('golf-settings', JSON.stringify(settings));
          return true;
        } catch (error) {
          console.error('Failed to save settings:', error);
          return false;
        }
      },

      loadSettings() {
        try {
          const settings = localStorage.getItem('golf-settings');
          return settings ? JSON.parse(settings) : this.getDefaultSettings();
        } catch (error) {
          console.error('Failed to load settings:', error);
          return this.getDefaultSettings();
        }
      },

      getDefaultSettings() {
        return {
          soundEnabled: true,
          musicEnabled: true,
          trailsEnabled: true,
          eventsEnabled: true,
          debugMode: false,
          tutorialCompleted: false,
          swingMode: 'easy' // 'easy' or 'pro'
        };
      },

      // === Leaderboard Methods (T074-T076) ===
      async addLeaderboardEntry(entry) {
        try {
          if (!this.db) {
            await this.init();
          }

          const leaderboard = await this.getLeaderboard();

          // Add new entry
          leaderboard.push({
            scoreRelativeToPar: entry.scoreRelativeToPar,
            totalStrokes: entry.totalStrokes,
            completedAt: entry.completedAt || Date.now(),
            playerInitials: entry.playerInitials || 'YOU'
          });

          // Sort by score (lower is better)
          leaderboard.sort((a, b) => a.scoreRelativeToPar - b.scoreRelativeToPar);

          // Keep only top 10
          const top10 = leaderboard.slice(0, 10);

          // Save to IndexedDB
          const transaction = this.db.transaction([this.storeName], 'readwrite');
          const objectStore = transaction.objectStore(this.storeName);
          const request = objectStore.put({
            id: 'leaderboard',
            entries: top10,
            timestamp: Date.now()
          });

          return new Promise((resolve, reject) => {
            request.onsuccess = () => resolve(top10);
            request.onerror = () => {
              console.error('Leaderboard save error:', request.error);
              reject(request.error);
            };
          });
        } catch (error) {
          console.error('Failed to add leaderboard entry:', error);
          return [];
        }
      },

      async getLeaderboard() {
        try {
          if (!this.db) {
            await this.init();
          }

          const transaction = this.db.transaction([this.storeName], 'readonly');
          const objectStore = transaction.objectStore(this.storeName);
          const request = objectStore.get('leaderboard');

          return new Promise((resolve, reject) => {
            request.onsuccess = () => {
              if (request.result && request.result.entries) {
                resolve(request.result.entries);
              } else {
                resolve([]);
              }
            };
            request.onerror = () => {
              console.error('Leaderboard load error:', request.error);
              reject(request.error);
            };
          });
        } catch (error) {
          console.error('Failed to load leaderboard:', error);
          return [];
        }
      }
    };

    // === AudioManager Module (T073f, T073g) ===
    const AudioManager = {
      context: null,
      sounds: {},
      muted: false,
      musicPlaying: false,
      musicGain: null,
      musicNodes: [],

      init() {
        try {
          this.context = new (window.AudioContext || window.webkitAudioContext)();
          this.muted = StorageManager.loadSettings().soundEnabled === false;
        } catch (error) {
          console.error('Web Audio API not supported:', error);
        }
      },

      unlock() {
        if (!this.context) return;

        if (this.context.state === 'suspended') {
          this.context.resume();
        }

        const buffer = this.context.createBuffer(1, 1, 22050);
        const source = this.context.createBufferSource();
        source.buffer = buffer;
        source.connect(this.context.destination);
        source.start(0);
      },

      // Background music - chill golf course ambience
      startBackgroundMusic() {
        // Check both muted state and musicEnabled setting
        const settings = StorageManager.loadSettings();
        if (this.muted || settings.musicEnabled === false || !this.context || this.musicPlaying) return;

        this.musicPlaying = true;

        // Create master gain for music
        this.musicGain = this.context.createGain();
        this.musicGain.gain.value = 0.08; // Quiet background
        this.musicGain.connect(this.context.destination);

        // Peaceful chord progression (C - Am - F - G)
        const chords = [
          [261.63, 329.63, 392.00], // C major
          [220.00, 261.63, 329.63], // A minor
          [174.61, 220.00, 261.63], // F major
          [196.00, 246.94, 293.66]  // G major
        ];

        let chordIndex = 0;

        const playChord = () => {
          if (!this.musicPlaying || this.muted) return;

          const chord = chords[chordIndex];
          const now = this.context.currentTime;

          chord.forEach((freq, i) => {
            const osc = this.context.createOscillator();
            const gain = this.context.createGain();

            osc.type = 'sine';
            osc.frequency.value = freq;

            gain.gain.setValueAtTime(0, now);
            gain.gain.linearRampToValueAtTime(0.3, now + 0.3);
            gain.gain.linearRampToValueAtTime(0.15, now + 1.5);
            gain.gain.linearRampToValueAtTime(0, now + 2.8);

            osc.connect(gain);
            gain.connect(this.musicGain);

            osc.start(now);
            osc.stop(now + 3);

            this.musicNodes.push(osc);
          });

          chordIndex = (chordIndex + 1) % chords.length;

          // Schedule next chord
          this.musicTimeout = setTimeout(playChord, 3000);
        };

        // Add ambient bird chirps
        const playBird = () => {
          if (!this.musicPlaying || this.muted) return;

          const now = this.context.currentTime;
          const osc = this.context.createOscillator();
          const gain = this.context.createGain();

          osc.type = 'sine';
          const baseFreq = 1800 + Math.random() * 800;

          osc.frequency.setValueAtTime(baseFreq, now);
          osc.frequency.linearRampToValueAtTime(baseFreq * 1.2, now + 0.05);
          osc.frequency.linearRampToValueAtTime(baseFreq * 0.9, now + 0.1);

          gain.gain.setValueAtTime(0, now);
          gain.gain.linearRampToValueAtTime(0.03, now + 0.02);
          gain.gain.linearRampToValueAtTime(0, now + 0.15);

          osc.connect(gain);
          gain.connect(this.musicGain);

          osc.start(now);
          osc.stop(now + 0.2);

          // Random interval for next bird
          this.birdTimeout = setTimeout(playBird, 4000 + Math.random() * 8000);
        };

        playChord();
        setTimeout(playBird, 2000);
      },

      stopBackgroundMusic() {
        this.musicPlaying = false;
        if (this.musicTimeout) clearTimeout(this.musicTimeout);
        if (this.birdTimeout) clearTimeout(this.birdTimeout);
        this.musicNodes.forEach(node => {
          try { node.stop(); } catch (e) {}
        });
        this.musicNodes = [];
      },

      // === T096: Enhanced club hit sounds ===
      playHitSound(power) {
        if (this.muted || !this.context) return;

        const oscillator = this.context.createOscillator();
        const gainNode = this.context.createGain();

        oscillator.connect(gainNode);
        gainNode.connect(this.context.destination);

        // Soft, medium, hard hit sounds based on power
        let frequency, volume, duration;
        if (power < 0.3) {
          frequency = 180;
          volume = 0.08;
          duration = 0.04;
        } else if (power < 0.6) {
          frequency = 280;
          volume = 0.15;
          duration = 0.06;
        } else {
          frequency = 380;
          volume = 0.22;
          duration = 0.08;
        }

        oscillator.frequency.value = frequency;
        oscillator.type = 'sine';

        gainNode.gain.setValueAtTime(volume, this.context.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, this.context.currentTime + duration);

        oscillator.start(this.context.currentTime);
        oscillator.stop(this.context.currentTime + duration);
      },

      // === T097: Landing sounds based on surface ===
      playLandSound(surfaceType = 'grass') {
        if (this.muted || !this.context) return;

        const oscillator = this.context.createOscillator();
        const gainNode = this.context.createGain();

        oscillator.connect(gainNode);
        gainNode.connect(this.context.destination);

        let frequency, duration, volume;
        switch (surfaceType) {
          case 'sand':
            frequency = 120;
            duration = 0.15;
            volume = 0.12;
            break;
          case 'water':
            frequency = 200;
            duration = 0.2;
            volume = 0.18;
            oscillator.type = 'triangle';
            break;
          case 'grass':
          default:
            frequency = 150;
            duration = 0.08;
            volume = 0.1;
            break;
        }

        oscillator.frequency.value = frequency;
        if (surfaceType !== 'water') oscillator.type = 'sine';

        gainNode.gain.setValueAtTime(volume, this.context.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, this.context.currentTime + duration);

        oscillator.start(this.context.currentTime);
        oscillator.stop(this.context.currentTime + duration);
      },

      // === T098: Cheer sound for exceptional shots ===
      playCheerSound() {
        if (this.muted || !this.context) return;

        // Play a rising three-note cheer
        const notes = [523.25, 659.25, 783.99]; // C5, E5, G5
        notes.forEach((freq, i) => {
          setTimeout(() => {
            const osc = this.context.createOscillator();
            const gain = this.context.createGain();
            osc.connect(gain);
            gain.connect(this.context.destination);
            osc.frequency.value = freq;
            osc.type = 'sine';
            gain.gain.setValueAtTime(0.15, this.context.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, this.context.currentTime + 0.3);
            osc.start(this.context.currentTime);
            osc.stop(this.context.currentTime + 0.3);
          }, i * 100);
        });
      },

      // UI click sound for menu buttons
      playClickSound() {
        if (this.muted || !this.context) return;

        const oscillator = this.context.createOscillator();
        const gainNode = this.context.createGain();

        oscillator.connect(gainNode);
        gainNode.connect(this.context.destination);

        // Short, snappy click
        oscillator.frequency.value = 800;
        oscillator.type = 'sine';

        gainNode.gain.setValueAtTime(0.15, this.context.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, this.context.currentTime + 0.05);

        oscillator.start(this.context.currentTime);
        oscillator.stop(this.context.currentTime + 0.05);
      },

      // Achievement unlock sound - triumphant fanfare
      playAchievement() {
        if (this.muted || !this.context) return;

        // Play a triumphant 3-note fanfare
        const notes = [523.25, 659.25, 783.99]; // C5, E5, G5
        const durations = [0.15, 0.15, 0.4];
        let startTime = this.context.currentTime;

        notes.forEach((freq, i) => {
          const osc = this.context.createOscillator();
          const gain = this.context.createGain();

          osc.connect(gain);
          gain.connect(this.context.destination);

          osc.frequency.value = freq;
          osc.type = 'triangle';

          gain.gain.setValueAtTime(0.25, startTime);
          gain.gain.exponentialRampToValueAtTime(0.01, startTime + durations[i]);

          osc.start(startTime);
          osc.stop(startTime + durations[i]);

          startTime += durations[i] * 0.7; // Slight overlap
        });
      },

      // === T099: Hole completion jingle ===
      playHoleSound() {
        if (this.muted || !this.context) return;

        const oscillator = this.context.createOscillator();
        const gainNode = this.context.createGain();

        oscillator.connect(gainNode);
        gainNode.connect(this.context.destination);

        oscillator.frequency.value = 523.25;
        oscillator.type = 'sine';

        gainNode.gain.setValueAtTime(0.2, this.context.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, this.context.currentTime + 0.3);

        oscillator.start(this.context.currentTime);
        oscillator.stop(this.context.currentTime + 0.3);

        setTimeout(() => {
          const osc2 = this.context.createOscillator();
          const gain2 = this.context.createGain();
          osc2.connect(gain2);
          gain2.connect(this.context.destination);
          osc2.frequency.value = 659.25;
          osc2.type = 'sine';
          gain2.gain.setValueAtTime(0.2, this.context.currentTime);
          gain2.gain.exponentialRampToValueAtTime(0.01, this.context.currentTime + 0.3);
          osc2.start(this.context.currentTime);
          osc2.stop(this.context.currentTime + 0.3);
        }, 150);
      },

      playStreakerSound() {
        if (this.muted || !this.context) return;

        // Create a funny "AAAHHHH!" scream sound
        const duration = 1.2;
        const now = this.context.currentTime;

        // Main scream oscillator - starts high, wobbles
        const screamOsc = this.context.createOscillator();
        const screamGain = this.context.createGain();
        const vibrato = this.context.createOscillator();
        const vibratoGain = this.context.createGain();

        // Vibrato for wobbly scream effect
        vibrato.frequency.value = 12; // Fast wobble
        vibratoGain.gain.value = 50; // Amount of pitch wobble
        vibrato.connect(vibratoGain);
        vibratoGain.connect(screamOsc.frequency);

        screamOsc.connect(screamGain);
        screamGain.connect(this.context.destination);

        // Scream starts high and drops slightly
        screamOsc.frequency.setValueAtTime(800, now);
        screamOsc.frequency.linearRampToValueAtTime(600, now + 0.3);
        screamOsc.frequency.linearRampToValueAtTime(700, now + 0.6);
        screamOsc.frequency.linearRampToValueAtTime(500, now + duration);

        screamOsc.type = 'sawtooth'; // Harsh, scream-like

        // Volume envelope - loud start, sustain, fade
        screamGain.gain.setValueAtTime(0, now);
        screamGain.gain.linearRampToValueAtTime(0.15, now + 0.05);
        screamGain.gain.setValueAtTime(0.12, now + 0.3);
        screamGain.gain.linearRampToValueAtTime(0.08, now + 0.8);
        screamGain.gain.exponentialRampToValueAtTime(0.01, now + duration);

        vibrato.start(now);
        screamOsc.start(now);
        vibrato.stop(now + duration);
        screamOsc.stop(now + duration);

        // Add a second higher harmonic for more "voice" quality
        const harmonic = this.context.createOscillator();
        const harmonicGain = this.context.createGain();
        harmonic.connect(harmonicGain);
        harmonicGain.connect(this.context.destination);

        harmonic.frequency.setValueAtTime(1200, now);
        harmonic.frequency.linearRampToValueAtTime(900, now + 0.3);
        harmonic.frequency.linearRampToValueAtTime(1000, now + duration);
        harmonic.type = 'sine';

        harmonicGain.gain.setValueAtTime(0, now);
        harmonicGain.gain.linearRampToValueAtTime(0.05, now + 0.05);
        harmonicGain.gain.exponentialRampToValueAtTime(0.01, now + duration);

        harmonic.start(now);
        harmonic.stop(now + duration);
      },

      // === Crowd ambient noise and reactions ===
      crowdAmbienceGain: null,
      crowdAmbienceNodes: [],
      crowdAmbiencePlaying: false,

      startCrowdAmbience() {
        const settings = StorageManager.loadSettings();
        if (this.muted || settings.musicEnabled === false || !this.context || this.crowdAmbiencePlaying) return;

        this.crowdAmbiencePlaying = true;

        // Create gain node for crowd ambience
        this.crowdAmbienceGain = this.context.createGain();
        this.crowdAmbienceGain.gain.value = 0.015;  // Very quiet background
        this.crowdAmbienceGain.connect(this.context.destination);

        // Generate soft crowd murmur using filtered noise
        const playMurmur = () => {
          if (!this.crowdAmbiencePlaying || this.muted) return;

          // Create noise buffer
          const bufferSize = this.context.sampleRate * 2;
          const noiseBuffer = this.context.createBuffer(1, bufferSize, this.context.sampleRate);
          const output = noiseBuffer.getChannelData(0);

          for (let i = 0; i < bufferSize; i++) {
            output[i] = Math.random() * 2 - 1;
          }

          const noise = this.context.createBufferSource();
          noise.buffer = noiseBuffer;

          // Low-pass filter for muffled crowd sound
          const filter = this.context.createBiquadFilter();
          filter.type = 'lowpass';
          filter.frequency.value = 300;
          filter.Q.value = 1;

          // Gentle volume envelope
          const gain = this.context.createGain();
          const now = this.context.currentTime;
          gain.gain.setValueAtTime(0, now);
          gain.gain.linearRampToValueAtTime(1, now + 0.5);
          gain.gain.setValueAtTime(1, now + 1.5);
          gain.gain.linearRampToValueAtTime(0, now + 2);

          noise.connect(filter);
          filter.connect(gain);
          gain.connect(this.crowdAmbienceGain);

          noise.start(now);
          noise.stop(now + 2);

          this.crowdAmbienceNodes.push(noise);

          // Schedule next murmur
          this.crowdMurmurTimeout = setTimeout(playMurmur, 3000 + Math.random() * 4000);
        };

        // Occasional cough or sneeze sound
        const playRandomSound = () => {
          if (!this.crowdAmbiencePlaying || this.muted) return;

          const now = this.context.currentTime;
          const osc = this.context.createOscillator();
          const gain = this.context.createGain();

          // Random cough-like sound
          osc.type = 'sine';
          osc.frequency.setValueAtTime(200 + Math.random() * 100, now);
          osc.frequency.exponentialRampToValueAtTime(80, now + 0.1);

          gain.gain.setValueAtTime(0, now);
          gain.gain.linearRampToValueAtTime(0.03, now + 0.02);
          gain.gain.exponentialRampToValueAtTime(0.001, now + 0.15);

          osc.connect(gain);
          gain.connect(this.crowdAmbienceGain);

          osc.start(now);
          osc.stop(now + 0.2);

          this.crowdRandomTimeout = setTimeout(playRandomSound, 8000 + Math.random() * 15000);
        };

        playMurmur();
        setTimeout(playRandomSound, 5000);
      },

      stopCrowdAmbience() {
        this.crowdAmbiencePlaying = false;
        if (this.crowdMurmurTimeout) clearTimeout(this.crowdMurmurTimeout);
        if (this.crowdRandomTimeout) clearTimeout(this.crowdRandomTimeout);
        this.crowdAmbienceNodes.forEach(node => {
          try { node.stop(); } catch (e) {}
        });
        this.crowdAmbienceNodes = [];
      },

      // Crowd cheer for great shots
      playCrowdCheer() {
        if (this.muted || !this.context) return;

        const now = this.context.currentTime;

        // Multiple voices cheering
        for (let i = 0; i < 5; i++) {
          const osc = this.context.createOscillator();
          const gain = this.context.createGain();
          const filter = this.context.createBiquadFilter();

          // Randomized cheer frequencies
          const baseFreq = 200 + Math.random() * 150;
          osc.type = 'sawtooth';
          osc.frequency.setValueAtTime(baseFreq, now);
          osc.frequency.linearRampToValueAtTime(baseFreq * 1.3, now + 0.2);
          osc.frequency.linearRampToValueAtTime(baseFreq * 1.1, now + 0.5);

          filter.type = 'lowpass';
          filter.frequency.value = 800;

          gain.gain.setValueAtTime(0, now);
          gain.gain.linearRampToValueAtTime(0.04, now + 0.05);
          gain.gain.setValueAtTime(0.04, now + 0.3);
          gain.gain.exponentialRampToValueAtTime(0.001, now + 0.6);

          osc.connect(filter);
          filter.connect(gain);
          gain.connect(this.context.destination);

          osc.start(now + Math.random() * 0.1);
          osc.stop(now + 0.7);
        }
      },

      // Crowd gasp for bad shots (water, sand)
      playCrowdGasp() {
        if (this.muted || !this.context) return;

        const now = this.context.currentTime;

        // Quick inhale sound
        for (let i = 0; i < 3; i++) {
          const osc = this.context.createOscillator();
          const gain = this.context.createGain();
          const filter = this.context.createBiquadFilter();

          osc.type = 'sine';
          osc.frequency.setValueAtTime(400 + Math.random() * 200, now);
          osc.frequency.linearRampToValueAtTime(250, now + 0.15);

          filter.type = 'lowpass';
          filter.frequency.value = 600;

          gain.gain.setValueAtTime(0, now);
          gain.gain.linearRampToValueAtTime(0.03, now + 0.03);
          gain.gain.exponentialRampToValueAtTime(0.001, now + 0.2);

          osc.connect(filter);
          filter.connect(gain);
          gain.connect(this.context.destination);

          osc.start(now + Math.random() * 0.05);
          osc.stop(now + 0.25);
        }
      },

      // Polite applause for holing out
      playCrowdClap() {
        if (this.muted || !this.context) return;

        const now = this.context.currentTime;

        // Generate clapping sounds
        for (let c = 0; c < 8; c++) {
          const startTime = now + c * 0.12 + Math.random() * 0.05;

          // Each clap is filtered noise burst
          const bufferSize = this.context.sampleRate * 0.05;
          const buffer = this.context.createBuffer(1, bufferSize, this.context.sampleRate);
          const data = buffer.getChannelData(0);
          for (let i = 0; i < bufferSize; i++) {
            data[i] = Math.random() * 2 - 1;
          }

          const source = this.context.createBufferSource();
          source.buffer = buffer;

          const filter = this.context.createBiquadFilter();
          filter.type = 'bandpass';
          filter.frequency.value = 2000 + Math.random() * 1000;
          filter.Q.value = 2;

          const gain = this.context.createGain();
          gain.gain.setValueAtTime(0.08, startTime);
          gain.gain.exponentialRampToValueAtTime(0.001, startTime + 0.05);

          source.connect(filter);
          filter.connect(gain);
          gain.connect(this.context.destination);

          source.start(startTime);
          source.stop(startTime + 0.05);
        }
      },

      // === T094, T100: Mute toggle ===
      setMuted(muted) {
        this.muted = muted;
        const settings = StorageManager.loadSettings();
        settings.soundEnabled = !muted;
        StorageManager.saveSettings(settings);
      }
    };

    // === Announcer Module: Voice commentary system ===
    const Announcer = {
      synth: window.speechSynthesis,
      voice: null,
      enabled: false, // Disabled for now
      queue: [],
      speaking: false,
      unlocked: false,

      init() {
        if (!this.synth) {
          console.warn('Speech synthesis not supported');
          return;
        }
        // Wait for voices to load
        if (this.synth.getVoices().length === 0) {
          this.synth.addEventListener('voiceschanged', () => this.selectVoice());
        } else {
          this.selectVoice();
        }

        // Unlock speech synthesis on first user interaction
        const unlockHandler = () => {
          this.unlock();
          document.removeEventListener('click', unlockHandler);
          document.removeEventListener('touchstart', unlockHandler);
        };
        document.addEventListener('click', unlockHandler);
        document.addEventListener('touchstart', unlockHandler);
      },

      unlock() {
        if (this.unlocked || !this.synth) return;
        // Speak a silent utterance to unlock
        const utterance = new SpeechSynthesisUtterance('');
        utterance.volume = 0;
        this.synth.speak(utterance);
        this.unlocked = true;
        console.log('Speech synthesis unlocked');
      },

      selectVoice() {
        const voices = this.synth.getVoices();
        // Prefer a male English voice for announcer feel
        this.voice = voices.find(v => v.lang.startsWith('en') && v.name.toLowerCase().includes('male')) ||
                     voices.find(v => v.lang.startsWith('en-US')) ||
                     voices.find(v => v.lang.startsWith('en')) ||
                     voices[0];
      },

      speak(text, options = {}) {
        if (!this.synth || !this.enabled || AudioManager.muted) return;

        // Resume if paused (browser can pause speech)
        if (this.synth.paused) {
          this.synth.resume();
        }

        const utterance = new SpeechSynthesisUtterance(text);
        utterance.voice = this.voice;
        utterance.rate = options.rate || 1.0;
        utterance.pitch = options.pitch || 1.0;
        utterance.volume = options.volume || 0.9;

        // Queue management
        utterance.onend = () => {
          this.speaking = false;
          this.processQueue();
        };
        utterance.onerror = () => {
          this.speaking = false;
          this.processQueue();
        };

        if (options.immediate || !this.speaking) {
          if (options.immediate) {
            this.synth.cancel(); // Clear queue for immediate announcements
          }
          this.speaking = true;
          this.synth.speak(utterance);
        } else {
          this.queue.push(utterance);
        }
      },

      processQueue() {
        if (this.queue.length > 0 && !this.speaking) {
          this.speaking = true;
          this.synth.speak(this.queue.shift());
        }
      },

      // Pre-defined announcements
      announceOnTee(playerName) {
        const intros = [
          `Next on the tee, ${playerName}`,
          `Now playing, ${playerName}`,
          `On the tee, ${playerName}`,
          `Please welcome to the tee, ${playerName}`
        ];
        const intro = intros[Math.floor(Math.random() * intros.length)];
        this.speak(intro, { rate: 0.9, pitch: 0.9 });
      },

      announceShot(type, distance) {
        const comments = {
          great_drive: [
            'What a drive!',
            'Crushed it!',
            'That ball is gone!',
            'Absolutely smashed!',
            'A monster drive!'
          ],
          good_shot: [
            'Nice shot!',
            'Well played!',
            'Good swing!',
            'That\'ll play!'
          ],
          close_to_pin: [
            'That\'s close!',
            'Pin high!',
            'Looking at birdie!',
            'What a shot!'
          ],
          in_hole: [
            'It\'s in the hole!',
            'Get in there! Yes!',
            'Down it goes!',
            'What a putt!'
          ],
          hole_in_one: [
            'HOLE IN ONE! Unbelievable!',
            'ACE! What a shot!',
            'IT WENT IN! A hole in one!',
            'Incredible! A hole in one!'
          ],
          eagle: [
            'Eagle! What a score!',
            'That\'s an eagle!',
            'Two under par! Incredible!'
          ],
          birdie: [
            'Birdie!',
            'One under!',
            'Nice birdie!'
          ],
          water: [
            'Oh no, it found the water!',
            'That\'s wet!',
            'In the drink!'
          ],
          bunker: [
            'That\'s found the bunker',
            'Sandy lie ahead',
            'Beach time!'
          ]
        };

        const phrases = comments[type];
        if (phrases) {
          const phrase = phrases[Math.floor(Math.random() * phrases.length)];
          this.speak(phrase, { rate: 1.1, pitch: 1.0 });
        }
      },

      announceHole(holeNumber, par) {
        this.speak(`Hole ${holeNumber}. Par ${par}.`, { rate: 0.95 });
      },

      announceRivalry(rivalName, message) {
        this.speak(`${rivalName} says: ${message}`, { rate: 1.0, pitch: 0.85 });
      },

      announcePressure(message) {
        this.speak(message, { rate: 0.85, pitch: 0.9 });
      },

      setEnabled(enabled) {
        this.enabled = enabled;
        if (!enabled) {
          this.synth?.cancel();
          this.queue = [];
        }
      }
    };

    // === ConfettiSystem Module (T102-T105: Visual Polish) ===
    const ConfettiSystem = {
      particles: [],

      // Color palettes for different score types
      colors: {
        standard: ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7', '#DDA0DD'],
        birdie: ['#4CAF50', '#8BC34A', '#CDDC39', '#FFD700'],
        eagle: ['#FFD700', '#FFA500', '#FF6347', '#FF69B4', '#9370DB', '#00CED1']
      },

      spawn(x, y, count, colorPalette = 'standard') {
        const palette = this.colors[colorPalette] || this.colors.standard;

        for (let i = 0; i < count; i++) {
          const angle = (Math.PI * 2 * i / count) + (Math.random() - 0.5) * 0.5;
          const speed = 150 + Math.random() * 200;

          this.particles.push({
            x: x,
            y: y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed - 100, // Bias upward
            rotation: Math.random() * Math.PI * 2,
            rotationSpeed: (Math.random() - 0.5) * 10,
            color: palette[Math.floor(Math.random() * palette.length)],
            size: 4 + Math.random() * 6,
            life: 1.0, // 1.0 = full life, 0 = dead
            gravity: 300
          });
        }
      },

      update(deltaTime) {
        for (let i = this.particles.length - 1; i >= 0; i--) {
          const p = this.particles[i];

          // Apply physics
          p.vy += p.gravity * deltaTime;
          p.x += p.vx * deltaTime;
          p.y += p.vy * deltaTime;
          p.rotation += p.rotationSpeed * deltaTime;

          // Apply drag
          p.vx *= 0.99;
          p.vy *= 0.99;

          // Decay life
          p.life -= deltaTime * 0.5;

          // Remove dead particles
          if (p.life <= 0) {
            this.particles.splice(i, 1);
          }
        }
      },

      draw(ctx) {
        for (const p of this.particles) {
          ctx.save();
          ctx.translate(p.x, p.y);
          ctx.rotate(p.rotation);
          ctx.globalAlpha = Math.min(p.life, 1);
          ctx.fillStyle = p.color;
          ctx.fillRect(-p.size / 2, -p.size / 4, p.size, p.size / 2);
          ctx.restore();
        }
      },

      clear() {
        this.particles = [];
      }
    };

    // === MailboxManager Module ===
    const MailboxManager = {
      notifications: [],
      maxNotifications: 50,
      storageKey: 'golf-mailbox',

      init() {
        this.load();
        this.updateBadge();
      },

      load() {
        try {
          const data = localStorage.getItem(this.storageKey);
          if (data) {
            this.notifications = JSON.parse(data);
          }
        } catch (e) {
          console.error('Failed to load mailbox:', e);
          this.notifications = [];
        }
      },

      save() {
        try {
          localStorage.setItem(this.storageKey, JSON.stringify(this.notifications));
        } catch (e) {
          console.error('Failed to save mailbox:', e);
        }
      },

      addNotification(type, title, message, data = null) {
        const notification = {
          id: Date.now().toString(),
          type: type, // 'earnings', 'achievement', 'tournament', 'unlock', 'general'
          title: title,
          message: message,
          timestamp: Date.now(),
          read: false,
          data: data
        };

        this.notifications.unshift(notification);

        // Limit stored notifications
        if (this.notifications.length > this.maxNotifications) {
          this.notifications = this.notifications.slice(0, this.maxNotifications);
        }

        this.save();
        this.updateBadge();
      },

      markAsRead(id) {
        const notification = this.notifications.find(n => n.id === id);
        if (notification && !notification.read) {
          notification.read = true;
          this.save();
          this.updateBadge();
        }
      },

      markAllAsRead() {
        let changed = false;
        for (const n of this.notifications) {
          if (!n.read) {
            n.read = true;
            changed = true;
          }
        }
        if (changed) {
          this.save();
          this.updateBadge();
        }
      },

      getUnreadCount() {
        return this.notifications.filter(n => !n.read).length;
      },

      updateBadge() {
        const badge = document.getElementById('mailbox-badge');
        if (!badge) return;

        const count = this.getUnreadCount();
        if (count > 0) {
          badge.textContent = count > 99 ? '99+' : count;
          badge.classList.remove('hidden');
        } else {
          badge.classList.add('hidden');
        }
      },

      formatTimestamp(timestamp) {
        const now = Date.now();
        const diff = now - timestamp;
        const minutes = Math.floor(diff / 60000);
        const hours = Math.floor(diff / 3600000);
        const days = Math.floor(diff / 86400000);

        if (minutes < 1) return 'Just now';
        if (minutes < 60) return `${minutes}m ago`;
        if (hours < 24) return `${hours}h ago`;
        if (days < 7) return `${days}d ago`;
        return new Date(timestamp).toLocaleDateString();
      },

      getTypeIcon(type) {
        switch (type) {
          case 'earnings': return 'ðŸ’°';
          case 'achievement': return 'ðŸ†';
          case 'tournament': return 'ðŸ…';
          case 'round': return 'â›³';
          case 'unlock': return 'ðŸ”“';
          default: return 'ðŸ“¬';
        }
      },

      renderMailbox() {
        const container = document.getElementById('mailbox-content');
        if (!container) return;

        if (this.notifications.length === 0) {
          container.innerHTML = '<div class="notification-empty">No notifications yet.<br>Play to earn Golf Bucks and achievements!</div>';
          return;
        }

        container.innerHTML = this.notifications.map(n => {
          const icon = this.getTypeIcon(n.type);
          const timeStr = this.formatTimestamp(n.timestamp);
          let html = `
            <div class="notification-item ${n.read ? '' : 'unread'}" data-id="${n.id}">
              <div class="notification-header">
                <span class="notification-type">${icon} ${n.type}</span>
                <span class="notification-timestamp">${timeStr}</span>
              </div>
              <div class="notification-title">${n.title}</div>
              <div class="notification-message">${n.message}</div>
          `;

          // Add View Leaderboard button for tournament results
          if (n.type === 'tournament' && n.data && n.data.leaderboard) {
            html += `<button class="mailbox-view-btn" data-action="leaderboard" data-id="${n.id}">ðŸ“Š View Leaderboard</button>`;
          }

          // Add View Scorecard button for round completions
          if (n.type === 'round' && n.data && n.data.holeScores) {
            html += `<button class="mailbox-view-btn" data-action="scorecard" data-id="${n.id}">ðŸ“‹ View Scorecard</button>`;
          }

          html += '</div>';
          return html;
        }).join('');

        // Add click handlers for view buttons
        container.querySelectorAll('.mailbox-view-btn').forEach(btn => {
          btn.addEventListener('click', (e) => {
            e.stopPropagation();
            const action = btn.dataset.action;
            const id = btn.dataset.id;
            const notification = this.notifications.find(n => n.id === id);
            if (!notification) return;

            if (action === 'leaderboard') {
              this.showLeaderboardOverlay(notification.data);
            } else if (action === 'scorecard') {
              this.showScorecardOverlay(notification.data);
            }
          });
        });
      },

      showScorecardOverlay(data) {
        let tableHTML = '<table class="scorecard-table">';
        tableHTML += '<tr><th>Hole</th><th>Par</th><th>Strokes</th><th>Score</th></tr>';

        for (const holeScore of data.holeScores) {
          const scoreDisplay = ScoreKeeper.getScoreDisplay(holeScore.scoreRelativeToPar);
          const scoreClass = holeScore.scoreRelativeToPar < 0 ? 'under-par' :
                            holeScore.scoreRelativeToPar > 0 ? 'over-par' : 'par';

          tableHTML += `<tr>`;
          tableHTML += `<td>${holeScore.holeNumber}</td>`;
          tableHTML += `<td>${holeScore.par}</td>`;
          tableHTML += `<td>${holeScore.strokes}</td>`;
          tableHTML += `<td class="${scoreClass}">${scoreDisplay}</td>`;
          tableHTML += `</tr>`;
        }

        tableHTML += '</table>';
        tableHTML += `<div style="margin-top: 20px; font-size: 18px;">`;
        tableHTML += `<strong>Total Strokes:</strong> ${data.totalStrokes}<br>`;
        tableHTML += `<strong>Total Par:</strong> ${data.totalPar}<br>`;
        tableHTML += `<strong>Final Score:</strong> <span style="color: ${ScoreKeeper.getScoreColor(data.scoreRelativeToPar)}; font-weight: bold; font-size: 24px;">${ScoreKeeper.getScoreDisplay(data.scoreRelativeToPar)}</span>`;
        tableHTML += `</div>`;

        document.getElementById('scorecard-content').innerHTML = tableHTML;
        document.getElementById('scorecard-overlay').classList.remove('hidden');
      },

      showLeaderboardOverlay(data) {
        let html = `<h3 style="color: #FFD700; margin-bottom: 15px;">ðŸ† ${data.tournamentName || 'Tournament'} Leaderboard</h3>`;
        html += '<div class="tournament-leaderboard-embed" style="max-height: 400px; overflow-y: auto;">';

        data.leaderboard.forEach((entry, i) => {
          const scoreText = entry.score === 0 ? 'E' : (entry.score > 0 ? '+' + entry.score : entry.score);
          const positionClass = i === 0 ? 'gold' : i === 1 ? 'silver' : i === 2 ? 'bronze' : '';
          html += `<div class="leaderboard-entry ${entry.isPlayer ? 'player' : ''} ${positionClass}" style="display: flex; justify-content: space-between; padding: 8px; margin: 4px 0; background: ${entry.isPlayer ? 'rgba(76, 175, 80, 0.3)' : 'rgba(255,255,255,0.1)'}; border-radius: 4px;">
            <span>${i + 1}. ${entry.name}</span>
            <span style="font-weight: bold;">${scoreText}</span>
          </div>`;
        });

        html += '</div>';

        if (data.position && data.prize !== undefined) {
          html += `<div style="margin-top: 15px; text-align: center;">`;
          html += `<div style="font-size: 18px;">Your Position: <strong>${data.position}${data.position === 1 ? 'st' : data.position === 2 ? 'nd' : data.position === 3 ? 'rd' : 'th'}</strong></div>`;
          if (data.prize > 0) {
            html += `<div style="color: #4CAF50; font-size: 16px;">Prize Won: +${data.prize} Golf Bucks</div>`;
          }
          html += `</div>`;
        }

        document.getElementById('scorecard-content').innerHTML = html;
        document.getElementById('scorecard-overlay').classList.remove('hidden');
      }
    };

    // === Caddie AI System ===
    const CaddieSystem = {
      ownedTier: 0,  // 0=none, 1=rookie, 2=pro, 3=master
      storageKey: 'golf-caddie',

      tiers: [
        { name: 'Rookie Caddie', cost: 2000, icon: 'ðŸ§¢', desc: 'Basic distance recommendations' },
        { name: 'Pro Caddie', cost: 3000, icon: 'ðŸŽ©', desc: 'Accounts for lie penalties' },
        { name: 'Master Caddie', cost: 5000, icon: 'ðŸ‘‘', desc: 'Full analysis with wind' }
      ],

      init() {
        this.load();
      },

      load() {
        const data = localStorage.getItem(this.storageKey);
        if (data) {
          try {
            const parsed = JSON.parse(data);
            this.ownedTier = parsed.ownedTier || 0;
          } catch (e) {
            console.error('Failed to load caddie data:', e);
            this.ownedTier = 0;
          }
        }
      },

      save() {
        localStorage.setItem(this.storageKey, JSON.stringify({
          ownedTier: this.ownedTier
        }));
      },

      getOwnedTier() {
        return this.ownedTier;
      },

      canPurchase(tierIndex) {
        // Must purchase in order (0 -> 1 -> 2 -> 3)
        // tierIndex is 0-based (0=rookie, 1=pro, 2=master)
        const requiredTier = tierIndex; // To buy tier 1, need tier 0; to buy tier 2, need tier 1
        if (this.ownedTier !== requiredTier) return false;
        return ShopSystem.canAfford(this.tiers[tierIndex].cost);
      },

      purchase(tierIndex) {
        if (!this.canPurchase(tierIndex)) return false;
        const tier = this.tiers[tierIndex];
        if (ShopSystem.spendBucks(tier.cost)) {
          this.ownedTier = tierIndex + 1;
          this.save();
          ShopSystem.showUpgradePopup(`${tier.icon} ${tier.name}`, `You hired a ${tier.name}!`);
          AchievementManager.onShopPurchase(tier.cost);
          return true;
        }
        return false;
      },

      // Get club recommendation based on owned caddie tier
      getRecommendation(ball, holePosition, wind, lie) {
        if (this.ownedTier === 0) return null;

        // Calculate base distance
        const pixelDistance = PhysicsEngine.distance(ball, holePosition);
        const baseDistance = pixelDistance * PIXELS_TO_YARDS;
        let effectiveDistance = baseDistance;

        // Tier 2+: Account for lie penalties
        if (this.ownedTier >= 2) {
          if (lie === 'sand') {
            effectiveDistance *= 2; // 50% power means need 2x distance club
          } else if (lie === 'rough') {
            effectiveDistance *= 1.25; // 80% power
          }
        }

        // Tier 3: Account for wind
        if (this.ownedTier >= 3 && wind) {
          // Wind adjustment - headwind increases needed distance, tailwind decreases
          const windAngle = Math.atan2(holePosition.y - ball.y, holePosition.x - ball.x);
          const windDirection = Math.atan2(wind.dy || 0, wind.dx || 0);
          const angleDiff = Math.cos(windAngle - windDirection);
          // Strong headwind can add up to 20% distance, tailwind subtract 15%
          const windStrength = wind.strength || 0;
          effectiveDistance *= 1 + (angleDiff * windStrength * -0.02);
        }

        // Find appropriate club for effective distance
        const allClubIds = ['putter', 'wedge', 'iron9', 'iron8', 'iron7', 'iron6', 'iron5', 'iron4', 'wood5', 'wood3', 'driver'];
        const clubsWithDistances = allClubIds.map(clubId => ({
          id: clubId,
          maxDistance: ClubSystem.getMaxDistance(clubId)
        }));
        clubsWithDistances.sort((a, b) => a.maxDistance - b.maxDistance);

        let bestClub = clubsWithDistances[clubsWithDistances.length - 1].id;
        let clubMaxDistance = 0;
        for (const club of clubsWithDistances) {
          if (club.maxDistance >= effectiveDistance) {
            bestClub = club.id;
            clubMaxDistance = club.maxDistance;
            break;
          }
        }

        // For master tier, return additional yardage info
        if (this.ownedTier >= 3) {
          // Calculate power percentage needed to hit exact distance
          const powerPercent = Math.min(100, Math.round((effectiveDistance / clubMaxDistance) * 100));
          return {
            clubId: bestClub,
            targetYards: Math.round(effectiveDistance),
            powerPercent: powerPercent,
            distanceToHole: Math.round(baseDistance)
          };
        }

        return bestClub;
      },

      getCaddieIcon() {
        if (this.ownedTier === 0) return null;
        return this.tiers[this.ownedTier - 1].icon;
      },

      getCaddieName() {
        if (this.ownedTier === 0) return null;
        return this.tiers[this.ownedTier - 1].name;
      },

      renderShopTab() {
        let html = '<div class="caddie-shop">';
        html += '<h3>Hire a Caddie</h3>';
        html += '<p class="caddie-desc">Caddies help recommend the right club for each shot.</p>';

        this.tiers.forEach((tier, index) => {
          const tierNum = index + 1;
          const isOwned = this.ownedTier >= tierNum;
          const canBuy = this.canPurchase(index);
          const isLocked = this.ownedTier < index; // Need previous tier first

          let btnClass = 'caddie-item';
          if (isOwned) btnClass += ' owned';
          else if (isLocked) btnClass += ' locked';
          else if (!canBuy) btnClass += ' cant-afford';

          html += `<div class="${btnClass}" data-tier="${index}">`;
          html += `<div class="caddie-icon">${tier.icon}</div>`;
          html += `<div class="caddie-info">`;
          html += `<div class="caddie-name">${tier.name}</div>`;
          html += `<div class="caddie-tier-desc">${tier.desc}</div>`;
          html += `</div>`;

          if (isOwned) {
            html += '<div class="caddie-status">HIRED</div>';
          } else if (isLocked) {
            html += `<div class="caddie-status locked">Need ${this.tiers[index - 1].name}</div>`;
          } else {
            html += `<button class="caddie-buy-btn" data-tier="${index}">${tier.cost} GB</button>`;
          }
          html += '</div>';
        });

        html += '</div>';
        return html;
      }
    };

    // === Power-up System ===
    const PowerUpManager = {
      activePowerUps: [], // Power-ups currently on the course
      collectedPowerUps: [], // Power-ups player has collected this hole
      activeEffects: {}, // Currently active effects
      spawnChance: 0.4, // 40% chance to spawn power-ups per hole

      types: {
        superball: {
          icon: 'âš¡',
          name: 'Super Ball',
          desc: '+25% power on next shot',
          color: '#FFD700'
        },
        magnet: {
          icon: 'ðŸ§²',
          name: 'Magnet',
          desc: 'Ball attracted to hole',
          color: '#E91E63'
        },
        mulligan: {
          icon: 'ðŸ”„',
          name: 'Mulligan',
          desc: 'Free stroke (doesn\'t count)',
          color: '#4CAF50'
        },
        windshield: {
          icon: 'ðŸ›¡ï¸',
          name: 'Wind Shield',
          desc: 'Ignore wind on next shot',
          color: '#2196F3'
        },
        golden: {
          icon: 'âœ¨',
          name: 'Golden Ball',
          desc: '2x Golf Bucks this hole',
          color: '#FFC107'
        }
      },

      reset() {
        this.activePowerUps = [];
        this.collectedPowerUps = [];
        this.activeEffects = {};
        this.updateUI(); // Hide power-ups display
      },

      spawnPowerUps(hole, canvasWidth, canvasHeight) {
        this.activePowerUps = [];

        // Random chance to spawn
        if (Math.random() > this.spawnChance) return;

        // Spawn 1-2 power-ups
        const count = Math.random() < 0.7 ? 1 : 2;
        const typeKeys = Object.keys(this.types);

        for (let i = 0; i < count; i++) {
          const type = typeKeys[Math.floor(Math.random() * typeKeys.length)];

          // Find a valid position on the fairway
          const fairwayPath = hole.fairwayPath || [hole.teePosition, hole.greenPosition];
          const t = 0.2 + Math.random() * 0.6; // Between 20-80% along fairway

          let x, y;
          if (fairwayPath.length === 2) {
            x = fairwayPath[0].x + (fairwayPath[1].x - fairwayPath[0].x) * t;
            y = fairwayPath[0].y + (fairwayPath[1].y - fairwayPath[0].y) * t;
          } else {
            // Dogleg - interpolate through path
            const segment = t < 0.5 ? 0 : 1;
            const localT = t < 0.5 ? t * 2 : (t - 0.5) * 2;
            const p1 = fairwayPath[segment];
            const p2 = fairwayPath[segment + 1];
            x = p1.x + (p2.x - p1.x) * localT;
            y = p1.y + (p2.y - p1.y) * localT;
          }

          // Add some random offset from center
          x += (Math.random() - 0.5) * 80;
          y += (Math.random() - 0.5) * 40;

          this.activePowerUps.push({
            type,
            x,
            y,
            radius: 15,
            collected: false,
            pulsePhase: Math.random() * Math.PI * 2
          });
        }
      },

      checkCollection(ball) {
        if (!ball || ball.isMoving === false) return;

        for (const powerUp of this.activePowerUps) {
          if (powerUp.collected) continue;

          const dx = ball.x - powerUp.x;
          const dy = ball.y - powerUp.y;
          const distance = Math.sqrt(dx * dx + dy * dy);

          if (distance < powerUp.radius + 10) {
            powerUp.collected = true;
            this.collectPowerUp(powerUp.type);
          }
        }
      },

      collectPowerUp(type) {
        const powerUp = this.types[type];
        this.collectedPowerUps.push(type);

        // Show notification
        MailboxManager.addNotification(
          'powerup',
          `${powerUp.icon} ${powerUp.name}`,
          powerUp.desc,
          { type }
        );

        // Apply immediate effects
        if (type === 'golden') {
          this.activeEffects.goldenBall = true;
        }

        AudioManager.playClickSound(); // Collect sound
        this.updateUI(); // Update power-ups display
      },

      // Called before a swing to get power modifier
      getSwingModifiers() {
        const modifiers = {
          powerMultiplier: 1,
          ignoreWind: false,
          freeStroke: false,
          hasMagnet: false
        };

        // Check for super ball
        const superballIndex = this.collectedPowerUps.indexOf('superball');
        if (superballIndex !== -1) {
          modifiers.powerMultiplier = 1.25;
          this.collectedPowerUps.splice(superballIndex, 1);
        }

        // Check for wind shield
        const windshieldIndex = this.collectedPowerUps.indexOf('windshield');
        if (windshieldIndex !== -1) {
          modifiers.ignoreWind = true;
          this.collectedPowerUps.splice(windshieldIndex, 1);
        }

        // Check for mulligan
        const mulliganIndex = this.collectedPowerUps.indexOf('mulligan');
        if (mulliganIndex !== -1) {
          modifiers.freeStroke = true;
          this.collectedPowerUps.splice(mulliganIndex, 1);
        }

        // Check for magnet
        const magnetIndex = this.collectedPowerUps.indexOf('magnet');
        if (magnetIndex !== -1) {
          modifiers.hasMagnet = true;
          // Magnet consumed after ball stops, tracked in updateBall
        }

        // Update UI after consuming power-ups
        this.updateUI();

        return modifiers;
      },

      // Check magnet effect during ball movement
      applyMagnetEffect(ball, hole) {
        const magnetIndex = this.collectedPowerUps.indexOf('magnet');
        if (magnetIndex === -1) return;

        const dx = hole.holePosition.x - ball.x;
        const dy = hole.holePosition.y - ball.y;
        const distance = Math.sqrt(dx * dx + dy * dy);

        // Attract ball when within 50 pixels
        if (distance < 50 && distance > 5) {
          const attractStrength = 150 * (1 - distance / 50);
          const speed = Math.sqrt(ball.velocityX * ball.velocityX + ball.velocityY * ball.velocityY);

          if (speed > 10 && speed < 100) {
            ball.velocityX += (dx / distance) * attractStrength * 0.016;
            ball.velocityY += (dy / distance) * attractStrength * 0.016;
          }
        }

        // Consume magnet when ball stops
        if (!ball.isMoving) {
          this.collectedPowerUps.splice(magnetIndex, 1);
        }
      },

      // Get Golf Bucks multiplier for current hole
      getBucksMultiplier() {
        return this.activeEffects.goldenBall ? 2 : 1;
      },

      render(ctx, animationTime) {
        for (const powerUp of this.activePowerUps) {
          if (powerUp.collected) continue;

          const type = this.types[powerUp.type];

          // Pulsing glow effect
          powerUp.pulsePhase += 0.05;
          const pulse = Math.sin(powerUp.pulsePhase) * 0.3 + 0.7;
          const glowRadius = powerUp.radius * (1.5 + pulse * 0.5);

          // Draw glow
          ctx.save();
          const gradient = ctx.createRadialGradient(
            powerUp.x, powerUp.y, 0,
            powerUp.x, powerUp.y, glowRadius
          );
          gradient.addColorStop(0, type.color + '80');
          gradient.addColorStop(0.5, type.color + '40');
          gradient.addColorStop(1, type.color + '00');

          ctx.fillStyle = gradient;
          ctx.beginPath();
          ctx.arc(powerUp.x, powerUp.y, glowRadius, 0, Math.PI * 2);
          ctx.fill();

          // Draw icon background
          ctx.fillStyle = type.color;
          ctx.beginPath();
          ctx.arc(powerUp.x, powerUp.y, powerUp.radius, 0, Math.PI * 2);
          ctx.fill();

          // Draw icon
          ctx.font = 'bold 16px Arial';
          ctx.fillStyle = '#000';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(type.icon, powerUp.x, powerUp.y);

          ctx.restore();
        }
      },

      renderCollectedUI(ctx, canvasWidth) {
        if (this.collectedPowerUps.length === 0) return;

        const startX = canvasWidth - 40;
        const startY = 100;

        ctx.save();
        ctx.font = 'bold 12px Arial';
        ctx.textAlign = 'center';

        this.collectedPowerUps.forEach((type, i) => {
          const powerUp = this.types[type];
          const y = startY + i * 35;

          // Background
          ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
          ctx.beginPath();
          ctx.arc(startX, y, 15, 0, Math.PI * 2);
          ctx.fill();

          // Icon
          ctx.fillStyle = powerUp.color;
          ctx.fillText(powerUp.icon, startX, y + 1);
        });

        ctx.restore();
      },

      // Update HTML UI display
      updateUI() {
        const container = document.getElementById('powerups-display');
        const list = document.getElementById('powerups-list');

        // Guard against early calls before DOM is ready
        if (!container || !list) return;

        if (this.collectedPowerUps.length === 0 && !this.activeEffects.goldenBall) {
          container.classList.add('hidden');
          return;
        }

        container.classList.remove('hidden');

        // Build list of current power-ups
        let html = '';

        // Show golden ball if active
        if (this.activeEffects.goldenBall) {
          const type = this.types.golden;
          html += `<div class="powerup-item" style="border: 1px solid ${type.color}">
            <span class="powerup-icon">${type.icon}</span>
            <span>2x</span>
          </div>`;
        }

        // Show collected power-ups
        this.collectedPowerUps.forEach(typeKey => {
          const type = this.types[typeKey];
          html += `<div class="powerup-item" style="border: 1px solid ${type.color}">
            <span class="powerup-icon">${type.icon}</span>
          </div>`;
        });

        list.innerHTML = html;
      }
    };

    // === CareerSystem Module ===
    // Complete career mode with 4-tier tour structure, character customization, rival system, and sponsorships
    const CareerSystem = {
      activeCareer: null,
      isInCareerTournament: false,
      activeTournament: null,
      careerSlots: [],
      maxSlots: 3,
      storageKey: 'golf-career-saves',

      // Avatar sprites - loaded SVG images
      avatarSprites: {},       // Cache for Image objects keyed by "file" or "file:hairHex"
      avatarSvgText: {},       // Raw SVG text for each sprite file
      spritesLoaded: false,

      // Sprite definitions mapping to SVG files with skin tones and original hair colors
      spriteMap: {
        boy: [
          { id: 0, file: '01-boy-light-brown.svg', name: 'Short Brown', skinHex: '#FFDAB9', hairHex: ['#8B4513', '#A0522D'] },
          { id: 1, file: '02-boy-light-blonde.svg', name: 'Spiky Blonde', skinHex: '#FFDAB9', hairHex: ['#F4D03F', '#FFEB3B', '#DAA520'] },
          { id: 2, file: '03-boy-medium-curly.svg', name: 'Curly Afro', skinHex: '#DEB887', hairHex: ['#2C1810', '#3D2314'] },
          { id: 3, file: '04-boy-tan-wavy.svg', name: 'Wavy Brown', skinHex: '#D2A679', hairHex: ['#4A3728', '#5D4632'] },
          { id: 4, file: '05-boy-dark-short.svg', name: 'Short Black', skinHex: '#8B5A2B', hairHex: ['#1a1a1a', '#333'] },
          { id: 5, file: '06-boy-dark-fade.svg', name: 'Fade Cut', skinHex: '#6B4423', hairHex: ['#1a1a1a', '#333', '#2a2a2a'] },
          { id: 6, file: '13-boy-light-red.svg', name: 'Messy Red', skinHex: '#FFE4C4', hairHex: ['#C0392B', '#E74C3C', '#A93226'] },
          { id: 7, file: '14-boy-medium-mohawk.svg', name: 'Mohawk', skinHex: '#DEB887', hairHex: ['#9B59B6', '#8E44AD', '#7D3C98'] },
          { id: 8, file: '17-boy-tan-longhair.svg', name: 'Long Hair', skinHex: '#D2A679', hairHex: ['#1a1a1a', '#333'] },
          { id: 9, file: '19-boy-light-shortblonde.svg', name: 'Short Blonde', skinHex: '#FFDAB9', hairHex: ['#F4D03F', '#FFEB3B', '#DAA520'] },
          { id: 10, file: '20-boy-bald.svg', name: 'Bald', skinHex: '#FFDAB9', hairHex: ['#4A3728'] }
        ],
        girl: [
          { id: 0, file: '07-girl-light-blonde.svg', name: 'Long Blonde', skinHex: '#FFDAB9', hairHex: ['#F4D03F', '#FFEB3B', '#DAA520'] },
          { id: 1, file: '08-girl-light-ponytail.svg', name: 'Ponytail', skinHex: '#FFDAB9', hairHex: ['#8B4513', '#A0522D'] },
          { id: 2, file: '09-girl-medium-straight.svg', name: 'Straight Black', skinHex: '#DEB887', hairHex: ['#1a1a1a', '#333'] },
          { id: 3, file: '10-girl-tan-curly.svg', name: 'Big Curls', skinHex: '#D2A679', hairHex: ['#4A3728', '#5D4A35'] },
          { id: 4, file: '11-girl-dark-braids.svg', name: 'Braids', skinHex: '#8B5A2B', hairHex: ['#1a1a1a', '#333'] },
          { id: 5, file: '12-girl-dark-puffs.svg', name: 'Afro Puffs', skinHex: '#6B4423', hairHex: ['#1a1a1a', '#333'] },
          { id: 6, file: '15-girl-light-pigtails.svg', name: 'Pigtails', skinHex: '#FFDAB9', hairHex: ['#FF69B4', '#FF8DC7'] },
          { id: 7, file: '16-girl-medium-bob.svg', name: 'Bob Cut', skinHex: '#DEB887', hairHex: ['#4A3728', '#5D4A35'] },
          { id: 8, file: '18-girl-tan-bangs.svg', name: 'Bangs', skinHex: '#D2A679', hairHex: ['#8B4513', '#A0522D'] },
          { id: 9, file: '21-girl-bald.svg', name: 'Bald', skinHex: '#FFDAB9', hairHex: ['#4A3728'] }
        ]
      },

      // Skin tone options (null hex = use sprite's original)
      skinTones: [
        { id: 0, name: 'Original', hex: null },
        { id: 1, name: 'Light', hex: '#FFE0BD' },
        { id: 2, name: 'Fair', hex: '#F5D0B0' },
        { id: 3, name: 'Medium', hex: '#D4A574' },
        { id: 4, name: 'Tan', hex: '#C68642' },
        { id: 5, name: 'Brown', hex: '#8D5524' },
        { id: 6, name: 'Dark', hex: '#5C3A21' }
      ],

      // Hair colors - expanded palette (null hex = use sprite's original)
      hairColors: [
        { id: 0, name: 'Original', hex: null },
        { id: 1, name: 'Black', hex: '#1a1a1a' },
        { id: 2, name: 'Brown', hex: '#4A3728' },
        { id: 3, name: 'Light Brown', hex: '#8B4513' },
        { id: 4, name: 'Blonde', hex: '#F4D03F' },
        { id: 5, name: 'Platinum', hex: '#E8E4C9' },
        { id: 6, name: 'Ginger', hex: '#D2691E' },
        { id: 7, name: 'Red', hex: '#C0392B' },
        { id: 8, name: 'Pink', hex: '#FF69B4' },
        { id: 9, name: 'Purple', hex: '#9B59B6' },
        { id: 10, name: 'Blue', hex: '#3498DB' },
        { id: 11, name: 'Teal', hex: '#1ABC9C' },
        { id: 12, name: 'Gray', hex: '#7F8C8D' },
        { id: 13, name: 'White', hex: '#ECF0F1' }
      ],

      // Facial hair options (boy only)
      facialHairOptions: [
        { id: 0, name: 'None', type: null },
        { id: 1, name: 'Stubble', type: 'stubble' },
        { id: 2, name: 'Full Beard', type: 'beard' },
        { id: 3, name: 'Goatee', type: 'goatee' },
        { id: 4, name: 'Mustache', type: 'mustache' },
        { id: 5, name: 'Soul Patch', type: 'soulpatch' }
      ],

      // Beard color options
      beardColors: [
        { id: 0, name: 'Match Hair', hex: null },
        { id: 1, name: 'Black', hex: '#1a1a1a' },
        { id: 2, name: 'Dark Brown', hex: '#3d2314' },
        { id: 3, name: 'Brown', hex: '#5c4033' },
        { id: 4, name: 'Light Brown', hex: '#8b7355' },
        { id: 5, name: 'Blonde', hex: '#c4a574' },
        { id: 6, name: 'Ginger', hex: '#b5651d' },
        { id: 7, name: 'Red', hex: '#8b2500' },
        { id: 8, name: 'Gray', hex: '#6e6e6e' },
        { id: 9, name: 'White', hex: '#d3d3d3' }
      ],

      // Hairstyles per gender - now using sprite map
      get hairstyles() {
        return {
          boy: this.spriteMap.boy.map(s => ({ id: s.id, name: s.name, file: s.file })),
          girl: this.spriteMap.girl.map(s => ({ id: s.id, name: s.name, file: s.file }))
        };
      },

      // Load all avatar sprites as SVG text for recoloring
      async loadSprites() {
        if (this.spritesLoaded) return;

        const allSprites = [...this.spriteMap.boy, ...this.spriteMap.girl];

        for (const sprite of allSprites) {
          try {
            const response = await fetch(`sprites/${sprite.file}`);
            const svgText = await response.text();
            this.avatarSvgText[sprite.file] = svgText;
            // Create default image from original SVG
            this.avatarSprites[sprite.file] = await this.svgTextToImage(svgText);
          } catch (e) {
            console.warn(`Could not load sprite: ${sprite.file}`, e);
          }
        }

        this.spritesLoaded = true;
        console.log('Avatar sprites loaded:', Object.keys(this.avatarSprites).length);
      },

      // Convert SVG text to Image object
      svgTextToImage(svgText) {
        return new Promise((resolve, reject) => {
          const blob = new Blob([svgText], { type: 'image/svg+xml' });
          const url = URL.createObjectURL(blob);
          const img = new Image();
          img.onload = () => {
            URL.revokeObjectURL(url);
            resolve(img);
          };
          img.onerror = () => {
            URL.revokeObjectURL(url);
            reject(new Error('Failed to convert SVG to image'));
          };
          img.src = url;
        });
      },

      // Get a lighter version of a hex color for highlights
      lightenColor(hex, percent = 20) {
        const num = parseInt(hex.replace('#', ''), 16);
        const r = Math.min(255, (num >> 16) + Math.floor(255 * percent / 100));
        const g = Math.min(255, ((num >> 8) & 0x00FF) + Math.floor(255 * percent / 100));
        const b = Math.min(255, (num & 0x0000FF) + Math.floor(255 * percent / 100));
        return `#${((r << 16) | (g << 8) | b).toString(16).padStart(6, '0')}`;
      },

      // Get a darker version of a hex color for eyebrows
      darkenColor(hex, percent = 15) {
        const num = parseInt(hex.replace('#', ''), 16);
        const r = Math.max(0, (num >> 16) - Math.floor(255 * percent / 100));
        const g = Math.max(0, ((num >> 8) & 0x00FF) - Math.floor(255 * percent / 100));
        const b = Math.max(0, (num & 0x0000FF) - Math.floor(255 * percent / 100));
        return `#${((r << 16) | (g << 8) | b).toString(16).padStart(6, '0')}`;
      },

      // Get sprite with custom hair color (cached)
      async getRecoloredSprite(spriteInfo, newHairHex, newSkinHex = null) {
        if (!spriteInfo) return null;
        if (!newHairHex && !newSkinHex) return this.avatarSprites[spriteInfo?.file];

        const cacheKey = `${spriteInfo.file}:${newHairHex || 'default'}:${newSkinHex || 'default'}`;

        // Return cached version if exists
        if (this.avatarSprites[cacheKey]) {
          return this.avatarSprites[cacheKey];
        }

        // Get original SVG text
        const svgText = this.avatarSvgText[spriteInfo.file];
        if (!svgText) return this.avatarSprites[spriteInfo.file];

        let recoloredSvg = svgText;

        // Replace hair colors
        if (newHairHex) {
          const originalHairColors = spriteInfo.hairHex || [];
          const newHighlight = this.lightenColor(newHairHex, 20);
          const newDark = this.darkenColor(newHairHex, 10);

          // Replace each original hair color with the new color variants
          originalHairColors.forEach((origColor, i) => {
            const replacement = i === 0 ? newHairHex : (i === 1 ? newHighlight : newDark);
            // Escape the color for regex and match with or without #
            const escaped = origColor.replace('#', '').toUpperCase();
            // Match fill="#COLOR" or stroke="#COLOR" patterns (case insensitive)
            const fillRegex = new RegExp(`(fill=["']#?)${escaped}(["'])`, 'gi');
            const strokeRegex = new RegExp(`(stroke=["']#?)${escaped}(["'])`, 'gi');
            recoloredSvg = recoloredSvg.replace(fillRegex, `$1${replacement.replace('#', '')}$2`);
            recoloredSvg = recoloredSvg.replace(strokeRegex, `$1${replacement.replace('#', '')}$2`);
          });
        }

        // Replace skin color
        if (newSkinHex && spriteInfo.skinHex) {
          const origSkin = spriteInfo.skinHex.toUpperCase();
          const newSkinUpper = newSkinHex.toUpperCase();

          // Simple direct replacement of the main skin color
          // Replace the entire fill="#XXXXXX" pattern to avoid regex issues
          const origSkinNoHash = origSkin.replace('#', '');
          const newSkinNoHash = newSkinUpper.replace('#', '');

          // Replace fill colors (both with and without # prefix, case insensitive)
          recoloredSvg = recoloredSvg.split(`fill="#${origSkinNoHash}"`).join(`fill="#${newSkinNoHash}"`);
          recoloredSvg = recoloredSvg.split(`fill="#${origSkinNoHash.toLowerCase()}"`).join(`fill="#${newSkinNoHash}"`);
          recoloredSvg = recoloredSvg.split(`fill='#${origSkinNoHash}'`).join(`fill='#${newSkinNoHash}'`);
          recoloredSvg = recoloredSvg.split(`fill='#${origSkinNoHash.toLowerCase()}'`).join(`fill='#${newSkinNoHash}'`);

          // Also try without the # in case SVG uses different format
          recoloredSvg = recoloredSvg.split(`fill="${origSkinNoHash}"`).join(`fill="${newSkinNoHash}"`);
          recoloredSvg = recoloredSvg.split(`fill='${origSkinNoHash}'`).join(`fill='${newSkinNoHash}'`);
        }

        // Create and cache the new image
        try {
          const img = await this.svgTextToImage(recoloredSvg);
          this.avatarSprites[cacheKey] = img;
          return img;
        } catch (e) {
          console.warn('Failed to recolor sprite:', e);
          return this.avatarSprites[spriteInfo.file];
        }
      },

      // Outfit colors
      shirtColors: [
        '#E53935', '#1E88E5', '#43A047', '#FDD835', '#8E24AA', '#FF7043', '#00ACC1', '#FFFFFF'
      ],
      pantsColors: [
        '#1565C0', '#37474F', '#5D4037', '#212121', '#F5F5F5', '#2E7D32'
      ],

      // Tour configurations
      tours: {
        local: {
          id: 'local',
          name: 'Local Tour',
          icon: 'ðŸ ',
          color: '#4CAF50',
          entryFee: 0,
          minRankingPoints: 0,
          promotionPoints: 500,
          basePrize: 25,
          aiDifficulty: 'easy',
          tournamentCount: 8,
          themes: ['classic', 'desert'] // Beginner-friendly courses
        },
        amateur: {
          id: 'amateur',
          name: 'Amateur Tour',
          icon: 'ðŸŽ¯',
          color: '#2196F3',
          entryFee: 5,
          minRankingPoints: 500,
          promotionPoints: 2000,
          basePrize: 50,
          aiDifficulty: 'medium',
          tournamentCount: 10,
          themes: ['classic', 'desert', 'winter', 'tropical'] // All standard courses
        },
        pro: {
          id: 'pro',
          name: 'Pro Tour',
          icon: 'ðŸ†',
          color: '#9C27B0',
          entryFee: 15,
          minRankingPoints: 2000,
          promotionPoints: 5000,
          basePrize: 100,
          aiDifficulty: 'hard',
          tournamentCount: 10,
          themes: ['classic', 'desert', 'winter', 'tropical', 'links', 'night'] // Includes exclusive courses
        },
        legend: {
          id: 'legend',
          name: 'Legend Tour',
          icon: 'ðŸ‘‘',
          color: '#FF9800',
          entryFee: 50,
          minRankingPoints: 5000,
          promotionPoints: null, // Final tier
          basePrize: 250,
          aiDifficulty: 'expert',
          tournamentCount: 12,
          themes: ['links', 'night', 'volcanic', 'aurora'] // Exclusive legendary courses only
        }
      },

      // Career-exclusive course themes (not in Quick Play)
      careerExclusiveThemes: {
        links: {
          name: 'Scottish Links',
          icon: 'ðŸ´ó §ó ¢ó ³ó £ó ´ó ¿',
          description: 'Windswept coastal courses',
          colors: { fairway: '#7CB342', rough: '#5D8A3E', sand: '#D4C4A8', water: '#3A7CA5' }
        },
        night: {
          name: 'Night Golf',
          icon: 'ðŸŒ™',
          description: 'Under the stars',
          colors: { fairway: '#2E4A3E', rough: '#1E3A2E', sand: '#4A4A3A', water: '#1A3A5A' }
        },
        volcanic: {
          name: 'Volcanic',
          icon: 'ðŸŒ‹',
          description: 'Dramatic lava landscapes',
          colors: { fairway: '#4A5A4A', rough: '#3A4A3A', sand: '#2A2A2A', water: '#FF6B35' }
        },
        aurora: {
          name: 'Aurora Borealis',
          icon: 'âœ¨',
          description: 'Northern lights paradise',
          colors: { fairway: '#3A5A5A', rough: '#2A4A4A', sand: '#6A7A7A', water: '#4A8A9A' }
        }
      },

      // Rival configuration - Ace McStroke, your nemesis throughout career mode
      rival: {
        name: 'Ace McStroke',
        portrait: 'ðŸ˜Ž',
        phrases: {
          // First encounter
          firstMeet: [
            "Well, well... fresh meat on the tour. I'm Ace McStroke. Remember that name - you'll be seeing it at the top of every leaderboard.",
            "A new face? How adorable. I'm Ace, the one you'll never beat. Enjoy your brief time in the spotlight.",
            "So YOU'RE the rookie everyone's talking about? I've seen dozens like you come and go. I'm Ace McStroke - the king of this tour."
          ],
          // Regular encounters
          intro: [
            "Back for more? I admire your persistence.",
            "Oh look, my favorite punching bag returns!",
            "Ready to watch me lift another trophy?",
            "You again? Don't you ever learn?",
            "The rookie's back! How's second place treating you?",
            "Hope you stretched - you'll be chasing me all day."
          ],
          // When rival wins
          win: [
            "Better luck next time, kid.",
            "That's why they call me Ace!",
            "Come back when you've practiced more.",
            "And THAT'S how a pro does it!",
            "Maybe stick to mini-golf?",
            "Don't feel bad - losing to me is inevitable."
          ],
          // When player wins
          lose: [
            "Lucky shot... it won't happen again.",
            "Enjoy it while it lasts.",
            "I was going easy on you.",
            "Must've been the wind...",
            "Fine, you got ONE win. Savor it.",
            "I wasn't feeling well today. Next time you're done."
          ],
          // When player is promoted to next tier
          promotion: [
            "Oh, moving up? Don't get comfortable - I'll be there too.",
            "Congrats on the promotion. Now the REAL competition begins.",
            "You made it to the next level? Good. I was getting bored beating you down there."
          ],
          // Legend tier encounters
          legend: [
            "So you've made it to the Legend Tour. Impressive. But THIS is MY domain.",
            "Welcome to the big leagues, rookie. Here's where legends are made... or broken.",
            "You've come far. But no one's ever beaten me on the Legend Tour. NO ONE."
          ]
        }
      },

      // Shop items - purchasable with Tour Coins
      shopItems: {
        hats: [
          { id: 'visor_white', name: 'White Visor', icon: 'ðŸ§¢', price: 25, desc: 'Classic golf visor' },
          { id: 'cap_blue', name: 'Blue Cap', icon: 'ðŸ§¢', price: 30, desc: 'Sporty baseball cap' },
          { id: 'cap_red', name: 'Red Cap', icon: 'ðŸ§¢', price: 30, desc: 'Bold red cap' },
          { id: 'cap_black', name: 'Black Cap', icon: 'ðŸ§¢', price: 30, desc: 'Sleek black cap' },
          { id: 'bucket_hat', name: 'Bucket Hat', icon: 'ðŸŽ©', price: 50, desc: 'Trendy bucket style' },
          { id: 'cowboy', name: 'Cowboy Hat', icon: 'ðŸ¤ ', price: 75, desc: 'Yeehaw!' },
          { id: 'cowboy_black', name: 'Black Cowboy', icon: 'ðŸ¤ ', price: 85, desc: 'Outlaw style' },
          { id: 'beanie', name: 'Beanie', icon: 'ðŸ§¶', price: 40, desc: 'Cozy vibes' },
          { id: 'top_hat', name: 'Top Hat', icon: 'ðŸŽ©', price: 100, desc: 'Fancy and formal' },
          { id: 'crown', name: 'Champion Crown', icon: 'ðŸ‘‘', price: 200, desc: 'For true legends only' }
        ],
        glasses: [
          { id: 'sunglasses', name: 'Sunglasses', icon: 'ðŸ•¶ï¸', price: 20, desc: 'Cool shades' },
          { id: 'sport_shades', name: 'Sport Shades', icon: 'ðŸ•¶ï¸', price: 35, desc: 'Wraparound style' },
          { id: 'aviators', name: 'Aviators', icon: 'ðŸ•¶ï¸', price: 50, desc: 'Top Gun vibes' },
          { id: 'round_shades', name: 'Round Shades', icon: 'ðŸ•¶ï¸', price: 45, desc: 'Retro cool' },
          { id: 'nerd_glasses', name: 'Nerd Glasses', icon: 'ðŸ¤“', price: 40, desc: 'Smart look' },
          { id: 'star_glasses', name: 'Star Glasses', icon: 'â­', price: 80, desc: 'Be a star!' },
          { id: 'heart_glasses', name: 'Heart Glasses', icon: 'ðŸ’–', price: 60, desc: 'Spread the love' },
          { id: 'vr_headset', name: 'VR Headset', icon: 'ðŸ¥½', price: 150, desc: 'Future golfer' }
        ],
        outfits: [
          { id: 'outfit_stripes', name: 'Racing Stripes', icon: 'ðŸ', price: 50, desc: 'Speed demon look', shirtColor: '#1565C0', design: 'stripes', stripeColor: '#FFFFFF' },
          { id: 'outfit_gradient', name: 'Sunset Fade', icon: 'ðŸŒ…', price: 65, desc: 'Beautiful gradient', shirtColor: '#FF6B6B', design: 'gradient', gradientTo: '#9C27B0' },
          { id: 'outfit_camo', name: 'Golf Camo', icon: 'ðŸŒ²', price: 70, desc: 'Hidden in the rough', shirtColor: '#4CAF50', design: 'camo' },
          { id: 'outfit_argyle', name: 'Classic Argyle', icon: 'ðŸ”·', price: 80, desc: 'Old school cool', shirtColor: '#2E7D32', design: 'argyle', patternColor: '#FFC107' },
          { id: 'outfit_flames', name: 'Hot Shot', icon: 'ðŸ”¥', price: 100, desc: 'Straight fire', shirtColor: '#F44336', design: 'flames' },
          { id: 'outfit_stars', name: 'All-Star', icon: 'â­', price: 90, desc: 'Star player', shirtColor: '#1A237E', design: 'stars', patternColor: '#FFD700' },
          { id: 'outfit_tiger', name: 'Tiger Stripes', icon: 'ðŸ…', price: 110, desc: 'Fierce competitor', shirtColor: '#FF9800', design: 'tiger', pantsColor: '#1a1a1a' },
          { id: 'outfit_lightning', name: 'Lightning Strike', icon: 'âš¡', price: 120, desc: 'Electric energy', shirtColor: '#311B92', design: 'lightning', patternColor: '#FFEB3B' },
          { id: 'outfit_champion', name: 'Champion Gold', icon: 'ðŸ†', price: 150, desc: 'For true winners', shirtColor: '#FFD700', design: 'champion', pantsColor: '#1a1a1a' },
          { id: 'outfit_neon', name: 'Neon Nights', icon: 'ðŸ’œ', price: 130, desc: 'Glow in style', shirtColor: '#E91E63', design: 'neon', patternColor: '#00FFFF' },
          { id: 'outfit_tuxedo', name: 'Tuxedo', icon: 'ðŸ¤µ', price: 140, desc: 'Classy formal', shirtColor: '#212121', design: 'tuxedo', patternColor: '#FFFFFF' },
          { id: 'outfit_tropical', name: 'Tropical', icon: 'ðŸŒ´', price: 85, desc: 'Island vibes', shirtColor: '#00BCD4', design: 'tropical', patternColor: '#FFEB3B' },
          { id: 'outfit_galaxy', name: 'Galaxy', icon: 'ðŸŒŒ', price: 160, desc: 'Out of this world', shirtColor: '#1A237E', design: 'galaxy', patternColor: '#E040FB' },
          { id: 'outfit_retro', name: 'Retro 80s', icon: 'ðŸ“¼', price: 95, desc: 'Rad throwback', shirtColor: '#E91E63', design: 'retro', patternColor: '#00FFFF' },
          { id: 'outfit_western', name: 'Western', icon: 'ðŸ¤ ', price: 100, desc: 'Howdy partner', shirtColor: '#795548', design: 'western', patternColor: '#FFC107' }
        ],
        sets: [
          { id: 'set_cowboy', name: 'The Cowboy', icon: 'ðŸ¤ ', price: 200, desc: 'Yeehaw! Complete western look', hat: 'cowboy', glasses: 'aviators', outfit: { shirtColor: '#795548', design: 'western', patternColor: '#FFC107', pantsColor: '#4E342E' } },
          { id: 'set_rockstar', name: 'Rockstar', icon: 'ðŸŽ¸', price: 280, desc: 'Born to be wild', hat: 'top_hat', glasses: 'star_glasses', outfit: { shirtColor: '#E91E63', design: 'neon', patternColor: '#00FFFF', pantsColor: '#1a1a1a' } },
          { id: 'set_pro', name: 'Pro Classic', icon: 'ðŸŒï¸', price: 100, desc: 'Clean pro look', hat: 'visor_white', glasses: 'sport_shades', outfit: { shirtColor: '#1565C0', design: 'stripes', stripeColor: '#FFFFFF', pantsColor: '#37474F' } },
          { id: 'set_beach', name: 'Beach Vibes', icon: 'ðŸ–ï¸', price: 150, desc: 'Chill island style', hat: 'bucket_hat', glasses: 'aviators', outfit: { shirtColor: '#00BCD4', design: 'tropical', patternColor: '#FFEB3B', pantsColor: '#ECEFF1' } },
          { id: 'set_champion', name: 'The Champion', icon: 'ðŸ†', price: 400, desc: 'Ultimate winner set', hat: 'crown', glasses: 'aviators', outfit: { shirtColor: '#FFD700', design: 'champion', pantsColor: '#1a1a1a' } },
          { id: 'set_cyber', name: 'Cyber Golfer', icon: 'ðŸ¤–', price: 350, desc: 'Future of golf', hat: null, glasses: 'vr_headset', outfit: { shirtColor: '#1A237E', design: 'galaxy', patternColor: '#E040FB', pantsColor: '#263238' } },
          { id: 'set_nightsky', name: 'Night Sky', icon: 'ðŸŒ™', price: 180, desc: 'Stargazer style', hat: 'beanie', glasses: 'round_shades', outfit: { shirtColor: '#1A237E', design: 'stars', patternColor: '#FFD700', pantsColor: '#0D47A1' } },
          { id: 'set_fire', name: 'Fire Starter', icon: 'ðŸ”¥', price: 160, desc: 'Bring the heat', hat: 'cap_red', glasses: 'sunglasses', outfit: { shirtColor: '#F44336', design: 'flames', pantsColor: '#212121' } },
          { id: 'set_gentleman', name: 'The Gentleman', icon: 'ðŸŽ©', price: 220, desc: 'Dapper and refined', hat: 'top_hat', glasses: 'nerd_glasses', outfit: { shirtColor: '#212121', design: 'tuxedo', patternColor: '#FFFFFF', pantsColor: '#212121' } },
          { id: 'set_speed', name: 'Speed Demon', icon: 'âš¡', price: 190, desc: 'Lightning fast', hat: 'cap_black', glasses: 'sport_shades', outfit: { shirtColor: '#311B92', design: 'lightning', patternColor: '#FFEB3B', pantsColor: '#1a1a1a' } },
          { id: 'set_tiger', name: 'Tiger Mode', icon: 'ðŸ…', price: 200, desc: 'Fierce like Sunday red', hat: 'cap_red', glasses: 'sunglasses', outfit: { shirtColor: '#F44336', design: 'tiger', pantsColor: '#1a1a1a' } },
          { id: 'set_retro', name: 'Totally Rad', icon: 'ðŸ“¼', price: 170, desc: '80s throwback vibes', hat: 'bucket_hat', glasses: 'round_shades', outfit: { shirtColor: '#E91E63', design: 'retro', patternColor: '#00FFFF', pantsColor: '#7B1FA2' } },
          { id: 'set_military', name: 'Golf Force', icon: 'ðŸŽ–ï¸', price: 140, desc: 'Tactical golfer', hat: 'cap_blue', glasses: 'sport_shades', outfit: { shirtColor: '#4CAF50', design: 'camo', pantsColor: '#33691E' } },
          { id: 'set_love', name: 'Love Machine', icon: 'ðŸ’–', price: 150, desc: 'Spread the love', hat: 'bucket_hat', glasses: 'heart_glasses', outfit: { shirtColor: '#FF6B6B', design: 'gradient', gradientTo: '#E91E63', pantsColor: '#FFFFFF' } }
        ]
      },

      // Shop state
      currentShopTab: 'hats',
      selectedShopItem: null,

      // Equipment sponsors
      equipmentSponsors: {
        swing_dynamics: {
          id: 'swing_dynamics',
          name: 'Swing Dynamics',
          icon: 'ðŸŒï¸',
          type: 'equipment',
          minTour: 'local',
          tiers: [
            { level: 1, xpRequired: 0, powerBonus: 0.02, accuracyBonus: 0.02, reward: null },
            { level: 2, xpRequired: 50, powerBonus: 0.04, accuracyBonus: 0.04, reward: 'Driver +5%' },
            { level: 3, xpRequired: 150, powerBonus: 0.06, accuracyBonus: 0.06, reward: 'All Clubs +3%' },
            { level: 4, xpRequired: 300, powerBonus: 0.08, accuracyBonus: 0.08, reward: 'Irons +8%' },
            { level: 5, xpRequired: 500, powerBonus: 0.10, accuracyBonus: 0.10, reward: 'Full Set +10%' }
          ]
        },
        fairway_forge: {
          id: 'fairway_forge',
          name: 'Fairway Forge',
          icon: 'ðŸ”§',
          type: 'equipment',
          minTour: 'amateur',
          tiers: [
            { level: 1, xpRequired: 0, powerBonus: 0.03, accuracyBonus: 0.02, reward: null },
            { level: 2, xpRequired: 75, powerBonus: 0.05, accuracyBonus: 0.04, reward: 'Woods +6%' },
            { level: 3, xpRequired: 200, powerBonus: 0.07, accuracyBonus: 0.06, reward: 'All Clubs +5%' },
            { level: 4, xpRequired: 400, powerBonus: 0.09, accuracyBonus: 0.08, reward: 'Wedges +10%' },
            { level: 5, xpRequired: 650, powerBonus: 0.12, accuracyBonus: 0.10, reward: 'Full Set +12%' }
          ]
        },
        titan_golf: {
          id: 'titan_golf',
          name: 'Titan Golf',
          icon: 'âš¡',
          type: 'equipment',
          minTour: 'pro',
          tiers: [
            { level: 1, xpRequired: 0, powerBonus: 0.04, accuracyBonus: 0.03, reward: null },
            { level: 2, xpRequired: 100, powerBonus: 0.07, accuracyBonus: 0.05, reward: 'Driver +10%' },
            { level: 3, xpRequired: 250, powerBonus: 0.10, accuracyBonus: 0.07, reward: 'All Clubs +7%' },
            { level: 4, xpRequired: 500, powerBonus: 0.13, accuracyBonus: 0.09, reward: 'Power +15%' },
            { level: 5, xpRequired: 800, powerBonus: 0.15, accuracyBonus: 0.12, reward: 'Full Set +15%' }
          ]
        },
        precision_pro: {
          id: 'precision_pro',
          name: 'Precision Pro',
          icon: 'ðŸŽ¯',
          type: 'equipment',
          minTour: 'legend',
          tiers: [
            { level: 1, xpRequired: 0, powerBonus: 0.05, accuracyBonus: 0.05, reward: null },
            { level: 2, xpRequired: 150, powerBonus: 0.08, accuracyBonus: 0.08, reward: 'All Clubs +10%' },
            { level: 3, xpRequired: 350, powerBonus: 0.11, accuracyBonus: 0.11, reward: 'Accuracy +15%' },
            { level: 4, xpRequired: 600, powerBonus: 0.14, accuracyBonus: 0.14, reward: 'All Stats +12%' },
            { level: 5, xpRequired: 1000, powerBonus: 0.18, accuracyBonus: 0.18, reward: 'Elite Set +18%' }
          ]
        }
      },

      // Apparel sponsors
      apparelSponsors: {
        golf_basics: {
          id: 'golf_basics',
          name: 'Golf Basics',
          icon: 'ðŸ‘•',
          type: 'apparel',
          minTour: 'local',
          tiers: [
            { level: 1, xpRequired: 0, reward: null },
            { level: 2, xpRequired: 50, reward: { type: 'shirt', color: '#4CAF50', name: 'Green Polo' } },
            { level: 3, xpRequired: 150, reward: { type: 'pants', color: '#795548', name: 'Brown Khakis' } },
            { level: 4, xpRequired: 300, reward: { type: 'accessory', id: 'visor', name: 'Classic Visor' } },
            { level: 5, xpRequired: 500, reward: { type: 'shirt', color: '#FFD700', name: 'Gold Polo' } }
          ]
        },
        ace_apparel: {
          id: 'ace_apparel',
          name: 'Ace Apparel',
          icon: 'ðŸŽ½',
          type: 'apparel',
          minTour: 'amateur',
          tiers: [
            { level: 1, xpRequired: 0, reward: null },
            { level: 2, xpRequired: 75, reward: { type: 'shirt', color: '#2196F3', name: 'Sky Blue Polo' } },
            { level: 3, xpRequired: 200, reward: { type: 'accessory', id: 'sunglasses', name: 'Sport Shades' } },
            { level: 4, xpRequired: 400, reward: { type: 'pants', color: '#263238', name: 'Charcoal Slacks' } },
            { level: 5, xpRequired: 650, reward: { type: 'shirt', color: '#E91E63', name: 'Pro Pink Polo' } }
          ]
        },
        champion_wear: {
          id: 'champion_wear',
          name: 'Champion Wear',
          icon: 'ðŸ…',
          type: 'apparel',
          minTour: 'pro',
          tiers: [
            { level: 1, xpRequired: 0, reward: null },
            { level: 2, xpRequired: 100, reward: { type: 'shirt', color: '#9C27B0', name: 'Purple Pro' } },
            { level: 3, xpRequired: 250, reward: { type: 'accessory', id: 'cap', name: 'Champion Cap' } },
            { level: 4, xpRequired: 500, reward: { type: 'pants', color: '#1A237E', name: 'Navy Elite' } },
            { level: 5, xpRequired: 800, reward: { type: 'accessory', id: 'glove', name: 'Pro Glove' } }
          ]
        },
        legend_style: {
          id: 'legend_style',
          name: 'Legend Style',
          icon: 'ðŸ‘‘',
          type: 'apparel',
          minTour: 'legend',
          tiers: [
            { level: 1, xpRequired: 0, reward: null },
            { level: 2, xpRequired: 150, reward: { type: 'shirt', color: '#FF9800', name: 'Legend Orange' } },
            { level: 3, xpRequired: 350, reward: { type: 'accessory', id: 'goldvisor', name: 'Gold Visor' } },
            { level: 4, xpRequired: 600, reward: { type: 'pants', color: '#212121', name: 'Black Elite' } },
            { level: 5, xpRequired: 1000, reward: { type: 'accessory', id: 'crown', name: 'Legend Crown' } }
          ]
        }
      },

      init() {
        this.loadCareerSlots();
        this.setupEventListeners();
      },

      loadCareerSlots() {
        try {
          const saved = localStorage.getItem(this.storageKey);
          this.careerSlots = saved ? JSON.parse(saved) : [];
        } catch (e) {
          console.error('Failed to load career slots:', e);
          this.careerSlots = [];
        }
      },

      saveCareerSlots() {
        try {
          localStorage.setItem(this.storageKey, JSON.stringify(this.careerSlots));
        } catch (e) {
          console.error('Failed to save career slots:', e);
        }
      },

      saveActiveCareer() {
        if (!this.activeCareer) return;
        this.activeCareer.lastPlayedAt = Date.now();
        const index = this.careerSlots.findIndex(s => s.careerSlotId === this.activeCareer.careerSlotId);
        if (index >= 0) {
          this.careerSlots[index] = this.activeCareer;
        } else {
          this.careerSlots.push(this.activeCareer);
        }
        this.saveCareerSlots();
      },

      deleteCareer(careerSlotId) {
        this.careerSlots = this.careerSlots.filter(s => s.careerSlotId !== careerSlotId);
        this.saveCareerSlots();
        this.populateCareerSlots();
      },

      createNewCareer(name, character) {
        const career = {
          careerSlotId: Date.now().toString(),
          playerName: name || 'Golfer',
          createdAt: Date.now(),
          lastPlayedAt: Date.now(),
          character: {
            gender: character.gender || 'boy',
            skinTone: character.skinTone || 2,
            skinHex: character.skinHex || null,
            hairstyle: character.hairstyle || 0,
            hairColor: character.hairColor || null,
            facialHair: character.facialHair || null,
            beardColor: character.beardColor || null,
            outfitShirt: character.outfitShirt || '#E53935',
            outfitPants: character.outfitPants || '#1565C0',
            accessories: []
          },
          currentTour: 'local',
          currentSeason: 1,
          seasonWeek: 1,
          rankingPoints: 0,
          tourRanking: 100,
          careerGolfBucks: 15,
          tourCoins: 0,
          rival: {
            name: 'Ace McStroke',
            encounterCount: 0,
            winsAgainst: 0,
            lossesAgainst: 0,
            storyPhase: 0
          },
          equipmentSponsor: null,
          apparelSponsor: null,
          unlockedShirtColors: [],
          unlockedPantsColors: [],
          unlockedAccessories: ['visor'],
          equipmentBonuses: { power: 0, accuracy: 0 },
          stats: {
            roundsPlayed: 0,
            tournamentsWon: 0,
            totalEarnings: 0,
            bestScore: null,
            holesInOne: 0,
            eagles: 0,
            birdies: 0
          },
          tourHistory: [],
          milestones: {},
          storyFlags: {}
        };

        this.activeCareer = career;
        this.careerSlots.push(career);
        this.saveCareerSlots();
        return career;
      },

      setupEventListeners() {
        // Career Mode button
        document.getElementById('career-play-btn')?.addEventListener('click', () => {
          document.getElementById('game-mode-overlay').classList.add('hidden');
          this.showCareerEntry();
        });

        // Career entry buttons
        document.getElementById('new-career-btn')?.addEventListener('click', () => {
          document.getElementById('career-entry-overlay').classList.add('hidden');
          this.showCharacterCreator();
        });

        document.getElementById('career-back-btn')?.addEventListener('click', () => {
          document.getElementById('career-entry-overlay').classList.add('hidden');
          document.getElementById('game-mode-overlay').classList.remove('hidden');
        });

        // Character creator buttons
        document.getElementById('create-career-btn')?.addEventListener('click', () => {
          this.createCareerFromCreator();
        });

        document.getElementById('creator-back-btn')?.addEventListener('click', () => {
          document.getElementById('character-creator-overlay').classList.add('hidden');
          this.showCareerEntry();
        });

        // Hub buttons
        document.getElementById('hub-play-tournament-btn')?.addEventListener('click', () => {
          this.showTournamentSelection();
        });

        document.getElementById('hub-back-btn')?.addEventListener('click', () => {
          this.saveActiveCareer();
          document.getElementById('career-hub-overlay').classList.add('hidden');
          document.getElementById('game-mode-overlay').classList.remove('hidden');
        });

        // Shop button (Customize)
        document.getElementById('hub-customize-btn')?.addEventListener('click', () => {
          this.openShop();
        });

        // Shop event handlers
        document.getElementById('shop-back-btn')?.addEventListener('click', () => {
          this.closeShop();
        });

        document.querySelectorAll('.shop-tab').forEach(tab => {
          tab.addEventListener('click', () => {
            this.switchShopTab(tab.dataset.tab);
          });
        });

        document.getElementById('shop-action-btn')?.addEventListener('click', () => {
          this.shopAction();
        });

        // Sponsors button
        document.getElementById('hub-sponsors-btn')?.addEventListener('click', () => {
          this.showSponsors();
        });

        document.getElementById('sponsors-back-btn')?.addEventListener('click', () => {
          document.getElementById('sponsors-overlay').classList.add('hidden');
          this.showCareerHub();
        });

        document.getElementById('career-tournament-back-btn')?.addEventListener('click', () => {
          document.getElementById('career-tournament-overlay').classList.add('hidden');
          this.showCareerHub();
        });

        // Dialogue continue
        document.getElementById('dialogue-continue-btn')?.addEventListener('click', () => {
          this.continueDialogue();
        });

        // Sponsor decline
        document.getElementById('sponsor-decline-btn')?.addEventListener('click', () => {
          document.getElementById('sponsor-offer-overlay').classList.add('hidden');
        });

        // Gender options - update hairstyles when gender changes
        document.getElementById('gender-options')?.addEventListener('click', (e) => {
          const btn = e.target.closest('.gender-btn');
          if (btn) {
            document.querySelectorAll('#gender-options .gender-btn').forEach(b => b.classList.remove('selected'));
            btn.classList.add('selected');
            this.updateHairstyleOptions(); // Show correct sprites for selected gender
            this.updateFacialHairOptions(); // Show/hide facial hair for boys only
            this.updateCharacterPreview();
          }
        });
      },

      async showCareerEntry() {
        // Load sprites first
        await this.loadSprites();
        document.getElementById('career-entry-overlay').classList.remove('hidden');
        this.populateCareerSlots();
      },

      populateCareerSlots() {
        const container = document.getElementById('career-slots');
        container.innerHTML = '';

        this.careerSlots.forEach(career => {
          const slot = document.createElement('div');
          slot.className = 'career-slot';
          slot.innerHTML = `
            <canvas class="career-slot-avatar" width="50" height="65"></canvas>
            <div class="career-slot-info">
              <div class="career-slot-name">${career.playerName}</div>
              <div class="career-slot-details">${this.tours[career.currentTour].name} â€¢ $${career.careerGolfBucks}</div>
            </div>
            <button class="career-slot-delete" title="Delete Career">âœ•</button>
          `;

          // Click slot to load career
          slot.addEventListener('click', (e) => {
            if (e.target.classList.contains('career-slot-delete')) return;
            this.activeCareer = career;
            document.getElementById('career-entry-overlay').classList.add('hidden');
            this.showCareerHub();
          });

          // Delete button
          slot.querySelector('.career-slot-delete').addEventListener('click', (e) => {
            e.stopPropagation();
            if (confirm(`Delete ${career.playerName}'s career? This cannot be undone.`)) {
              this.deleteCareer(career.careerSlotId);
            }
          });

          container.appendChild(slot);

          // Draw avatar on the slot canvas
          const canvas = slot.querySelector('canvas');
          this.drawCharacterAvatar(canvas, career.character);
        });

        if (this.careerSlots.length < this.maxSlots) {
          const emptySlot = document.createElement('div');
          emptySlot.className = 'career-slot empty';
          emptySlot.textContent = '+ New Career';
          emptySlot.addEventListener('click', () => {
            document.getElementById('career-entry-overlay').classList.add('hidden');
            this.showCharacterCreator();
          });
          container.appendChild(emptySlot);
        }
      },

      async showCharacterCreator() {
        // Load sprites first
        await this.loadSprites();
        document.getElementById('character-creator-overlay').classList.remove('hidden');
        this.populateCreatorOptions();
        this.updateCharacterPreview();
      },

      populateCreatorOptions() {
        // Skin tones (index 0 = "Original" is default)
        const skinContainer = document.getElementById('skin-options');
        skinContainer.innerHTML = '';
        this.skinTones.forEach((tone, i) => {
          const opt = document.createElement('div');
          opt.className = 'color-option' + (i === 0 ? ' selected' : '');
          if (tone.hex === null) {
            // "Original" option - show slash through circle
            opt.style.background = 'transparent';
            opt.style.border = '2px solid rgba(255,255,255,0.5)';
            opt.style.position = 'relative';
            opt.innerHTML = '<div style="position:absolute;top:50%;left:50%;width:120%;height:2px;background:rgba(255,255,255,0.7);transform:translate(-50%,-50%) rotate(-45deg);"></div>';
            opt.title = 'Original (sprite default)';
          } else {
            opt.style.backgroundColor = tone.hex;
          }
          opt.dataset.value = i;
          opt.addEventListener('click', () => {
            skinContainer.querySelectorAll('.color-option').forEach(o => o.classList.remove('selected'));
            opt.classList.add('selected');
            this.updateCharacterPreview();
          });
          skinContainer.appendChild(opt);
        });

        // Hair colors (index 0 = "Original" is default)
        const hairColorContainer = document.getElementById('hair-color-options');
        hairColorContainer.innerHTML = '';
        this.hairColors.forEach((color, i) => {
          const opt = document.createElement('div');
          opt.className = 'color-option' + (i === 0 ? ' selected' : '');
          if (color.hex === null) {
            // "Original" option - show slash through circle
            opt.style.background = 'transparent';
            opt.style.border = '2px solid rgba(255,255,255,0.5)';
            opt.style.position = 'relative';
            opt.innerHTML = '<div style="position:absolute;top:50%;left:50%;width:120%;height:2px;background:rgba(255,255,255,0.7);transform:translate(-50%,-50%) rotate(-45deg);"></div>';
            opt.title = 'Original (sprite default)';
          } else {
            opt.style.backgroundColor = color.hex;
          }
          opt.dataset.value = color.hex || 'original';
          opt.addEventListener('click', () => {
            hairColorContainer.querySelectorAll('.color-option').forEach(o => o.classList.remove('selected'));
            opt.classList.add('selected');
            this.updateCharacterPreview();
          });
          hairColorContainer.appendChild(opt);
        });

        // Hairstyles
        this.updateHairstyleOptions();

        // Facial hair options
        this.updateFacialHairOptions();

        // Shirt colors
        const shirtContainer = document.getElementById('shirt-options');
        shirtContainer.innerHTML = '';
        this.shirtColors.forEach((color, i) => {
          const opt = document.createElement('div');
          opt.className = 'color-option' + (i === 0 ? ' selected' : '');
          opt.style.backgroundColor = color;
          opt.dataset.value = color;
          opt.addEventListener('click', () => {
            shirtContainer.querySelectorAll('.color-option').forEach(o => o.classList.remove('selected'));
            opt.classList.add('selected');
            this.updateCharacterPreview();
          });
          shirtContainer.appendChild(opt);
        });

        // Pants colors
        const pantsContainer = document.getElementById('pants-options');
        pantsContainer.innerHTML = '';
        this.pantsColors.forEach((color, i) => {
          const opt = document.createElement('div');
          opt.className = 'color-option' + (i === 0 ? ' selected' : '');
          opt.style.backgroundColor = color;
          opt.dataset.value = color;
          opt.addEventListener('click', () => {
            pantsContainer.querySelectorAll('.color-option').forEach(o => o.classList.remove('selected'));
            opt.classList.add('selected');
            this.updateCharacterPreview();
          });
          pantsContainer.appendChild(opt);
        });
      },

      updateHairstyleOptions() {
        const gender = document.querySelector('#gender-options .gender-btn.selected')?.dataset.value || 'boy';
        const container = document.getElementById('hair-style-options');
        container.innerHTML = '';
        this.hairstyles[gender].forEach((style, i) => {
          const opt = document.createElement('div');
          opt.className = 'style-option' + (i === 0 ? ' selected' : '');
          opt.dataset.value = i;
          opt.title = style.name;

          // Use sprite image if available
          if (style.file && this.avatarSprites[style.file]) {
            const img = document.createElement('img');
            img.src = `sprites/${style.file}`;
            img.style.width = '100%';
            img.style.height = '100%';
            img.style.objectFit = 'contain';
            opt.appendChild(img);
          } else if (style.file) {
            // Fallback to direct image load
            const img = document.createElement('img');
            img.src = `sprites/${style.file}`;
            img.style.width = '100%';
            img.style.height = '100%';
            img.style.objectFit = 'contain';
            opt.appendChild(img);
          } else {
            opt.textContent = 'ðŸ‘¤';
          }

          opt.addEventListener('click', () => {
            container.querySelectorAll('.style-option').forEach(o => o.classList.remove('selected'));
            opt.classList.add('selected');
            this.updateCharacterPreview();
          });
          container.appendChild(opt);
        });
      },

      updateFacialHairOptions() {
        const gender = document.querySelector('#gender-options .gender-btn.selected')?.dataset.value || 'boy';
        const section = document.getElementById('facial-hair-section');
        const container = document.getElementById('facial-hair-options');

        // Only show facial hair for boys
        if (gender === 'girl') {
          section.style.display = 'none';
          return;
        }
        section.style.display = 'block';

        container.innerHTML = '';
        this.facialHairOptions.forEach((option, i) => {
          const opt = document.createElement('div');
          opt.className = 'style-option facial-hair-option' + (i === 0 ? ' selected' : '');
          opt.dataset.value = option.type || 'none';
          opt.title = option.name;

          // Create canvas for visual icon
          const canvas = document.createElement('canvas');
          canvas.width = 36;
          canvas.height = 36;
          canvas.style.width = '100%';
          canvas.style.height = '100%';
          opt.appendChild(canvas);

          // Draw the facial hair icon
          const ctx = canvas.getContext('2d');
          const cx = 18, cy = 18;
          const hairColor = '#4A3728';

          // Draw face outline (light)
          ctx.fillStyle = '#FFDAB9';
          ctx.beginPath();
          ctx.arc(cx, cy - 2, 14, 0, Math.PI * 2);
          ctx.fill();

          // Draw eyes
          ctx.fillStyle = '#333';
          ctx.beginPath();
          ctx.arc(cx - 5, cy - 5, 2, 0, Math.PI * 2);
          ctx.arc(cx + 5, cy - 5, 2, 0, Math.PI * 2);
          ctx.fill();

          // Draw smile
          ctx.strokeStyle = '#333';
          ctx.lineWidth = 1.5;
          ctx.beginPath();
          ctx.arc(cx, cy + 2, 5, 0.2, Math.PI - 0.2);
          ctx.stroke();

          // Draw facial hair based on type
          ctx.fillStyle = hairColor;
          ctx.strokeStyle = hairColor;
          const mouthY = cy + 2;

          if (option.type === null) {
            // None - just clean face, nothing to draw
          } else if (option.type === 'stubble') {
            // Stubble - dots pattern
            ctx.globalAlpha = 0.6;
            const dots = [[-6,3],[-3,2],[0,3],[3,2],[6,3],[-5,6],[-2,5],[1,6],[4,5],[-4,9],[-1,8],[2,9],[0,11]];
            dots.forEach(([dx, dy]) => {
              ctx.beginPath();
              ctx.arc(cx + dx, mouthY + dy, 0.8, 0, Math.PI * 2);
              ctx.fill();
            });
            ctx.globalAlpha = 1;
          } else if (option.type === 'beard') {
            // Full beard
            ctx.beginPath();
            ctx.moveTo(cx - 10, mouthY - 1);
            ctx.quadraticCurveTo(cx - 12, mouthY + 6, cx - 8, mouthY + 10);
            ctx.quadraticCurveTo(cx, mouthY + 14, cx + 8, mouthY + 10);
            ctx.quadraticCurveTo(cx + 12, mouthY + 6, cx + 10, mouthY - 1);
            ctx.fill();
            // Mustache part
            ctx.beginPath();
            ctx.moveTo(cx - 7, mouthY);
            ctx.quadraticCurveTo(cx, mouthY - 3, cx + 7, mouthY);
            ctx.quadraticCurveTo(cx, mouthY + 2, cx - 7, mouthY);
            ctx.fill();
          } else if (option.type === 'goatee') {
            // Goatee
            ctx.beginPath();
            ctx.moveTo(cx - 5, mouthY + 3);
            ctx.quadraticCurveTo(cx - 5, mouthY + 8, cx, mouthY + 12);
            ctx.quadraticCurveTo(cx + 5, mouthY + 8, cx + 5, mouthY + 3);
            ctx.fill();
            // Small mustache
            ctx.beginPath();
            ctx.moveTo(cx - 5, mouthY + 1);
            ctx.quadraticCurveTo(cx, mouthY - 2, cx + 5, mouthY + 1);
            ctx.quadraticCurveTo(cx, mouthY + 3, cx - 5, mouthY + 1);
            ctx.fill();
          } else if (option.type === 'mustache') {
            // Handlebar mustache
            ctx.beginPath();
            ctx.moveTo(cx - 9, mouthY + 2);
            ctx.quadraticCurveTo(cx - 5, mouthY - 2, cx, mouthY);
            ctx.quadraticCurveTo(cx + 5, mouthY - 2, cx + 9, mouthY + 2);
            ctx.quadraticCurveTo(cx + 5, mouthY + 4, cx, mouthY + 2);
            ctx.quadraticCurveTo(cx - 5, mouthY + 4, cx - 9, mouthY + 2);
            ctx.fill();
          } else if (option.type === 'soulpatch') {
            // Soul patch
            ctx.beginPath();
            ctx.moveTo(cx - 2, mouthY + 4);
            ctx.quadraticCurveTo(cx, mouthY + 10, cx + 2, mouthY + 4);
            ctx.quadraticCurveTo(cx, mouthY + 5, cx - 2, mouthY + 4);
            ctx.fill();
          }

          opt.addEventListener('click', () => {
            container.querySelectorAll('.style-option').forEach(o => o.classList.remove('selected'));
            opt.classList.add('selected');
            // Show/hide beard color section and populate options
            const beardSection = document.getElementById('beard-color-section');
            if (beardSection) {
              if (option.type === null) {
                beardSection.style.display = 'none';
              } else {
                beardSection.style.display = 'block';
                this.setupBeardColorOptions('boy'); // Populate options when showing
              }
            }
            this.updateCharacterPreview();
          });
          container.appendChild(opt);
        });

        // Setup beard color options
        this.setupBeardColorOptions(gender);
      },

      setupBeardColorOptions(gender) {
        const section = document.getElementById('beard-color-section');
        const container = document.getElementById('beard-color-options');
        if (!section || !container) return;

        // Hide for girls or if no facial hair selected
        const facialHairValue = document.querySelector('#facial-hair-options .style-option.selected')?.dataset.value;
        if (gender === 'girl' || !facialHairValue || facialHairValue === 'none') {
          section.style.display = 'none';
          return;
        }
        section.style.display = 'block';

        container.innerHTML = '';
        this.beardColors.forEach((color, i) => {
          const opt = document.createElement('div');
          opt.className = 'color-option' + (i === 0 ? ' selected' : '');
          if (color.hex === null) {
            // "Match Hair" option - show link icon
            opt.style.background = 'linear-gradient(135deg, #4A3728 50%, #8B7355 50%)';
            opt.title = 'Match Hair Color';
          } else {
            opt.style.background = color.hex;
          }
          opt.dataset.value = color.hex || 'match';
          opt.title = color.name;
          opt.addEventListener('click', () => {
            container.querySelectorAll('.color-option').forEach(o => o.classList.remove('selected'));
            opt.classList.add('selected');
            this.updateCharacterPreview();
          });
          container.appendChild(opt);
        });
      },

      getCreatorSelections() {
        const gender = document.querySelector('#gender-options .gender-btn.selected')?.dataset.value || 'boy';
        const hairstyle = parseInt(document.querySelector('#hair-style-options .style-option.selected')?.dataset.value || '0');

        // Get user's selected skin tone (null = use sprite's original)
        const skinToneIndex = parseInt(document.querySelector('#skin-options .color-option.selected')?.dataset.value || '0');
        const selectedSkinHex = this.skinTones[skinToneIndex]?.hex; // Can be null for "Original"

        // Get user's selected hair color (null/"original" = use sprite's original)
        const hairColorValue = document.querySelector('#hair-color-options .color-option.selected')?.dataset.value;
        const selectedHairHex = (hairColorValue === 'original' || !hairColorValue) ? null : hairColorValue;

        // Get facial hair selection (boys only)
        const facialHairValue = document.querySelector('#facial-hair-options .style-option.selected')?.dataset.value;
        const facialHair = (facialHairValue === 'none' || !facialHairValue) ? null : facialHairValue;

        // Get beard color selection (null/"match" = derive from hair color)
        const beardColorValue = document.querySelector('#beard-color-options .color-option.selected')?.dataset.value;
        const beardColor = (beardColorValue === 'match' || !beardColorValue) ? null : beardColorValue;

        return {
          gender,
          skinTone: skinToneIndex,
          skinHex: selectedSkinHex, // null means keep sprite's original
          hairstyle,
          hairColor: selectedHairHex, // null means keep sprite's original
          facialHair: gender === 'boy' ? facialHair : null, // Only boys can have facial hair
          beardColor: gender === 'boy' ? beardColor : null, // null means match hair color
          outfitShirt: document.querySelector('#shirt-options .color-option.selected')?.dataset.value || '#E53935',
          outfitPants: document.querySelector('#pants-options .color-option.selected')?.dataset.value || '#1565C0'
        };
      },

      async updateCharacterPreview() {
        const canvas = document.getElementById('character-preview-canvas');
        if (!canvas) return;
        const character = this.getCreatorSelections();
        await this.drawCharacter(canvas, character, 'idle');
      },

      async drawCharacterAvatar(canvas, character, scale = 0.6) {
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        const size = Math.min(canvas.width, canvas.height);

        // Get sprite file for this character (with custom hair and skin colors)
        const gender = character.gender || 'boy';
        const hairstyle = character.hairstyle || 0;
        const spriteInfo = this.spriteMap[gender]?.[hairstyle];
        const hairColor = character.hairColor;
        const skinColor = character.skinHex;
        // Always use recolored sprite if we have hair or skin customization
        const sprite = spriteInfo
          ? await this.getRecoloredSprite(spriteInfo, hairColor, skinColor)
          : this.avatarSprites[spriteInfo?.file];

        // Background circle
        ctx.fillStyle = '#2a3a4a';
        ctx.beginPath();
        ctx.arc(centerX, centerY, size / 2 - 2, 0, Math.PI * 2);
        ctx.fill();

        const spriteSize = size * 0.85;
        const spriteX = centerX - spriteSize / 2;
        const spriteY = centerY - spriteSize / 2 - size * 0.08;
        const clipCutoff = 0.82; // Show top 82% of sprite (matches full body preview)

        // Draw sprite with 3-layer approach for long hair
        if (sprite) {
          // LAYER 1: Draw full sprite first (long hair goes BEHIND)
          ctx.drawImage(sprite, spriteX, spriteY, spriteSize, spriteSize);

          // LAYER 2: Shirt/shoulders (covers bottom of sprite)
          ctx.fillStyle = character.outfitShirt || '#E53935';
          ctx.beginPath();
          ctx.arc(centerX, centerY + size * 0.42, size * 0.35, 0, Math.PI, true);
          ctx.fill();

          // LAYER 2.5: Outfit design overlay on shirt
          if (character.outfitDesign) {
            ctx.save();
            ctx.beginPath();
            ctx.arc(centerX, centerY + size * 0.42, size * 0.34, 0, Math.PI, true);
            ctx.clip();
            const ds = size / 80; // design scale
            if (character.outfitDesign === 'stripes') {
              ctx.strokeStyle = character.outfitStripeColor || '#FFFFFF';
              ctx.lineWidth = 2 * ds;
              ctx.beginPath();
              ctx.moveTo(centerX - 3 * ds, centerY + size * 0.15);
              ctx.lineTo(centerX - 3 * ds, centerY + size * 0.5);
              ctx.stroke();
              ctx.beginPath();
              ctx.moveTo(centerX + 3 * ds, centerY + size * 0.15);
              ctx.lineTo(centerX + 3 * ds, centerY + size * 0.5);
              ctx.stroke();
            } else if (character.outfitDesign === 'stars') {
              ctx.fillStyle = character.outfitPatternColor || '#FFD700';
              const drawStar = (cx, cy, r) => {
                ctx.beginPath();
                for (let i = 0; i < 10; i++) {
                  const rad = i % 2 === 0 ? r : r * 0.4;
                  const angle = (i * Math.PI) / 5 - Math.PI / 2;
                  if (i === 0) ctx.moveTo(cx + rad * Math.cos(angle), cy + rad * Math.sin(angle));
                  else ctx.lineTo(cx + rad * Math.cos(angle), cy + rad * Math.sin(angle));
                }
                ctx.closePath();
                ctx.fill();
              };
              drawStar(centerX, centerY + size * 0.32, 4 * ds);
            } else if (character.outfitDesign === 'lightning') {
              ctx.fillStyle = character.outfitPatternColor || '#FFEB3B';
              ctx.beginPath();
              ctx.moveTo(centerX + 2 * ds, centerY + size * 0.2);
              ctx.lineTo(centerX - 3 * ds, centerY + size * 0.32);
              ctx.lineTo(centerX, centerY + size * 0.32);
              ctx.lineTo(centerX - 4 * ds, centerY + size * 0.45);
              ctx.lineTo(centerX + 1 * ds, centerY + size * 0.35);
              ctx.lineTo(centerX - 1 * ds, centerY + size * 0.35);
              ctx.lineTo(centerX + 4 * ds, centerY + size * 0.2);
              ctx.closePath();
              ctx.fill();
            } else if (character.outfitDesign === 'flames') {
              ctx.fillStyle = '#FF9800';
              for (let i = -1; i <= 1; i++) {
                ctx.beginPath();
                ctx.moveTo(centerX + i * 8 * ds - 3 * ds, centerY + size * 0.5);
                ctx.quadraticCurveTo(centerX + i * 8 * ds, centerY + size * 0.28, centerX + i * 8 * ds + 3 * ds, centerY + size * 0.5);
                ctx.fill();
              }
            } else if (character.outfitDesign === 'champion') {
              ctx.fillStyle = '#FFFFFF';
              ctx.beginPath();
              ctx.arc(centerX, centerY + size * 0.32, 6 * ds, 0, Math.PI * 2);
              ctx.fill();
              ctx.fillStyle = '#FFD700';
              ctx.font = `bold ${8 * ds}px Arial`;
              ctx.textAlign = 'center';
              ctx.fillText('â˜…', centerX, centerY + size * 0.35);
            } else if (character.outfitDesign === 'tiger') {
              ctx.strokeStyle = '#000000';
              ctx.lineWidth = 1.5 * ds;
              ctx.lineCap = 'round';
              for (let i = -1; i <= 1; i++) {
                ctx.beginPath();
                ctx.moveTo(centerX + i * 10 * ds - 4 * ds, centerY + size * 0.25);
                ctx.lineTo(centerX + i * 10 * ds, centerY + size * 0.3);
                ctx.lineTo(centerX + i * 10 * ds - 3 * ds, centerY + size * 0.38);
                ctx.stroke();
              }
            }
            ctx.restore();
          }

          // LAYER 3: Draw upper portion of sprite (head + top hair)
          ctx.save();
          ctx.beginPath();
          ctx.rect(spriteX, spriteY, spriteSize, spriteSize * clipCutoff);
          ctx.clip();
          ctx.drawImage(sprite, spriteX, spriteY, spriteSize, spriteSize);
          ctx.restore();

        } else {
          // Fallback: Shirt/shoulders at bottom
          ctx.fillStyle = character.outfitShirt || '#E53935';
          ctx.beginPath();
          ctx.arc(centerX, centerY + size * 0.42, size * 0.35, 0, Math.PI, true);
          ctx.fill();
          // Fallback: simple head drawing - use character's skinHex, or sprite's original if "Original" selected
          const skinTone = character.skinHex || spriteInfo?.skinHex || this.skinTones[character.skinTone]?.hex || '#D4A574';

          // Head
          ctx.fillStyle = skinTone;
          ctx.beginPath();
          ctx.ellipse(centerX, centerY - size * 0.02, size * 0.28, size * 0.32, 0, 0, Math.PI * 2);
          ctx.fill();

          // Hair
          ctx.fillStyle = character.hairColor || '#4A3728';
          ctx.beginPath();
          ctx.arc(centerX, centerY - size * 0.2, size * 0.22, Math.PI + 0.3, -0.3);
          ctx.fill();

          // Eyes
          ctx.fillStyle = '#333';
          ctx.beginPath();
          ctx.arc(centerX - size * 0.1, centerY - size * 0.05, size * 0.04, 0, Math.PI * 2);
          ctx.arc(centerX + size * 0.1, centerY - size * 0.05, size * 0.04, 0, Math.PI * 2);
          ctx.fill();

          // Smile
          ctx.strokeStyle = '#333';
          ctx.lineWidth = 2;
          ctx.lineCap = 'round';
          ctx.beginPath();
          ctx.arc(centerX, centerY + size * 0.16, size * 0.08, 0.3, Math.PI - 0.3);
          ctx.stroke();
        }

        // LAYER 3.5: Draw facial hair (boys only)
        if (character.facialHair && character.gender !== 'girl') {
          const hairColor = character.hairColor || '#4A3728';
          // Use custom beard color if set, otherwise darken hair color
          const facialHairColor = character.beardColor || this.darkenColor(hairColor, 10);
          const facialHairDark = character.beardColor ? this.darkenColor(character.beardColor, 15) : this.darkenColor(hairColor, 25);
          // Position to overlay the mouth on avatar
          const mouthY = centerY + size * 0.02;
          const chinY = centerY + size * 0.10;
          const sc = size / 100; // Scale factor

          ctx.save();

          if (character.facialHair === 'stubble') {
            // 5 o'clock shadow - dense stippling pattern
            ctx.fillStyle = facialHairColor;
            ctx.globalAlpha = 0.65;
            const stubblePoints = [
              [-18, 2], [-14, 0], [-10, -2], [-6, 0], [-2, -2], [2, 0], [6, -2], [10, 0], [14, 0], [18, 2],
              [-20, 6], [-16, 4], [-12, 6], [-8, 4], [-4, 6], [0, 4], [4, 6], [8, 4], [12, 6], [16, 4], [20, 5],
              [-18, 10], [-14, 8], [-10, 10], [-6, 8], [-2, 10], [2, 8], [6, 10], [10, 8], [14, 10], [18, 9],
              [-16, 14], [-12, 12], [-8, 14], [-4, 12], [0, 14], [4, 12], [8, 14], [12, 12], [16, 13],
              [-12, 18], [-8, 16], [-4, 18], [0, 16], [4, 18], [8, 16], [12, 17],
              [-8, 22], [-4, 20], [0, 22], [4, 20], [8, 21],
              [-4, 26], [0, 24], [4, 26]
            ];
            stubblePoints.forEach(([px, py]) => {
              ctx.beginPath();
              ctx.arc(centerX + px * sc, mouthY + py * sc, 1.2 * sc, 0, Math.PI * 2);
              ctx.fill();
            });
            ctx.globalAlpha = 1;
          } else if (character.facialHair === 'beard') {
            // Natural beard with mouth opening
            ctx.fillStyle = facialHairColor;

            // Left side of beard
            ctx.beginPath();
            ctx.moveTo(centerX - 18 * sc, mouthY - 2 * sc);
            ctx.quadraticCurveTo(centerX - 20 * sc, mouthY + 6 * sc, centerX - 16 * sc, chinY + 2 * sc);
            ctx.quadraticCurveTo(centerX - 8 * sc, chinY + 8 * sc, centerX - 4 * sc, chinY + 10 * sc);
            ctx.lineTo(centerX - 4 * sc, mouthY + 6 * sc);
            ctx.quadraticCurveTo(centerX - 10 * sc, mouthY + 4 * sc, centerX - 18 * sc, mouthY - 2 * sc);
            ctx.fill();

            // Right side of beard
            ctx.beginPath();
            ctx.moveTo(centerX + 18 * sc, mouthY - 2 * sc);
            ctx.quadraticCurveTo(centerX + 20 * sc, mouthY + 6 * sc, centerX + 16 * sc, chinY + 2 * sc);
            ctx.quadraticCurveTo(centerX + 8 * sc, chinY + 8 * sc, centerX + 4 * sc, chinY + 10 * sc);
            ctx.lineTo(centerX + 4 * sc, mouthY + 6 * sc);
            ctx.quadraticCurveTo(centerX + 10 * sc, mouthY + 4 * sc, centerX + 18 * sc, mouthY - 2 * sc);
            ctx.fill();

            // Chin beard (below mouth)
            ctx.beginPath();
            ctx.moveTo(centerX - 6 * sc, mouthY + 6 * sc);
            ctx.quadraticCurveTo(centerX - 8 * sc, chinY + 6 * sc, centerX, chinY + 12 * sc);
            ctx.quadraticCurveTo(centerX + 8 * sc, chinY + 6 * sc, centerX + 6 * sc, mouthY + 6 * sc);
            ctx.lineTo(centerX - 6 * sc, mouthY + 6 * sc);
            ctx.fill();

            // Mustache (above mouth) - positioned higher
            ctx.beginPath();
            ctx.moveTo(centerX - 12 * sc, mouthY - 2 * sc);
            ctx.quadraticCurveTo(centerX - 6 * sc, mouthY - 6 * sc, centerX, mouthY - 5 * sc);
            ctx.quadraticCurveTo(centerX + 6 * sc, mouthY - 6 * sc, centerX + 12 * sc, mouthY - 2 * sc);
            ctx.quadraticCurveTo(centerX + 6 * sc, mouthY - 1 * sc, centerX, mouthY - 2 * sc);
            ctx.quadraticCurveTo(centerX - 6 * sc, mouthY - 1 * sc, centerX - 12 * sc, mouthY - 2 * sc);
            ctx.fill();
          } else if (character.facialHair === 'goatee') {
            // Classic goatee
            ctx.fillStyle = facialHairColor;
            // Chin portion
            ctx.beginPath();
            ctx.moveTo(centerX - 10 * sc, mouthY + 8 * sc);
            ctx.quadraticCurveTo(centerX - 12 * sc, chinY + 8 * sc, centerX, chinY + 20 * sc);
            ctx.quadraticCurveTo(centerX + 12 * sc, chinY + 8 * sc, centerX + 10 * sc, mouthY + 8 * sc);
            ctx.quadraticCurveTo(centerX + 4 * sc, mouthY + 12 * sc, centerX, mouthY + 10 * sc);
            ctx.quadraticCurveTo(centerX - 4 * sc, mouthY + 12 * sc, centerX - 10 * sc, mouthY + 8 * sc);
            ctx.fill();
            // Small mustache
            ctx.beginPath();
            ctx.moveTo(centerX - 10 * sc, mouthY + 2 * sc);
            ctx.quadraticCurveTo(centerX, mouthY - 4 * sc, centerX + 10 * sc, mouthY + 2 * sc);
            ctx.quadraticCurveTo(centerX, mouthY + 6 * sc, centerX - 10 * sc, mouthY + 2 * sc);
            ctx.fill();
          } else if (character.facialHair === 'mustache') {
            // Thick handlebar mustache
            ctx.fillStyle = facialHairColor;
            // Left side
            ctx.beginPath();
            ctx.moveTo(centerX - 18 * sc, mouthY + 4 * sc);
            ctx.quadraticCurveTo(centerX - 12 * sc, mouthY - 4 * sc, centerX - 4 * sc, mouthY - 2 * sc);
            ctx.lineTo(centerX, mouthY);
            ctx.lineTo(centerX - 4 * sc, mouthY + 4 * sc);
            ctx.quadraticCurveTo(centerX - 10 * sc, mouthY + 6 * sc, centerX - 18 * sc, mouthY + 4 * sc);
            ctx.fill();
            // Right side
            ctx.beginPath();
            ctx.moveTo(centerX + 18 * sc, mouthY + 4 * sc);
            ctx.quadraticCurveTo(centerX + 12 * sc, mouthY - 4 * sc, centerX + 4 * sc, mouthY - 2 * sc);
            ctx.lineTo(centerX, mouthY);
            ctx.lineTo(centerX + 4 * sc, mouthY + 4 * sc);
            ctx.quadraticCurveTo(centerX + 10 * sc, mouthY + 6 * sc, centerX + 18 * sc, mouthY + 4 * sc);
            ctx.fill();
            // Center
            ctx.beginPath();
            ctx.arc(centerX, mouthY, 4 * sc, 0, Math.PI * 2);
            ctx.fill();
          } else if (character.facialHair === 'soulpatch') {
            // Soul patch below lip
            ctx.fillStyle = facialHairColor;
            ctx.beginPath();
            ctx.moveTo(centerX - 4 * sc, mouthY + 8 * sc);
            ctx.quadraticCurveTo(centerX, mouthY + 20 * sc, centerX + 4 * sc, mouthY + 8 * sc);
            ctx.quadraticCurveTo(centerX, mouthY + 10 * sc, centerX - 4 * sc, mouthY + 8 * sc);
            ctx.fill();
          }
          ctx.restore();
        }

        // LAYER 4: Draw accessories (hats and glasses) on avatar
        const equippedHat = character.equippedHat;
        const equippedGlasses = character.equippedGlasses;
        const accScale = size / 70; // Larger scale for avatar accessories

        // Draw glasses on face - positioned over the eyes
        if (equippedGlasses) {
          ctx.save();
          const eyeY = centerY - size * 0.05; // Eye level in avatar
          const eyeSpacing = size * 0.10; // Distance between eyes
          const gs = size / 60; // Glass scale factor

          ctx.translate(centerX, eyeY);

          if (equippedGlasses === 'sunglasses' || equippedGlasses === 'sport_shades') {
            // Sleek wraparound sunglasses
            ctx.fillStyle = '#1a1a1a';
            // Left lens
            ctx.beginPath();
            ctx.ellipse(-eyeSpacing, 0, 9 * gs, 5 * gs, -0.1, 0, Math.PI * 2);
            ctx.fill();
            // Right lens
            ctx.beginPath();
            ctx.ellipse(eyeSpacing, 0, 9 * gs, 5 * gs, 0.1, 0, Math.PI * 2);
            ctx.fill();
            // Bridge
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2 * gs;
            ctx.beginPath();
            ctx.moveTo(-eyeSpacing + 7 * gs, -1 * gs);
            ctx.quadraticCurveTo(0, -3 * gs, eyeSpacing - 7 * gs, -1 * gs);
            ctx.stroke();
            // Lens shine
            ctx.strokeStyle = 'rgba(255,255,255,0.3)';
            ctx.lineWidth = 1.5 * gs;
            ctx.beginPath();
            ctx.arc(-eyeSpacing - 2 * gs, -1 * gs, 3 * gs, Math.PI * 0.8, Math.PI * 1.4);
            ctx.stroke();
          } else if (equippedGlasses === 'aviators') {
            // Classic aviator shape with gold frame
            ctx.strokeStyle = '#C0A060';
            ctx.lineWidth = 2 * gs;
            // Left lens
            ctx.fillStyle = 'rgba(80, 60, 40, 0.7)';
            ctx.beginPath();
            ctx.moveTo(-eyeSpacing - 8 * gs, -4 * gs);
            ctx.quadraticCurveTo(-eyeSpacing - 10 * gs, 3 * gs, -eyeSpacing, 6 * gs);
            ctx.quadraticCurveTo(-eyeSpacing + 10 * gs, 3 * gs, -eyeSpacing + 8 * gs, -4 * gs);
            ctx.quadraticCurveTo(-eyeSpacing, -6 * gs, -eyeSpacing - 8 * gs, -4 * gs);
            ctx.fill();
            ctx.stroke();
            // Right lens
            ctx.beginPath();
            ctx.moveTo(eyeSpacing - 8 * gs, -4 * gs);
            ctx.quadraticCurveTo(eyeSpacing - 10 * gs, 3 * gs, eyeSpacing, 6 * gs);
            ctx.quadraticCurveTo(eyeSpacing + 10 * gs, 3 * gs, eyeSpacing + 8 * gs, -4 * gs);
            ctx.quadraticCurveTo(eyeSpacing, -6 * gs, eyeSpacing - 8 * gs, -4 * gs);
            ctx.fill();
            ctx.stroke();
            // Bridge
            ctx.beginPath();
            ctx.moveTo(-eyeSpacing + 6 * gs, -3 * gs);
            ctx.lineTo(eyeSpacing - 6 * gs, -3 * gs);
            ctx.stroke();
          } else if (equippedGlasses === 'nerd_glasses') {
            // Thick round frames
            ctx.strokeStyle = '#222';
            ctx.lineWidth = 3 * gs;
            // Left lens
            ctx.beginPath();
            ctx.arc(-eyeSpacing, 0, 7 * gs, 0, Math.PI * 2);
            ctx.stroke();
            // Right lens
            ctx.beginPath();
            ctx.arc(eyeSpacing, 0, 7 * gs, 0, Math.PI * 2);
            ctx.stroke();
            // Bridge
            ctx.lineWidth = 2.5 * gs;
            ctx.beginPath();
            ctx.moveTo(-eyeSpacing + 7 * gs, 0);
            ctx.lineTo(eyeSpacing - 7 * gs, 0);
            ctx.stroke();
            // Lens glare
            ctx.fillStyle = 'rgba(255,255,255,0.15)';
            ctx.beginPath();
            ctx.arc(-eyeSpacing, 0, 6 * gs, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(eyeSpacing, 0, 6 * gs, 0, Math.PI * 2);
            ctx.fill();
          } else if (equippedGlasses === 'star_glasses') {
            // Fun star-shaped glasses
            ctx.fillStyle = '#FFD700';
            ctx.strokeStyle = '#DAA520';
            ctx.lineWidth = 1 * gs;
            const drawStar = (cx, cy, outerR, innerR) => {
              ctx.beginPath();
              for (let i = 0; i < 10; i++) {
                const r = i % 2 === 0 ? outerR : innerR;
                const angle = (i * Math.PI) / 5 - Math.PI / 2;
                const x = cx + r * Math.cos(angle);
                const y = cy + r * Math.sin(angle);
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
              }
              ctx.closePath();
              ctx.fill();
              ctx.stroke();
            };
            drawStar(-eyeSpacing, 0, 9 * gs, 4 * gs);
            drawStar(eyeSpacing, 0, 9 * gs, 4 * gs);
            // Bridge
            ctx.strokeStyle = '#FFD700';
            ctx.lineWidth = 2 * gs;
            ctx.beginPath();
            ctx.moveTo(-eyeSpacing + 6 * gs, 0);
            ctx.lineTo(eyeSpacing - 6 * gs, 0);
            ctx.stroke();
          } else if (equippedGlasses === 'vr_headset') {
            // Futuristic VR headset
            ctx.fillStyle = '#2a2a2a';
            // Main visor
            ctx.beginPath();
            ctx.roundRect(-size * 0.22, -6 * gs, size * 0.44, 14 * gs, 4 * gs);
            ctx.fill();
            // Glowing screens
            ctx.fillStyle = '#4FC3F7';
            ctx.beginPath();
            ctx.roundRect(-eyeSpacing - 6 * gs, -3 * gs, 12 * gs, 8 * gs, 2 * gs);
            ctx.fill();
            ctx.beginPath();
            ctx.roundRect(eyeSpacing - 6 * gs, -3 * gs, 12 * gs, 8 * gs, 2 * gs);
            ctx.fill();
            // Glow effect
            ctx.shadowColor = '#4FC3F7';
            ctx.shadowBlur = 5;
            ctx.fillStyle = 'rgba(79, 195, 247, 0.3)';
            ctx.fillRect(-eyeSpacing - 5 * gs, -2 * gs, 10 * gs, 6 * gs);
            ctx.fillRect(eyeSpacing - 5 * gs, -2 * gs, 10 * gs, 6 * gs);
            ctx.shadowBlur = 0;
          }
          ctx.restore();
        }

        // Draw hat on top - make them look like they're actually ON the head
        if (equippedHat) {
          ctx.save();
          // Position hat to wrap around the top of the head
          const headTop = centerY - size * 0.28; // Top of head in avatar
          const headRadius = size * 0.28; // Head radius
          const hs = size / 55; // Hat scale factor

          if (equippedHat === 'visor_white') {
            // Visor - sits on forehead with brim
            ctx.translate(centerX, headTop + size * 0.12);
            ctx.fillStyle = '#FFFFFF';
            // Headband part
            ctx.beginPath();
            ctx.arc(0, 0, headRadius * 0.95, Math.PI + 0.3, -0.3);
            ctx.lineWidth = 4 * hs;
            ctx.strokeStyle = '#FFFFFF';
            ctx.stroke();
            // Brim
            ctx.fillStyle = '#FFFFFF';
            ctx.beginPath();
            ctx.ellipse(0, 3 * hs, 22 * hs, 6 * hs, 0, Math.PI, 0);
            ctx.fill();
            ctx.strokeStyle = '#ddd';
            ctx.lineWidth = 1;
            ctx.stroke();
          } else if (equippedHat === 'cap_blue' || equippedHat === 'cap_red') {
            // Baseball cap - wraps around head
            ctx.translate(centerX, headTop + size * 0.08);
            const capColor = equippedHat === 'cap_blue' ? '#1565C0' : '#C62828';
            // Cap dome
            ctx.fillStyle = capColor;
            ctx.beginPath();
            ctx.arc(0, 2 * hs, headRadius * 1.05, Math.PI, 0);
            ctx.fill();
            // Cap button on top
            ctx.fillStyle = capColor;
            ctx.beginPath();
            ctx.arc(0, -headRadius * 0.95, 3 * hs, 0, Math.PI * 2);
            ctx.fill();
            // Brim
            ctx.beginPath();
            ctx.ellipse(8 * hs, 5 * hs, 18 * hs, 5 * hs, 0.25, Math.PI, 0);
            ctx.fill();
          } else if (equippedHat === 'bucket_hat') {
            // Bucket hat - floppy brim all around
            ctx.translate(centerX, headTop + size * 0.06);
            ctx.fillStyle = '#8D6E63';
            // Crown
            ctx.beginPath();
            ctx.arc(0, 0, headRadius * 0.98, Math.PI, 0);
            ctx.fill();
            // Top flat
            ctx.beginPath();
            ctx.ellipse(0, -headRadius * 0.85, headRadius * 0.7, 4 * hs, 0, 0, Math.PI * 2);
            ctx.fill();
            // Wide floppy brim
            ctx.fillStyle = '#7D5E53';
            ctx.beginPath();
            ctx.ellipse(0, 5 * hs, headRadius * 1.4, 7 * hs, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#8D6E63';
            ctx.beginPath();
            ctx.ellipse(0, 4 * hs, headRadius * 1.35, 5 * hs, 0, 0, Math.PI);
            ctx.fill();
          } else if (equippedHat === 'cowboy') {
            // Cowboy hat - tall crown, wide curved brim
            ctx.translate(centerX, headTop + size * 0.04);
            ctx.fillStyle = '#8B4513';
            // Wide brim (under)
            ctx.fillStyle = '#6D4C41';
            ctx.beginPath();
            ctx.ellipse(0, 8 * hs, headRadius * 1.6, 8 * hs, 0, 0, Math.PI * 2);
            ctx.fill();
            // Crown
            ctx.fillStyle = '#8B4513';
            ctx.beginPath();
            ctx.moveTo(-headRadius * 0.7, 5 * hs);
            ctx.quadraticCurveTo(-headRadius * 0.65, -12 * hs, 0, -15 * hs);
            ctx.quadraticCurveTo(headRadius * 0.65, -12 * hs, headRadius * 0.7, 5 * hs);
            ctx.fill();
            // Front brim curve
            ctx.beginPath();
            ctx.ellipse(0, 6 * hs, headRadius * 1.5, 6 * hs, 0, Math.PI * 0.85, Math.PI * 0.15, true);
            ctx.fill();
            // Band
            ctx.fillStyle = '#5D4037';
            ctx.fillRect(-headRadius * 0.65, -2 * hs, headRadius * 1.3, 4 * hs);
          } else if (equippedHat === 'top_hat') {
            // Top hat - tall cylinder with brim
            ctx.translate(centerX, headTop + size * 0.02);
            ctx.fillStyle = '#1a1a1a';
            // Brim
            ctx.beginPath();
            ctx.ellipse(0, 5 * hs, headRadius * 1.2, 5 * hs, 0, 0, Math.PI * 2);
            ctx.fill();
            // Tall cylinder
            ctx.fillRect(-headRadius * 0.65, -25 * hs, headRadius * 1.3, 28 * hs);
            // Top of hat
            ctx.beginPath();
            ctx.ellipse(0, -25 * hs, headRadius * 0.65, 4 * hs, 0, 0, Math.PI * 2);
            ctx.fill();
            // Purple band
            ctx.fillStyle = '#9C27B0';
            ctx.fillRect(-headRadius * 0.66, -4 * hs, headRadius * 1.32, 6 * hs);
          } else if (equippedHat === 'crown') {
            // Crown - royal with points and jewels
            ctx.translate(centerX, headTop + size * 0.08);
            // Gold crown base wrapping head
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.arc(0, 2 * hs, headRadius * 0.95, Math.PI + 0.2, -0.2);
            ctx.lineTo(headRadius * 0.9, -3 * hs);
            // Crown points
            ctx.lineTo(headRadius * 0.7, -15 * hs);
            ctx.lineTo(headRadius * 0.45, -5 * hs);
            ctx.lineTo(headRadius * 0.2, -18 * hs);
            ctx.lineTo(0, -8 * hs);
            ctx.lineTo(-headRadius * 0.2, -18 * hs);
            ctx.lineTo(-headRadius * 0.45, -5 * hs);
            ctx.lineTo(-headRadius * 0.7, -15 * hs);
            ctx.lineTo(-headRadius * 0.9, -3 * hs);
            ctx.closePath();
            ctx.fill();
            // Crown outline
            ctx.strokeStyle = '#DAA520';
            ctx.lineWidth = 1.5;
            ctx.stroke();
            // Center jewel (red)
            ctx.fillStyle = '#E91E63';
            ctx.beginPath();
            ctx.arc(0, -4 * hs, 4 * hs, 0, Math.PI * 2);
            ctx.fill();
            // Side jewels (blue)
            ctx.fillStyle = '#4FC3F7';
            ctx.beginPath();
            ctx.arc(-headRadius * 0.5, -1 * hs, 3 * hs, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(headRadius * 0.5, -1 * hs, 3 * hs, 0, Math.PI * 2);
            ctx.fill();
          }
          ctx.restore();
        }

        // Purple border
        ctx.strokeStyle = '#8B5CF6';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(centerX, centerY, size / 2 - 2, 0, Math.PI * 2);
        ctx.stroke();
      },

      async drawCharacter(canvas, character, pose = 'idle') {
        const ctx = canvas.getContext('2d');
        const width = canvas.width;
        const height = canvas.height;

        ctx.clearRect(0, 0, width, height);

        // Dark blue-gray background (works with all hair colors including black)
        ctx.fillStyle = '#2a3a4a';
        ctx.fillRect(0, 0, width, height);

        const centerX = width / 2;
        const centerY = height * 0.75;
        const scale = 1.3;

        // Get character customization options
        const gender = character.gender || 'boy';
        const hairstyle = character.hairstyle || 0;
        const spriteInfo = this.spriteMap[gender]?.[hairstyle];
        // When "Original" is selected (skinHex is null), use the sprite's original skin color for arms
        const skinTone = character.skinHex || spriteInfo?.skinHex || this.skinTones[character.skinTone]?.hex || '#D4A574';

        // Shadow
        ctx.fillStyle = 'rgba(0,0,0,0.2)';
        ctx.beginPath();
        ctx.ellipse(centerX, centerY + 5, 25 * scale, 8 * scale, 0, 0, Math.PI * 2);
        ctx.fill();

        ctx.save();
        ctx.translate(centerX, centerY);

        // Get sprite (with custom hair and skin colors)
        const hairColor = character.hairColor;
        const skinColor = character.skinHex;
        const sprite = spriteInfo
          ? await this.getRecoloredSprite(spriteInfo, hairColor, skinColor)
          : this.avatarSprites[spriteInfo?.file];
        const headSize = 38 * scale;
        const headX = 2 * scale; // Offset to match torso center
        const headY = -65 * scale;
        // Sprite positioning
        const spriteX = headX - headSize / 2;
        const spriteY = headY - headSize / 2;
        // Cut off point: where the body/shoulders start (percentage from top of sprite)
        const clipCutoff = 0.82; // Show top 82% of sprite, hide bottom 18% (the long hair area)

        // LAYER 1: Draw full sprite first (long hair goes BEHIND body)
        if (sprite) {
          ctx.drawImage(sprite, spriteX, spriteY, headSize, headSize);
        }

        // LAYER 2: Draw body (covers the long hair that extends below)
        const shirtColor = character.outfitShirt || '#E53935';
        const pantsColor = character.outfitPants || '#1565C0';

        // Helper to darken color for shading
        const darken = (hex, amt) => {
          let c = hex.replace('#', '');
          let num = parseInt(c, 16);
          let r = Math.max(0, (num >> 16) - amt);
          let g = Math.max(0, ((num >> 8) & 0x00FF) - amt);
          let b = Math.max(0, (num & 0x0000FF) - amt);
          return '#' + (r << 16 | g << 8 | b).toString(16).padStart(6, '0');
        };
        const lighten = (hex, amt) => {
          let c = hex.replace('#', '');
          let num = parseInt(c, 16);
          let r = Math.min(255, (num >> 16) + amt);
          let g = Math.min(255, ((num >> 8) & 0x00FF) + amt);
          let b = Math.min(255, (num & 0x0000FF) + amt);
          return '#' + (r << 16 | g << 8 | b).toString(16).padStart(6, '0');
        };

        // === SLIM STYLIZED GOLFER BODY ===
        // Body connects to head at -65 * scale, so torso top should reach -55 to -58

        // Golf shoes - small and neat
        ctx.fillStyle = '#FFFFFF';
        ctx.beginPath();
        ctx.ellipse(-4 * scale, 20 * scale, 6 * scale, 3.5 * scale, 0.15, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.ellipse(6 * scale, 20 * scale, 6 * scale, 3.5 * scale, -0.15, 0, Math.PI * 2);
        ctx.fill();
        // Shoe soles
        ctx.fillStyle = '#555';
        ctx.beginPath();
        ctx.ellipse(-4 * scale, 22 * scale, 5 * scale, 1.5 * scale, 0.15, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.ellipse(6 * scale, 22 * scale, 5 * scale, 1.5 * scale, -0.15, 0, Math.PI * 2);
        ctx.fill();

        // Legs - slightly different for boy/girl
        const legGradL = ctx.createLinearGradient(-8 * scale, 0, 2 * scale, 0);
        legGradL.addColorStop(0, darken(pantsColor, 25));
        legGradL.addColorStop(0.5, pantsColor);
        legGradL.addColorStop(1, lighten(pantsColor, 10));
        const legGradR = ctx.createLinearGradient(0, 0, 10 * scale, 0);
        legGradR.addColorStop(0, lighten(pantsColor, 10));
        legGradR.addColorStop(0.5, pantsColor);
        legGradR.addColorStop(1, darken(pantsColor, 25));

        if (gender === 'girl') {
          // Girl legs - slimmer, closer together
          ctx.fillStyle = legGradL;
          ctx.beginPath();
          ctx.moveTo(-5 * scale, -12 * scale);
          ctx.quadraticCurveTo(-6 * scale, 5 * scale, -4 * scale, 18 * scale);
          ctx.lineTo(0, 18 * scale);
          ctx.quadraticCurveTo(-1 * scale, 5 * scale, -1 * scale, -12 * scale);
          ctx.closePath();
          ctx.fill();

          ctx.fillStyle = legGradR;
          ctx.beginPath();
          ctx.moveTo(3 * scale, -12 * scale);
          ctx.quadraticCurveTo(3 * scale, 5 * scale, 6 * scale, 18 * scale);
          ctx.lineTo(10 * scale, 18 * scale);
          ctx.quadraticCurveTo(8 * scale, 5 * scale, 7 * scale, -12 * scale);
          ctx.closePath();
          ctx.fill();
        } else {
          // Boy legs - slightly wider stance
          ctx.fillStyle = legGradL;
          ctx.beginPath();
          ctx.moveTo(-7 * scale, -12 * scale);
          ctx.quadraticCurveTo(-7 * scale, 5 * scale, -4 * scale, 18 * scale);
          ctx.lineTo(0, 18 * scale);
          ctx.quadraticCurveTo(-1 * scale, 5 * scale, -2 * scale, -12 * scale);
          ctx.closePath();
          ctx.fill();

          ctx.fillStyle = legGradR;
          ctx.beginPath();
          ctx.moveTo(4 * scale, -12 * scale);
          ctx.quadraticCurveTo(3 * scale, 5 * scale, 6 * scale, 18 * scale);
          ctx.lineTo(10 * scale, 18 * scale);
          ctx.quadraticCurveTo(9 * scale, 5 * scale, 9 * scale, -12 * scale);
          ctx.closePath();
          ctx.fill();
        }

        // Torso - different shapes for boy/girl
        const torsoGrad = ctx.createLinearGradient(-12 * scale, -50 * scale, 12 * scale, -30 * scale);
        torsoGrad.addColorStop(0, darken(shirtColor, 30));
        torsoGrad.addColorStop(0.35, shirtColor);
        torsoGrad.addColorStop(0.65, lighten(shirtColor, 15));
        torsoGrad.addColorStop(1, darken(shirtColor, 20));
        ctx.fillStyle = torsoGrad;

        if (gender === 'girl') {
          // Girl: narrow waist, slight hip curve, fitted look
          ctx.beginPath();
          ctx.moveTo(-4 * scale, -12 * scale);  // Narrow waist
          ctx.quadraticCurveTo(-6 * scale, -18 * scale, -5 * scale, -28 * scale);  // Hip hint
          ctx.quadraticCurveTo(-8 * scale, -40 * scale, -9 * scale, -50 * scale);  // Narrower shoulders
          ctx.quadraticCurveTo(-4 * scale, -58 * scale, 1 * scale, -58 * scale);   // Neck area (connects to head)
          ctx.quadraticCurveTo(6 * scale, -58 * scale, 11 * scale, -50 * scale);
          ctx.quadraticCurveTo(10 * scale, -40 * scale, 7 * scale, -28 * scale);
          ctx.quadraticCurveTo(8 * scale, -18 * scale, 6 * scale, -12 * scale);    // Narrow waist
          ctx.closePath();
          ctx.fill();
        } else {
          // Boy: broader shoulders, straighter sides
          ctx.beginPath();
          ctx.moveTo(-6 * scale, -12 * scale);  // Waist
          ctx.quadraticCurveTo(-8 * scale, -25 * scale, -12 * scale, -45 * scale); // Broader build
          ctx.quadraticCurveTo(-8 * scale, -58 * scale, 1 * scale, -58 * scale);   // Neck area
          ctx.quadraticCurveTo(10 * scale, -58 * scale, 14 * scale, -45 * scale);  // Broad shoulders
          ctx.quadraticCurveTo(10 * scale, -25 * scale, 8 * scale, -12 * scale);
          ctx.closePath();
          ctx.fill();
        }

        // OUTFIT DESIGN OVERLAY
        const outfitDesign = character.outfitDesign;
        if (outfitDesign) {
          ctx.save();
          // Clip to torso shape
          ctx.beginPath();
          if (gender === 'girl') {
            ctx.moveTo(-4 * scale, -12 * scale);
            ctx.quadraticCurveTo(-6 * scale, -18 * scale, -5 * scale, -28 * scale);
            ctx.quadraticCurveTo(-8 * scale, -40 * scale, -9 * scale, -50 * scale);
            ctx.quadraticCurveTo(-4 * scale, -58 * scale, 1 * scale, -58 * scale);
            ctx.quadraticCurveTo(6 * scale, -58 * scale, 11 * scale, -50 * scale);
            ctx.quadraticCurveTo(10 * scale, -40 * scale, 7 * scale, -28 * scale);
            ctx.quadraticCurveTo(8 * scale, -18 * scale, 6 * scale, -12 * scale);
          } else {
            ctx.moveTo(-6 * scale, -12 * scale);
            ctx.quadraticCurveTo(-8 * scale, -25 * scale, -12 * scale, -45 * scale);
            ctx.quadraticCurveTo(-8 * scale, -58 * scale, 1 * scale, -58 * scale);
            ctx.quadraticCurveTo(10 * scale, -58 * scale, 14 * scale, -45 * scale);
            ctx.quadraticCurveTo(10 * scale, -25 * scale, 8 * scale, -12 * scale);
          }
          ctx.closePath();
          ctx.clip();

          if (outfitDesign === 'stripes') {
            // Racing stripes down the middle
            const stripeColor = character.outfitStripeColor || '#FFFFFF';
            ctx.strokeStyle = stripeColor;
            ctx.lineWidth = 2.5 * scale;
            ctx.beginPath();
            ctx.moveTo(-2 * scale, -55 * scale);
            ctx.lineTo(-2 * scale, -12 * scale);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(4 * scale, -55 * scale);
            ctx.lineTo(4 * scale, -12 * scale);
            ctx.stroke();
          } else if (outfitDesign === 'gradient') {
            // Gradient overlay
            const gradTo = character.outfitGradientTo || '#9C27B0';
            const gradOverlay = ctx.createLinearGradient(0, -55 * scale, 0, -12 * scale);
            gradOverlay.addColorStop(0, 'transparent');
            gradOverlay.addColorStop(0.5, gradTo + '80');
            gradOverlay.addColorStop(1, gradTo);
            ctx.fillStyle = gradOverlay;
            ctx.fillRect(-15 * scale, -60 * scale, 30 * scale, 50 * scale);
          } else if (outfitDesign === 'camo') {
            // Camo pattern
            ctx.globalAlpha = 0.6;
            const camoColors = ['#2E7D32', '#1B5E20', '#33691E', '#4E342E'];
            for (let i = 0; i < 12; i++) {
              ctx.fillStyle = camoColors[i % camoColors.length];
              const x = (Math.random() - 0.5) * 20 * scale;
              const y = -20 * scale - Math.random() * 35 * scale;
              ctx.beginPath();
              ctx.ellipse(x, y, 4 * scale + Math.random() * 3 * scale, 3 * scale + Math.random() * 2 * scale, Math.random() * Math.PI, 0, Math.PI * 2);
              ctx.fill();
            }
            ctx.globalAlpha = 1;
          } else if (outfitDesign === 'argyle') {
            // Argyle diamonds
            const patternColor = character.outfitPatternColor || '#FFC107';
            ctx.fillStyle = patternColor + '90';
            for (let row = 0; row < 3; row++) {
              for (let col = -1; col <= 1; col++) {
                ctx.save();
                ctx.translate(col * 8 * scale, -48 * scale + row * 14 * scale);
                ctx.rotate(Math.PI / 4);
                ctx.fillRect(-3 * scale, -3 * scale, 6 * scale, 6 * scale);
                ctx.restore();
              }
            }
          } else if (outfitDesign === 'flames') {
            // Flames from bottom
            ctx.fillStyle = '#FF9800';
            for (let i = -2; i <= 2; i++) {
              ctx.beginPath();
              ctx.moveTo(i * 4 * scale - 2 * scale, -12 * scale);
              ctx.quadraticCurveTo(i * 4 * scale, -28 * scale - Math.random() * 8 * scale, i * 4 * scale + 2 * scale, -12 * scale);
              ctx.fill();
            }
            ctx.fillStyle = '#FFEB3B';
            for (let i = -1; i <= 1; i++) {
              ctx.beginPath();
              ctx.moveTo(i * 5 * scale - 1 * scale, -12 * scale);
              ctx.quadraticCurveTo(i * 5 * scale, -22 * scale, i * 5 * scale + 1 * scale, -12 * scale);
              ctx.fill();
            }
          } else if (outfitDesign === 'stars') {
            // Star pattern
            const patternColor = character.outfitPatternColor || '#FFD700';
            ctx.fillStyle = patternColor;
            const drawSmallStar = (cx, cy, size) => {
              ctx.beginPath();
              for (let i = 0; i < 10; i++) {
                const r = i % 2 === 0 ? size : size * 0.4;
                const angle = (i * Math.PI) / 5 - Math.PI / 2;
                const x = cx + r * Math.cos(angle);
                const y = cy + r * Math.sin(angle);
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
              }
              ctx.closePath();
              ctx.fill();
            };
            drawSmallStar(0, -45 * scale, 4 * scale);
            drawSmallStar(-6 * scale, -32 * scale, 3 * scale);
            drawSmallStar(6 * scale, -35 * scale, 3 * scale);
            drawSmallStar(-3 * scale, -22 * scale, 2.5 * scale);
            drawSmallStar(4 * scale, -25 * scale, 2.5 * scale);
          } else if (outfitDesign === 'tiger') {
            // Tiger stripes
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 2 * scale;
            ctx.lineCap = 'round';
            const stripes = [
              [[-8, -50], [-4, -48], [-6, -45]],
              [[8, -50], [4, -48], [6, -45]],
              [[-6, -40], [-2, -38], [-5, -35]],
              [[6, -40], [2, -38], [5, -35]],
              [[-4, -30], [0, -28], [-3, -25]],
              [[4, -30], [0, -28], [3, -25]]
            ];
            stripes.forEach(stripe => {
              ctx.beginPath();
              ctx.moveTo(stripe[0][0] * scale, stripe[0][1] * scale);
              stripe.slice(1).forEach(pt => ctx.lineTo(pt[0] * scale, pt[1] * scale));
              ctx.stroke();
            });
          } else if (outfitDesign === 'lightning') {
            // Lightning bolt
            const patternColor = character.outfitPatternColor || '#FFEB3B';
            ctx.fillStyle = patternColor;
            ctx.beginPath();
            ctx.moveTo(2 * scale, -52 * scale);
            ctx.lineTo(-4 * scale, -38 * scale);
            ctx.lineTo(-1 * scale, -38 * scale);
            ctx.lineTo(-6 * scale, -20 * scale);
            ctx.lineTo(0, -30 * scale);
            ctx.lineTo(-2 * scale, -30 * scale);
            ctx.lineTo(5 * scale, -52 * scale);
            ctx.closePath();
            ctx.fill();
          } else if (outfitDesign === 'champion') {
            // Champion emblem
            ctx.fillStyle = '#FFFFFF';
            ctx.beginPath();
            ctx.arc(1 * scale, -40 * scale, 8 * scale, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#FFD700';
            ctx.font = `bold ${10 * scale}px Arial`;
            ctx.textAlign = 'center';
            ctx.fillText('â˜…', 1 * scale, -36 * scale);
          } else if (outfitDesign === 'neon') {
            // Neon glow lines
            const patternColor = character.outfitPatternColor || '#00FFFF';
            ctx.shadowColor = patternColor;
            ctx.shadowBlur = 8 * scale;
            ctx.strokeStyle = patternColor;
            ctx.lineWidth = 1.5 * scale;
            ctx.beginPath();
            ctx.moveTo(-8 * scale, -48 * scale);
            ctx.lineTo(-4 * scale, -38 * scale);
            ctx.lineTo(-8 * scale, -28 * scale);
            ctx.lineTo(-4 * scale, -18 * scale);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(10 * scale, -48 * scale);
            ctx.lineTo(6 * scale, -38 * scale);
            ctx.lineTo(10 * scale, -28 * scale);
            ctx.lineTo(6 * scale, -18 * scale);
            ctx.stroke();
            ctx.shadowBlur = 0;
          } else if (outfitDesign === 'tuxedo') {
            // Tuxedo - lapels and bow tie
            const patternColor = character.outfitPatternColor || '#FFFFFF';
            // White shirt front
            ctx.fillStyle = patternColor;
            ctx.beginPath();
            ctx.moveTo(-3 * scale, -50 * scale);
            ctx.lineTo(5 * scale, -50 * scale);
            ctx.lineTo(4 * scale, -18 * scale);
            ctx.lineTo(-2 * scale, -18 * scale);
            ctx.closePath();
            ctx.fill();
            // Bow tie
            ctx.fillStyle = '#D32F2F';
            ctx.beginPath();
            ctx.ellipse(1 * scale, -48 * scale, 4 * scale, 2 * scale, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#B71C1C';
            ctx.beginPath();
            ctx.arc(1 * scale, -48 * scale, 1.5 * scale, 0, Math.PI * 2);
            ctx.fill();
          } else if (outfitDesign === 'tropical') {
            // Tropical - palm leaf pattern
            const patternColor = character.outfitPatternColor || '#FFEB3B';
            ctx.strokeStyle = patternColor;
            ctx.lineWidth = 1.5 * scale;
            // Palm leaves
            for (let i = 0; i < 3; i++) {
              const x = -6 * scale + i * 8 * scale;
              const y = -45 * scale + i * 10 * scale;
              ctx.beginPath();
              ctx.moveTo(x, y);
              ctx.quadraticCurveTo(x + 4 * scale, y - 5 * scale, x + 8 * scale, y);
              ctx.stroke();
              ctx.beginPath();
              ctx.moveTo(x + 2 * scale, y);
              ctx.quadraticCurveTo(x + 4 * scale, y + 4 * scale, x + 6 * scale, y);
              ctx.stroke();
            }
          } else if (outfitDesign === 'galaxy') {
            // Galaxy - stars and nebula swirls
            const patternColor = character.outfitPatternColor || '#E040FB';
            ctx.fillStyle = patternColor;
            // Stars scattered
            const stars = [[0, -45], [-5, -35], [7, -40], [-3, -25], [5, -30], [2, -20]];
            for (const [sx, sy] of stars) {
              ctx.beginPath();
              ctx.arc(sx * scale, sy * scale, 1.5 * scale, 0, Math.PI * 2);
              ctx.fill();
            }
            // Nebula swirl
            ctx.strokeStyle = patternColor;
            ctx.lineWidth = 1 * scale;
            ctx.globalAlpha = 0.5;
            ctx.beginPath();
            ctx.moveTo(-6 * scale, -42 * scale);
            ctx.quadraticCurveTo(0, -48 * scale, 6 * scale, -42 * scale);
            ctx.quadraticCurveTo(3 * scale, -35 * scale, -3 * scale, -30 * scale);
            ctx.stroke();
            ctx.globalAlpha = 1;
          } else if (outfitDesign === 'retro') {
            // Retro 80s - geometric shapes
            const patternColor = character.outfitPatternColor || '#00FFFF';
            ctx.strokeStyle = patternColor;
            ctx.lineWidth = 2 * scale;
            // Horizontal lines
            ctx.beginPath();
            ctx.moveTo(-8 * scale, -40 * scale);
            ctx.lineTo(10 * scale, -40 * scale);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(-8 * scale, -32 * scale);
            ctx.lineTo(10 * scale, -32 * scale);
            ctx.stroke();
            // Triangle
            ctx.fillStyle = '#FFEB3B';
            ctx.beginPath();
            ctx.moveTo(0, -48 * scale);
            ctx.lineTo(-5 * scale, -38 * scale);
            ctx.lineTo(5 * scale, -38 * scale);
            ctx.closePath();
            ctx.fill();
          } else if (outfitDesign === 'western') {
            // Western - fringe pattern
            const patternColor = character.outfitPatternColor || '#FFC107';
            ctx.strokeStyle = patternColor;
            ctx.lineWidth = 1 * scale;
            // Yoke design (V-shape on chest)
            ctx.beginPath();
            ctx.moveTo(-10 * scale, -50 * scale);
            ctx.lineTo(1 * scale, -42 * scale);
            ctx.lineTo(12 * scale, -50 * scale);
            ctx.stroke();
            // Fringe under yoke
            for (let i = -8; i <= 10; i += 3) {
              ctx.beginPath();
              ctx.moveTo(i * scale, -42 * scale + Math.abs(i) * 0.3 * scale);
              ctx.lineTo(i * scale, -36 * scale + Math.abs(i) * 0.3 * scale);
              ctx.stroke();
            }
          }
          ctx.restore();
        }

        // Collar - V-neck style, positioned to connect with head
        ctx.fillStyle = lighten(shirtColor, 50);
        ctx.beginPath();
        ctx.moveTo(-2 * scale, -55 * scale);
        ctx.lineTo(1 * scale, -48 * scale);
        ctx.lineTo(4 * scale, -55 * scale);
        ctx.quadraticCurveTo(1 * scale, -59 * scale, -2 * scale, -55 * scale);
        ctx.fill();

        // Collar outline
        ctx.strokeStyle = darken(shirtColor, 40);
        ctx.lineWidth = 0.8;
        ctx.beginPath();
        ctx.moveTo(-2 * scale, -55 * scale);
        ctx.lineTo(1 * scale, -48 * scale);
        ctx.lineTo(4 * scale, -55 * scale);
        ctx.stroke();

        // Short sleeves - different sizes for boy/girl
        ctx.fillStyle = shirtColor;
        if (gender === 'girl') {
          // Girl sleeves - smaller, more fitted
          ctx.beginPath();
          ctx.ellipse(-9 * scale, -46 * scale, 3.5 * scale, 5 * scale, 0.3, 0, Math.PI * 2);
          ctx.fill();
          ctx.beginPath();
          ctx.ellipse(11 * scale, -46 * scale, 3.5 * scale, 5 * scale, -0.3, 0, Math.PI * 2);
          ctx.fill();
        } else {
          // Boy sleeves - slightly larger
          ctx.beginPath();
          ctx.ellipse(-12 * scale, -44 * scale, 4 * scale, 6 * scale, 0.3, 0, Math.PI * 2);
          ctx.fill();
          ctx.beginPath();
          ctx.ellipse(14 * scale, -44 * scale, 4 * scale, 6 * scale, -0.3, 0, Math.PI * 2);
          ctx.fill();
        }

        // Sleeve shading
        ctx.fillStyle = darken(shirtColor, 30);
        if (gender === 'girl') {
          ctx.beginPath();
          ctx.ellipse(-10 * scale, -44 * scale, 2 * scale, 3.5 * scale, 0.3, 0, Math.PI * 2);
          ctx.fill();
          ctx.beginPath();
          ctx.ellipse(12 * scale, -44 * scale, 2 * scale, 3.5 * scale, -0.3, 0, Math.PI * 2);
          ctx.fill();
        } else {
          ctx.beginPath();
          ctx.ellipse(-13 * scale, -42 * scale, 2.5 * scale, 4 * scale, 0.3, 0, Math.PI * 2);
          ctx.fill();
          ctx.beginPath();
          ctx.ellipse(15 * scale, -42 * scale, 2.5 * scale, 4 * scale, -0.3, 0, Math.PI * 2);
          ctx.fill();
        }

        // Arms - slimmer for girls
        ctx.fillStyle = skinTone;
        if (gender === 'girl') {
          // Girl arms - thinner
          ctx.beginPath();
          ctx.moveTo(-10 * scale, -42 * scale);
          ctx.quadraticCurveTo(-11 * scale, -32 * scale, -10 * scale, -22 * scale);
          ctx.lineTo(-8 * scale, -22 * scale);
          ctx.quadraticCurveTo(-8 * scale, -32 * scale, -7 * scale, -42 * scale);
          ctx.closePath();
          ctx.fill();
          ctx.beginPath();
          ctx.moveTo(12 * scale, -42 * scale);
          ctx.quadraticCurveTo(13 * scale, -32 * scale, 12 * scale, -22 * scale);
          ctx.lineTo(10 * scale, -22 * scale);
          ctx.quadraticCurveTo(10 * scale, -32 * scale, 9 * scale, -42 * scale);
          ctx.closePath();
          ctx.fill();
        } else {
          // Boy arms - slightly thicker
          ctx.beginPath();
          ctx.moveTo(-13 * scale, -40 * scale);
          ctx.quadraticCurveTo(-14 * scale, -30 * scale, -13 * scale, -20 * scale);
          ctx.lineTo(-10 * scale, -20 * scale);
          ctx.quadraticCurveTo(-10 * scale, -30 * scale, -10 * scale, -40 * scale);
          ctx.closePath();
          ctx.fill();
          ctx.beginPath();
          ctx.moveTo(15 * scale, -40 * scale);
          ctx.quadraticCurveTo(16 * scale, -30 * scale, 15 * scale, -20 * scale);
          ctx.lineTo(12 * scale, -20 * scale);
          ctx.quadraticCurveTo(12 * scale, -30 * scale, 12 * scale, -40 * scale);
          ctx.closePath();
          ctx.fill();
        }

        // Hands - smaller for girls
        ctx.fillStyle = skinTone;
        if (gender === 'girl') {
          ctx.beginPath();
          ctx.arc(-9 * scale, -20 * scale, 2.5 * scale, 0, Math.PI * 2);
          ctx.fill();
          ctx.beginPath();
          ctx.arc(11 * scale, -20 * scale, 2.5 * scale, 0, Math.PI * 2);
          ctx.fill();
        } else {
          ctx.beginPath();
          ctx.arc(-11.5 * scale, -18 * scale, 3 * scale, 0, Math.PI * 2);
          ctx.fill();
          ctx.beginPath();
          ctx.arc(13.5 * scale, -18 * scale, 3 * scale, 0, Math.PI * 2);
          ctx.fill();
        }

        // LAYER 3: Draw upper portion of sprite (head + top hair, but NOT long hair hanging down)
        if (sprite) {
          ctx.save();
          ctx.beginPath();
          // Clip to rectangle covering upper portion of sprite
          ctx.rect(spriteX, spriteY, headSize, headSize * clipCutoff);
          ctx.clip();
          ctx.drawImage(sprite, spriteX, spriteY, headSize, headSize);
          ctx.restore();
        } else {
          // Fallback: programmatic head
          ctx.fillStyle = skinTone;
          ctx.beginPath();
          ctx.arc(0, -65 * scale, 14 * scale, 0, Math.PI * 2);
          ctx.fill();

          // Hair
          ctx.fillStyle = character.hairColor || '#4A3728';
          ctx.beginPath();
          ctx.arc(0, -68 * scale, 13 * scale, Math.PI + 0.3, -0.3);
          ctx.fill();

          // Eyes
          ctx.fillStyle = '#333';
          ctx.beginPath();
          ctx.arc(-5 * scale, -66 * scale, 2.5 * scale, 0, Math.PI * 2);
          ctx.arc(5 * scale, -66 * scale, 2.5 * scale, 0, Math.PI * 2);
          ctx.fill();

          // Smile
          ctx.strokeStyle = '#333';
          ctx.lineWidth = 1.5;
          ctx.beginPath();
          ctx.arc(0, -62 * scale, 5 * scale, 0.2, Math.PI - 0.2);
          ctx.stroke();
        }

        // LAYER 3.5: Draw facial hair (boys only)
        if (character.facialHair && character.gender !== 'girl') {
          // Use custom beard color if set, otherwise darken hair color
          const facialHairColor = character.beardColor || darken(character.hairColor || '#4A3728', 10);
          const facialHairDark = character.beardColor ? darken(character.beardColor, 15) : darken(character.hairColor || '#4A3728', 25);
          // Position to overlay the mouth (smile is at -62)
          const mouthY = -60 * scale;
          const chinY = -52 * scale;
          const jawWidth = 12 * scale;

          ctx.save();

          if (character.facialHair === 'stubble') {
            // 5 o'clock shadow - dense stippling pattern
            ctx.fillStyle = facialHairColor;
            ctx.globalAlpha = 0.7;
            // Use seeded positions for consistent look
            const stubblePoints = [
              [-8, 1], [-6, 0], [-4, -1], [-2, 0], [0, -1], [2, 0], [4, -1], [6, 0], [8, 1],
              [-9, 3], [-7, 2], [-5, 3], [-3, 2], [-1, 3], [1, 2], [3, 3], [5, 2], [7, 3], [9, 2],
              [-8, 5], [-6, 4], [-4, 5], [-2, 4], [0, 5], [2, 4], [4, 5], [6, 4], [8, 5],
              [-7, 7], [-5, 6], [-3, 7], [-1, 6], [1, 7], [3, 6], [5, 7], [7, 6],
              [-6, 9], [-4, 8], [-2, 9], [0, 8], [2, 9], [4, 8], [6, 9],
              [-4, 11], [-2, 10], [0, 11], [2, 10], [4, 11],
              [-2, 13], [0, 12], [2, 13]
            ];
            stubblePoints.forEach(([px, py]) => {
              ctx.beginPath();
              ctx.arc(headX + px * scale * 0.9, mouthY + py * scale * 0.8, 0.8 * scale, 0, Math.PI * 2);
              ctx.fill();
            });
            ctx.globalAlpha = 1;
          } else if (character.facialHair === 'beard') {
            // Natural beard with mouth opening
            ctx.fillStyle = facialHairColor;

            // Left side of beard (jaw/cheek area)
            ctx.beginPath();
            ctx.moveTo(headX - 9 * scale, mouthY - 1 * scale);
            ctx.quadraticCurveTo(headX - 10 * scale, mouthY + 3 * scale, headX - 8 * scale, chinY + 1 * scale);
            ctx.quadraticCurveTo(headX - 4 * scale, chinY + 4 * scale, headX - 2 * scale, chinY + 5 * scale);
            ctx.lineTo(headX - 2 * scale, mouthY + 3 * scale);
            ctx.quadraticCurveTo(headX - 5 * scale, mouthY + 2 * scale, headX - 9 * scale, mouthY - 1 * scale);
            ctx.fill();

            // Right side of beard (jaw/cheek area)
            ctx.beginPath();
            ctx.moveTo(headX + 9 * scale, mouthY - 1 * scale);
            ctx.quadraticCurveTo(headX + 10 * scale, mouthY + 3 * scale, headX + 8 * scale, chinY + 1 * scale);
            ctx.quadraticCurveTo(headX + 4 * scale, chinY + 4 * scale, headX + 2 * scale, chinY + 5 * scale);
            ctx.lineTo(headX + 2 * scale, mouthY + 3 * scale);
            ctx.quadraticCurveTo(headX + 5 * scale, mouthY + 2 * scale, headX + 9 * scale, mouthY - 1 * scale);
            ctx.fill();

            // Chin beard (below mouth)
            ctx.beginPath();
            ctx.moveTo(headX - 3 * scale, mouthY + 3 * scale);
            ctx.quadraticCurveTo(headX - 4 * scale, chinY + 3 * scale, headX, chinY + 6 * scale);
            ctx.quadraticCurveTo(headX + 4 * scale, chinY + 3 * scale, headX + 3 * scale, mouthY + 3 * scale);
            ctx.lineTo(headX - 3 * scale, mouthY + 3 * scale);
            ctx.fill();

            // Mustache (above mouth)
            ctx.beginPath();
            ctx.moveTo(headX - 6 * scale, mouthY + 1 * scale);
            ctx.quadraticCurveTo(headX - 3 * scale, mouthY - 1 * scale, headX, mouthY - 0.5 * scale);
            ctx.quadraticCurveTo(headX + 3 * scale, mouthY - 1 * scale, headX + 6 * scale, mouthY + 1 * scale);
            ctx.quadraticCurveTo(headX + 3 * scale, mouthY + 1.5 * scale, headX, mouthY + 1 * scale);
            ctx.quadraticCurveTo(headX - 3 * scale, mouthY + 1.5 * scale, headX - 6 * scale, mouthY + 1 * scale);
            ctx.fill();
          } else if (character.facialHair === 'goatee') {
            // Classic goatee - chin beard + mustache connected
            ctx.fillStyle = facialHairColor;
            // Chin portion
            ctx.beginPath();
            ctx.moveTo(headX - 5 * scale, mouthY + 4 * scale);
            ctx.quadraticCurveTo(headX - 6 * scale, chinY + 4 * scale, headX, chinY + 10 * scale);
            ctx.quadraticCurveTo(headX + 6 * scale, chinY + 4 * scale, headX + 5 * scale, mouthY + 4 * scale);
            ctx.quadraticCurveTo(headX + 2 * scale, mouthY + 6 * scale, headX, mouthY + 5 * scale);
            ctx.quadraticCurveTo(headX - 2 * scale, mouthY + 6 * scale, headX - 5 * scale, mouthY + 4 * scale);
            ctx.fill();
            // Small mustache
            ctx.beginPath();
            ctx.moveTo(headX - 5 * scale, mouthY + 1 * scale);
            ctx.quadraticCurveTo(headX, mouthY - 2 * scale, headX + 5 * scale, mouthY + 1 * scale);
            ctx.quadraticCurveTo(headX, mouthY + 3 * scale, headX - 5 * scale, mouthY + 1 * scale);
            ctx.fill();
          } else if (character.facialHair === 'mustache') {
            // Thick handlebar-style mustache
            ctx.fillStyle = facialHairColor;
            ctx.beginPath();
            // Left side
            ctx.moveTo(headX - 9 * scale, mouthY + 2 * scale);
            ctx.quadraticCurveTo(headX - 6 * scale, mouthY - 2 * scale, headX - 2 * scale, mouthY - 1 * scale);
            ctx.lineTo(headX, mouthY);
            ctx.lineTo(headX - 2 * scale, mouthY + 2 * scale);
            ctx.quadraticCurveTo(headX - 5 * scale, mouthY + 3 * scale, headX - 9 * scale, mouthY + 2 * scale);
            ctx.fill();
            // Right side
            ctx.beginPath();
            ctx.moveTo(headX + 9 * scale, mouthY + 2 * scale);
            ctx.quadraticCurveTo(headX + 6 * scale, mouthY - 2 * scale, headX + 2 * scale, mouthY - 1 * scale);
            ctx.lineTo(headX, mouthY);
            ctx.lineTo(headX + 2 * scale, mouthY + 2 * scale);
            ctx.quadraticCurveTo(headX + 5 * scale, mouthY + 3 * scale, headX + 9 * scale, mouthY + 2 * scale);
            ctx.fill();
            // Center connector
            ctx.beginPath();
            ctx.arc(headX, mouthY, 2 * scale, 0, Math.PI * 2);
            ctx.fill();
          } else if (character.facialHair === 'soulpatch') {
            // Small triangle/oval below lower lip
            ctx.fillStyle = facialHairColor;
            ctx.beginPath();
            ctx.moveTo(headX - 2 * scale, mouthY + 4 * scale);
            ctx.quadraticCurveTo(headX, mouthY + 10 * scale, headX + 2 * scale, mouthY + 4 * scale);
            ctx.quadraticCurveTo(headX, mouthY + 5 * scale, headX - 2 * scale, mouthY + 4 * scale);
            ctx.fill();
          }
          ctx.restore();
        }

        // LAYER 4: Draw accessories (hats and glasses) on top of head
        const equippedHat = character.equippedHat;
        const equippedGlasses = character.equippedGlasses;

        // Draw glasses first (under hats)
        if (equippedGlasses) {
          ctx.save();
          ctx.translate(2 * scale, -66 * scale); // Center on eyes
          const gs = scale * 0.85; // Glass scale

          if (equippedGlasses === 'sunglasses' || equippedGlasses === 'sport_shades') {
            // Dark sunglasses - sleek and small
            ctx.fillStyle = '#1a1a1a';
            ctx.beginPath();
            ctx.ellipse(-5 * gs, 0, 4 * gs, 2.5 * gs, -0.1, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(5 * gs, 0, 4 * gs, 2.5 * gs, 0.1, 0, Math.PI * 2);
            ctx.fill();
            // Bridge
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(-1 * gs, 0);
            ctx.lineTo(1 * gs, 0);
            ctx.stroke();
          } else if (equippedGlasses === 'aviators') {
            // Aviator style - teardrop shape
            ctx.fillStyle = 'rgba(80, 60, 40, 0.85)';
            ctx.beginPath();
            ctx.ellipse(-5 * gs, 0.5 * gs, 4.5 * gs, 3 * gs, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(5 * gs, 0.5 * gs, 4.5 * gs, 3 * gs, 0, 0, Math.PI * 2);
            ctx.fill();
            // Gold frame
            ctx.strokeStyle = '#D4AF37';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.ellipse(-5 * gs, 0.5 * gs, 4.5 * gs, 3 * gs, 0, 0, Math.PI * 2);
            ctx.stroke();
            ctx.beginPath();
            ctx.ellipse(5 * gs, 0.5 * gs, 4.5 * gs, 3 * gs, 0, 0, Math.PI * 2);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(-0.5 * gs, 0);
            ctx.lineTo(0.5 * gs, 0);
            ctx.stroke();
          } else if (equippedGlasses === 'nerd_glasses') {
            // Round nerd glasses - small circles
            ctx.strokeStyle = '#222';
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.arc(-5 * gs, 0, 3.5 * gs, 0, Math.PI * 2);
            ctx.stroke();
            ctx.beginPath();
            ctx.arc(5 * gs, 0, 3.5 * gs, 0, Math.PI * 2);
            ctx.stroke();
            // Bridge
            ctx.beginPath();
            ctx.moveTo(-1.5 * gs, 0);
            ctx.lineTo(1.5 * gs, 0);
            ctx.stroke();
          } else if (equippedGlasses === 'star_glasses') {
            // Star shaped - smaller, positioned on eyes
            ctx.fillStyle = '#FFD700';
            ctx.strokeStyle = '#DAA520';
            ctx.lineWidth = 0.5;
            const drawStar = (cx, cy, spikes, outerR, innerR) => {
              ctx.beginPath();
              for (let i = 0; i < spikes * 2; i++) {
                const r = i % 2 === 0 ? outerR : innerR;
                const angle = (i * Math.PI) / spikes - Math.PI / 2;
                const x = cx + r * Math.cos(angle);
                const y = cy + r * Math.sin(angle);
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
              }
              ctx.closePath();
              ctx.fill();
              ctx.stroke();
            };
            drawStar(-5 * gs, 0, 5, 4 * gs, 2 * gs);
            drawStar(5 * gs, 0, 5, 4 * gs, 2 * gs);
            // Bridge
            ctx.strokeStyle = '#DAA520';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(-1 * gs, 0);
            ctx.lineTo(1 * gs, 0);
            ctx.stroke();
          } else if (equippedGlasses === 'vr_headset') {
            // VR headset - compact
            ctx.fillStyle = '#222';
            ctx.beginPath();
            ctx.roundRect(-9 * gs, -2.5 * gs, 18 * gs, 6 * gs, 2);
            ctx.fill();
            ctx.fillStyle = '#4FC3F7';
            ctx.beginPath();
            ctx.roundRect(-7.5 * gs, -1.5 * gs, 6 * gs, 4 * gs, 1);
            ctx.fill();
            ctx.beginPath();
            ctx.roundRect(1.5 * gs, -1.5 * gs, 6 * gs, 4 * gs, 1);
            ctx.fill();
          } else if (equippedGlasses === 'round_shades') {
            // Round retro sunglasses
            ctx.fillStyle = 'rgba(60, 40, 30, 0.9)';
            ctx.beginPath();
            ctx.arc(-5 * gs, 0, 4 * gs, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(5 * gs, 0, 4 * gs, 0, Math.PI * 2);
            ctx.fill();
            // Gold frame
            ctx.strokeStyle = '#B8860B';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(-5 * gs, 0, 4 * gs, 0, Math.PI * 2);
            ctx.stroke();
            ctx.beginPath();
            ctx.arc(5 * gs, 0, 4 * gs, 0, Math.PI * 2);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(-1 * gs, 0);
            ctx.lineTo(1 * gs, 0);
            ctx.stroke();
          } else if (equippedGlasses === 'heart_glasses') {
            // Heart shaped glasses
            ctx.fillStyle = '#E91E63';
            const drawHeart = (cx, cy, size) => {
              ctx.beginPath();
              ctx.moveTo(cx, cy + size * 0.3);
              ctx.bezierCurveTo(cx - size, cy - size * 0.5, cx - size, cy + size * 0.5, cx, cy + size);
              ctx.bezierCurveTo(cx + size, cy + size * 0.5, cx + size, cy - size * 0.5, cx, cy + size * 0.3);
              ctx.closePath();
              ctx.fill();
            };
            drawHeart(-5 * gs, -1 * gs, 4 * gs);
            drawHeart(5 * gs, -1 * gs, 4 * gs);
            // Bridge
            ctx.strokeStyle = '#E91E63';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(-1 * gs, 0);
            ctx.lineTo(1 * gs, 0);
            ctx.stroke();
          }
          ctx.restore();
        }

        // Draw hat on top
        if (equippedHat) {
          ctx.save();
          ctx.translate(2 * scale, -78 * scale); // Position above head
          const hs = scale * 0.85; // Hat scale

          if (equippedHat === 'visor_white') {
            // Golf visor - curved headband + brim
            ctx.fillStyle = '#FFFFFF';
            // Curved headband
            ctx.beginPath();
            ctx.arc(0, 4 * hs, 14 * hs, Math.PI + 0.2, -0.2);
            ctx.arc(0, 4 * hs, 10 * hs, -0.2, Math.PI + 0.2, true);
            ctx.closePath();
            ctx.fill();
            // Curved brim
            ctx.beginPath();
            ctx.ellipse(5 * hs, 6 * hs, 13 * hs, 5 * hs, 0.1, Math.PI, 0);
            ctx.fill();
          } else if (equippedHat === 'cap_blue' || equippedHat === 'cap_red' || equippedHat === 'cap_black') {
            // Baseball cap - covers more head
            const capColor = equippedHat === 'cap_blue' ? '#1976D2' : (equippedHat === 'cap_red' ? '#D32F2F' : '#333333');
            const darkColor = equippedHat === 'cap_blue' ? '#0D47A1' : (equippedHat === 'cap_red' ? '#B71C1C' : '#1a1a1a');

            // Cap dome - larger, covers hair
            ctx.fillStyle = capColor;
            ctx.beginPath();
            ctx.arc(0, 6 * hs, 15 * hs, Math.PI, 0);
            ctx.fill();

            // Button on top
            ctx.fillStyle = darkColor;
            ctx.beginPath();
            ctx.arc(0, -8 * hs, 2 * hs, 0, Math.PI * 2);
            ctx.fill();

            // Curved brim
            ctx.fillStyle = capColor;
            ctx.beginPath();
            ctx.ellipse(6 * hs, 8 * hs, 14 * hs, 5 * hs, 0.15, Math.PI, 0);
            ctx.fill();

            // Brim underside
            ctx.fillStyle = darkColor;
            ctx.beginPath();
            ctx.ellipse(6 * hs, 9 * hs, 12 * hs, 3 * hs, 0.15, Math.PI, 0);
            ctx.fill();
          } else if (equippedHat === 'bucket_hat') {
            // Bucket hat - soft crown + floppy brim
            // Crown
            ctx.fillStyle = '#A1887F';
            ctx.beginPath();
            ctx.moveTo(-11 * hs, 3 * hs);
            ctx.quadraticCurveTo(-10 * hs, -10 * hs, 0, -12 * hs);
            ctx.quadraticCurveTo(10 * hs, -10 * hs, 11 * hs, 3 * hs);
            ctx.closePath();
            ctx.fill();
            // Crown seams
            ctx.strokeStyle = '#8D6E63';
            ctx.lineWidth = 0.5;
            ctx.beginPath();
            ctx.moveTo(0, -12 * hs);
            ctx.lineTo(0, 2 * hs);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(-6 * hs, -10 * hs);
            ctx.quadraticCurveTo(-5 * hs, -4 * hs, -5 * hs, 2 * hs);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(6 * hs, -10 * hs);
            ctx.quadraticCurveTo(5 * hs, -4 * hs, 5 * hs, 2 * hs);
            ctx.stroke();
            // Floppy brim
            ctx.fillStyle = '#8D6E63';
            ctx.beginPath();
            ctx.ellipse(0, 4 * hs, 16 * hs, 6 * hs, 0, 0, Math.PI * 2);
            ctx.fill();
            // Brim top (lighter)
            ctx.fillStyle = '#A1887F';
            ctx.beginPath();
            ctx.ellipse(0, 3 * hs, 15 * hs, 4 * hs, 0, 0, Math.PI);
            ctx.fill();
          } else if (equippedHat === 'cowboy' || equippedHat === 'cowboy_black') {
            // Cowboy hat
            ctx.fillStyle = equippedHat === 'cowboy_black' ? '#1a1a1a' : '#8B4513';
            // Crown
            ctx.beginPath();
            ctx.moveTo(-10 * hs, 4 * hs);
            ctx.quadraticCurveTo(-8 * hs, -12 * hs, 0, -14 * hs);
            ctx.quadraticCurveTo(8 * hs, -12 * hs, 10 * hs, 4 * hs);
            ctx.fill();
            // Wide brim
            ctx.beginPath();
            ctx.ellipse(0, 5 * hs, 22 * hs, 6 * hs, 0, 0, Math.PI * 2);
            ctx.fill();
            // Band
            ctx.fillStyle = equippedHat === 'cowboy_black' ? '#444' : '#654321';
            ctx.fillRect(-10 * hs, 0, 20 * hs, 3 * hs);
          } else if (equippedHat === 'beanie') {
            // Beanie - cozy knit hat
            ctx.fillStyle = '#5D4037';
            // Main dome
            ctx.beginPath();
            ctx.arc(0, 4 * hs, 14 * hs, Math.PI, 0);
            ctx.fill();
            // Folded brim
            ctx.fillStyle = '#4E342E';
            ctx.fillRect(-14 * hs, 2 * hs, 28 * hs, 6 * hs);
            // Knit lines
            ctx.strokeStyle = '#3E2723';
            ctx.lineWidth = 0.5;
            for (let i = -10; i <= 10; i += 4) {
              ctx.beginPath();
              ctx.moveTo(i * hs, -8 * hs);
              ctx.lineTo(i * hs, 2 * hs);
              ctx.stroke();
            }
          } else if (equippedHat === 'top_hat') {
            // Top hat
            ctx.fillStyle = '#1a1a1a';
            // Crown
            ctx.fillRect(-10 * hs, -20 * hs, 20 * hs, 24 * hs);
            // Brim
            ctx.beginPath();
            ctx.ellipse(0, 4 * hs, 14 * hs, 4 * hs, 0, 0, Math.PI * 2);
            ctx.fill();
            // Band
            ctx.fillStyle = '#9C27B0';
            ctx.fillRect(-10 * hs, -2 * hs, 20 * hs, 4 * hs);
          } else if (equippedHat === 'crown') {
            // Crown
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.moveTo(-12 * hs, 4 * hs);
            ctx.lineTo(-12 * hs, -6 * hs);
            ctx.lineTo(-8 * hs, -12 * hs);
            ctx.lineTo(-4 * hs, -4 * hs);
            ctx.lineTo(0, -14 * hs);
            ctx.lineTo(4 * hs, -4 * hs);
            ctx.lineTo(8 * hs, -12 * hs);
            ctx.lineTo(12 * hs, -6 * hs);
            ctx.lineTo(12 * hs, 4 * hs);
            ctx.closePath();
            ctx.fill();
            // Jewels
            ctx.fillStyle = '#E91E63';
            ctx.beginPath();
            ctx.arc(0, -2 * hs, 3 * hs, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#4FC3F7';
            ctx.beginPath();
            ctx.arc(-6 * hs, 0, 2 * hs, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(6 * hs, 0, 2 * hs, 0, Math.PI * 2);
            ctx.fill();
          }
          ctx.restore();
        }

        ctx.restore();
      },

      // Draw full-body reporter for interview scene
      async drawReporter(canvas) {
        const ctx = canvas.getContext('2d');
        const width = canvas.width;
        const height = canvas.height;

        ctx.clearRect(0, 0, width, height);

        const centerX = width / 2;
        const groundY = height * 0.92;
        const scale = height / 220; // Scale based on canvas height

        ctx.save();
        ctx.translate(centerX, groundY);

        // Reporter colors
        const skinTone = '#E8C4A0';
        const hairColor = '#5D4037';
        const blazerColor = '#1A237E'; // Navy blue
        const blouseColor = '#FFFFFF';
        const skirtColor = '#1A237E';
        const shoeColor = '#212121';

        // Helper functions
        const darken = (hex, amt) => {
          const num = parseInt(hex.slice(1), 16);
          const r = Math.max(0, (num >> 16) - amt);
          const g = Math.max(0, ((num >> 8) & 0x00FF) - amt);
          const b = Math.max(0, (num & 0x0000FF) - amt);
          return `#${(r << 16 | g << 8 | b).toString(16).padStart(6, '0')}`;
        };
        const lighten = (hex, amt) => {
          const num = parseInt(hex.slice(1), 16);
          const r = Math.min(255, (num >> 16) + amt);
          const g = Math.min(255, ((num >> 8) & 0x00FF) + amt);
          const b = Math.min(255, (num & 0x0000FF) + amt);
          return `#${(r << 16 | g << 8 | b).toString(16).padStart(6, '0')}`;
        };

        // === FEET/SHOES ===
        ctx.fillStyle = shoeColor;
        // Left shoe - heels
        ctx.beginPath();
        ctx.ellipse(-6 * scale, -2 * scale, 4 * scale, 2 * scale, 0, 0, Math.PI * 2);
        ctx.fill();
        // Right shoe
        ctx.beginPath();
        ctx.ellipse(6 * scale, -2 * scale, 4 * scale, 2 * scale, 0, 0, Math.PI * 2);
        ctx.fill();
        // Heels
        ctx.fillRect(-7 * scale, -4 * scale, 2 * scale, 4 * scale);
        ctx.fillRect(5 * scale, -4 * scale, 2 * scale, 4 * scale);

        // === LEGS ===
        ctx.fillStyle = skinTone;
        // Left leg
        ctx.beginPath();
        ctx.moveTo(-8 * scale, -4 * scale);
        ctx.quadraticCurveTo(-7 * scale, -20 * scale, -6 * scale, -35 * scale);
        ctx.lineTo(-4 * scale, -35 * scale);
        ctx.quadraticCurveTo(-5 * scale, -20 * scale, -4 * scale, -4 * scale);
        ctx.closePath();
        ctx.fill();
        // Right leg
        ctx.beginPath();
        ctx.moveTo(4 * scale, -4 * scale);
        ctx.quadraticCurveTo(5 * scale, -20 * scale, 6 * scale, -35 * scale);
        ctx.lineTo(8 * scale, -35 * scale);
        ctx.quadraticCurveTo(7 * scale, -20 * scale, 8 * scale, -4 * scale);
        ctx.closePath();
        ctx.fill();

        // === SKIRT ===
        ctx.fillStyle = skirtColor;
        ctx.beginPath();
        ctx.moveTo(-12 * scale, -35 * scale);
        ctx.lineTo(-10 * scale, -55 * scale);
        ctx.lineTo(10 * scale, -55 * scale);
        ctx.lineTo(12 * scale, -35 * scale);
        ctx.closePath();
        ctx.fill();

        // Skirt shading
        ctx.fillStyle = darken(skirtColor, 30);
        ctx.beginPath();
        ctx.moveTo(-2 * scale, -35 * scale);
        ctx.lineTo(-1 * scale, -55 * scale);
        ctx.lineTo(1 * scale, -55 * scale);
        ctx.lineTo(2 * scale, -35 * scale);
        ctx.closePath();
        ctx.fill();

        // === TORSO/BLOUSE ===
        ctx.fillStyle = blouseColor;
        ctx.beginPath();
        ctx.moveTo(-8 * scale, -55 * scale);
        ctx.lineTo(-7 * scale, -75 * scale);
        ctx.lineTo(7 * scale, -75 * scale);
        ctx.lineTo(8 * scale, -55 * scale);
        ctx.closePath();
        ctx.fill();

        // Blouse details (slight shading)
        ctx.strokeStyle = '#E0E0E0';
        ctx.lineWidth = 0.5 * scale;
        ctx.beginPath();
        ctx.moveTo(0, -75 * scale);
        ctx.lineTo(0, -58 * scale);
        ctx.stroke();

        // === BLAZER ===
        ctx.fillStyle = blazerColor;
        // Left side of blazer
        ctx.beginPath();
        ctx.moveTo(-10 * scale, -55 * scale);
        ctx.lineTo(-12 * scale, -75 * scale);
        ctx.lineTo(-7 * scale, -75 * scale);
        ctx.lineTo(-6 * scale, -55 * scale);
        ctx.closePath();
        ctx.fill();
        // Right side of blazer
        ctx.beginPath();
        ctx.moveTo(10 * scale, -55 * scale);
        ctx.lineTo(12 * scale, -75 * scale);
        ctx.lineTo(7 * scale, -75 * scale);
        ctx.lineTo(6 * scale, -55 * scale);
        ctx.closePath();
        ctx.fill();

        // Blazer lapels
        ctx.fillStyle = lighten(blazerColor, 20);
        ctx.beginPath();
        ctx.moveTo(-5 * scale, -75 * scale);
        ctx.lineTo(-3 * scale, -65 * scale);
        ctx.lineTo(-6 * scale, -65 * scale);
        ctx.closePath();
        ctx.fill();
        ctx.beginPath();
        ctx.moveTo(5 * scale, -75 * scale);
        ctx.lineTo(3 * scale, -65 * scale);
        ctx.lineTo(6 * scale, -65 * scale);
        ctx.closePath();
        ctx.fill();

        // === ARMS ===
        // Left arm (at side)
        ctx.fillStyle = blazerColor;
        ctx.beginPath();
        ctx.moveTo(-12 * scale, -75 * scale);
        ctx.quadraticCurveTo(-15 * scale, -60 * scale, -14 * scale, -45 * scale);
        ctx.lineTo(-11 * scale, -45 * scale);
        ctx.quadraticCurveTo(-12 * scale, -60 * scale, -10 * scale, -70 * scale);
        ctx.closePath();
        ctx.fill();

        // Left hand
        ctx.fillStyle = skinTone;
        ctx.beginPath();
        ctx.arc(-12.5 * scale, -43 * scale, 3 * scale, 0, Math.PI * 2);
        ctx.fill();

        // Right arm (holding microphone, bent up)
        ctx.fillStyle = blazerColor;
        ctx.beginPath();
        ctx.moveTo(12 * scale, -75 * scale);
        ctx.quadraticCurveTo(16 * scale, -68 * scale, 18 * scale, -60 * scale);
        ctx.quadraticCurveTo(17 * scale, -65 * scale, 15 * scale, -55 * scale);
        ctx.lineTo(12 * scale, -57 * scale);
        ctx.quadraticCurveTo(13 * scale, -65 * scale, 10 * scale, -70 * scale);
        ctx.closePath();
        ctx.fill();

        // Right hand holding mic
        ctx.fillStyle = skinTone;
        ctx.beginPath();
        ctx.arc(16 * scale, -58 * scale, 3 * scale, 0, Math.PI * 2);
        ctx.fill();

        // === MICROPHONE ===
        // Mic handle
        ctx.fillStyle = '#424242';
        ctx.fillRect(14 * scale, -70 * scale, 4 * scale, 15 * scale);
        // Mic head
        ctx.fillStyle = '#616161';
        ctx.beginPath();
        ctx.arc(16 * scale, -73 * scale, 4 * scale, 0, Math.PI * 2);
        ctx.fill();
        // Mic mesh pattern
        ctx.strokeStyle = '#757575';
        ctx.lineWidth = 0.5 * scale;
        ctx.beginPath();
        ctx.arc(16 * scale, -73 * scale, 2.5 * scale, 0, Math.PI * 2);
        ctx.stroke();

        // === NECK ===
        ctx.fillStyle = skinTone;
        ctx.fillRect(-3 * scale, -82 * scale, 6 * scale, 8 * scale);

        // === HEAD ===
        ctx.fillStyle = skinTone;
        ctx.beginPath();
        ctx.arc(0, -95 * scale, 14 * scale, 0, Math.PI * 2);
        ctx.fill();

        // === HAIR ===
        ctx.fillStyle = hairColor;
        // Main hair volume
        ctx.beginPath();
        ctx.arc(0, -98 * scale, 15 * scale, Math.PI + 0.4, -0.4);
        ctx.fill();
        // Side hair (bob cut style)
        ctx.beginPath();
        ctx.ellipse(-12 * scale, -90 * scale, 5 * scale, 12 * scale, 0.2, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.ellipse(12 * scale, -90 * scale, 5 * scale, 12 * scale, -0.2, 0, Math.PI * 2);
        ctx.fill();
        // Hair shine
        ctx.fillStyle = lighten(hairColor, 30);
        ctx.beginPath();
        ctx.arc(-5 * scale, -105 * scale, 4 * scale, 0, Math.PI * 2);
        ctx.fill();

        // === FACE ===
        // Eyes
        ctx.fillStyle = '#FFFFFF';
        ctx.beginPath();
        ctx.ellipse(-5 * scale, -96 * scale, 3 * scale, 2.5 * scale, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.ellipse(5 * scale, -96 * scale, 3 * scale, 2.5 * scale, 0, 0, Math.PI * 2);
        ctx.fill();

        // Irises
        ctx.fillStyle = '#5D4037';
        ctx.beginPath();
        ctx.arc(-5 * scale, -96 * scale, 1.5 * scale, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(5 * scale, -96 * scale, 1.5 * scale, 0, Math.PI * 2);
        ctx.fill();

        // Pupils
        ctx.fillStyle = '#1a1a1a';
        ctx.beginPath();
        ctx.arc(-5 * scale, -96 * scale, 0.8 * scale, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(5 * scale, -96 * scale, 0.8 * scale, 0, Math.PI * 2);
        ctx.fill();

        // Eyebrows
        ctx.strokeStyle = darken(hairColor, 20);
        ctx.lineWidth = 1.5 * scale;
        ctx.beginPath();
        ctx.moveTo(-8 * scale, -100 * scale);
        ctx.quadraticCurveTo(-5 * scale, -102 * scale, -2 * scale, -100 * scale);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(8 * scale, -100 * scale);
        ctx.quadraticCurveTo(5 * scale, -102 * scale, 2 * scale, -100 * scale);
        ctx.stroke();

        // Nose
        ctx.strokeStyle = darken(skinTone, 30);
        ctx.lineWidth = 1 * scale;
        ctx.beginPath();
        ctx.moveTo(0, -95 * scale);
        ctx.lineTo(1 * scale, -90 * scale);
        ctx.lineTo(0, -89 * scale);
        ctx.stroke();

        // Smile
        ctx.strokeStyle = '#C62828';
        ctx.lineWidth = 2 * scale;
        ctx.lineCap = 'round';
        ctx.beginPath();
        ctx.arc(0, -88 * scale, 5 * scale, 0.2, Math.PI - 0.2);
        ctx.stroke();

        // Lips color
        ctx.fillStyle = '#E57373';
        ctx.beginPath();
        ctx.ellipse(0, -86 * scale, 4 * scale, 1.5 * scale, 0, 0, Math.PI);
        ctx.fill();

        // Earrings
        ctx.fillStyle = '#FFD700';
        ctx.beginPath();
        ctx.arc(-13 * scale, -93 * scale, 2 * scale, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(13 * scale, -93 * scale, 2 * scale, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();
      },

      createCareerFromCreator() {
        const name = document.getElementById('career-name-input').value.trim() || 'Golfer';
        const character = this.getCreatorSelections();

        this.createNewCareer(name, character);
        document.getElementById('character-creator-overlay').classList.add('hidden');
        this.showCareerHub();
      },

      showCareerHub() {
        if (!this.activeCareer) return;
        document.getElementById('career-hub-overlay').classList.remove('hidden');
        this.updateHubDisplay();
      },

      async updateHubDisplay() {
        const career = this.activeCareer;
        if (!career) return;

        const tour = this.tours[career.currentTour];

        document.getElementById('hub-player-name').textContent = career.playerName;
        document.getElementById('hub-tour-name').textContent = tour.name;
        document.getElementById('hub-golf-bucks').textContent = '$' + career.careerGolfBucks;
        document.getElementById('hub-tour-coins').textContent = career.tourCoins;
        document.getElementById('hub-ranking-points').textContent = career.rankingPoints;
        document.getElementById('hub-tour-ranking').textContent = '#' + career.tourRanking;
        document.getElementById('hub-wins').textContent = career.stats.tournamentsWon;
        document.getElementById('hub-total-earnings').textContent = '$' + (career.stats.totalEarnings || 0);
        document.getElementById('hub-fanbase').textContent = (career.fanbase || 0).toLocaleString() + ' fans';

        // Update headline with career news
        const headline = this.generateHeadline(career);
        document.getElementById('hub-headline-text').textContent = headline;

        // Update next tournament preview
        const tournamentNum = ((career.seasonWeek - 1) % tour.tournamentCount) + 1;
        document.getElementById('hub-season-week').textContent = `Tournament ${tournamentNum} of ${tour.tournamentCount} â€¢ Season ${career.currentSeason}`;
        const tournamentNames = ['Local Open', 'Hometown Classic', 'City Championship', 'Regional Cup', 'County Invitational', 'State Qualifier', 'Amateur Challenge', 'Rising Stars Open'];
        const nextTournament = tournamentNames[(career.seasonWeek - 1) % tournamentNames.length];
        document.getElementById('hub-next-tournament-name').textContent = nextTournament;
        document.getElementById('hub-next-entry').textContent = tour.entryFee > 0 ? `Entry: $${tour.entryFee}` : 'Free Entry';
        document.getElementById('hub-next-prize').textContent = `Prize: $${tour.basePrize}`;

        // Update play button text based on tour
        document.getElementById('hub-play-btn-text').textContent = `Play ${tour.name} Tournament`;

        // Update progress bar
        const progressPercent = tour.promotionPoints ?
          Math.min(100, (career.rankingPoints / tour.promotionPoints) * 100) : 100;
        document.getElementById('hub-promotion-progress').style.width = progressPercent + '%';
        document.getElementById('hub-promotion-label').textContent = tour.promotionPoints ?
          `${career.rankingPoints} / ${tour.promotionPoints} pts to promote` : 'Legend Status Achieved!';

        // Draw avatar
        const avatarCanvas = document.getElementById('hub-avatar-canvas');
        await this.drawCharacterAvatar(avatarCanvas, career.character, 0.9);
      },

      generateHeadline(career) {
        const tour = this.tours[career.currentTour];
        const headlines = [];
        const playerName = career.playerName;
        const rivalName = this.rival.name;

        // General tour news (always available)
        const generalNews = [
          `Many new rookies ready to make their debut on the ${tour.name} this season...`,
          `High-potential players flood ${tour.name} tryouts as season kicks off`,
          `Scouts predict exciting season ahead for ${tour.name} competitors`,
          `${tour.name} officials report record number of entrants this year`,
          `"This is the most talented rookie class in years" - ${tour.name} commissioner`,
          `Former champions return to mentor young talent on the ${tour.name}`,
          `Weather forecast looks favorable for upcoming ${tour.name} events`,
          `Course maintenance crews working overtime to prepare pristine fairways`,
          `New equipment regulations spark debate among ${tour.name} players`,
          `${tour.name} announces expanded broadcast coverage for upcoming events`,
          `Fitness trainers report increase in golfer workout programs`,
          `Mental coaches in high demand as competition intensifies`,
          `Local caddies share secrets of reading tournament greens`,
          `Golf cart manufacturers showcase new electric models at expo`,
          `Putting green innovation promises faster, truer rolls`,
          `Sand trap redesigns challenge even veteran players`,
          `${tour.name} launches youth outreach program in local schools`,
          `Former baseball stars spotted at ${tour.name} pro-am event`
        ];
        headlines.push(...generalNews);

        // Quirky/funny headlines
        const funnyNews = [
          `Wayward shot strikes hot dog cart; vendor demands free drop`,
          `Golfer claims squirrel "deliberately moved" ball in viral video`,
          `Local duck population increasingly bold around water hazards`,
          `Player blames defeat on "suspiciously loud birds" near 18th`,
          `Meteorologist forecasts "70% chance of bogeys" this weekend`,
          `"My putter told me to do it" claims player after bold birdie attempt`,
          `Club fitting expert: "Longest driver won't fix your slice"`,
          `Caddie union demands better snacks at tournament venues`,
          `Player's lucky socks confirmed unwashed for third consecutive win`,
          `Golf ball manufacturers deny balls are "scared" of water hazards`
        ];
        headlines.push(...funnyNews);

        // Player-specific headlines based on stats
        if (career.stats.tournamentsWon > 0) {
          headlines.push(
            `${playerName} among rising stars making waves on ${tour.name}`,
            `${playerName}'s ${career.stats.tournamentsWon} win${career.stats.tournamentsWon > 1 ? 's' : ''} catching attention of sponsors`,
            `"${playerName} has that champion mindset" says former pro`,
            `${playerName}'s victory speech inspires young golfers everywhere`,
            `Coaches analyze ${playerName}'s winning technique in new viral breakdown`
          );
        }
        if (career.stats.tournamentsWon >= 3) {
          headlines.push(
            `${playerName} dominance has competitors scrambling for answers`,
            `"Nobody can stop ${playerName} right now" admits rival coach`,
            `${playerName} proving to be generation-defining talent on ${tour.name}`
          );
        }
        if (career.stats.birdies > 10) {
          headlines.push(
            `${playerName}'s birdie count (${career.stats.birdies}) leads ${tour.name} statistics`,
            `"${playerName} sees birdies everywhere" marvels sports psychologist`
          );
        }
        if (career.stats.holesInOne > 0) {
          headlines.push(
            `INCREDIBLE: ${playerName} has recorded ${career.stats.holesInOne} hole${career.stats.holesInOne > 1 ? 's' : ''}-in-one!`,
            `${playerName}'s hole-in-one compilation goes viral on social media`
          );
        }
        if (career.stats.eagleOrBetter > 2) {
          headlines.push(
            `Eagle-eyed ${playerName} continues spectacular scoring streak`,
            `${playerName}'s ${career.stats.eagleOrBetter} eagles make statisticians swoon`
          );
        }

        // Earnings-based headlines
        if (career.careerGolfBucks >= 1000) {
          headlines.push(
            `${playerName} crosses $${career.careerGolfBucks.toLocaleString()} in career earnings`,
            `Financial advisors eager to work with rising star ${playerName}`
          );
        }
        if (career.tourCoins >= 100) {
          headlines.push(
            `${playerName} amasses impressive Tour Coin collection`,
            `Players jealous of ${playerName}'s exclusive cosmetic collection`
          );
        }

        // Rival-related headlines
        if (career.rival && career.rival.encounterCount > 0) {
          headlines.push(
            `${rivalName} looking strong heading into tournament play`,
            `"${tour.name} is mine" declares ${rivalName} at press conference`,
            `${rivalName} seen practicing late into the evening before big match`,
            `Tension between ${playerName} and ${rivalName} continues to build`,
            `"${playerName}? Never heard of them." - ${rivalName} dismissively`,
            `Rivalry watch: ${rivalName} makes pointed comments about ${playerName}'s style`,
            `${rivalName} switches equipment sponsor in surprise announcement`,
            `Fans create ${playerName} vs ${rivalName} prediction polls online`
          );
          if (career.rival.winsAgainst > 0) {
            headlines.push(
              `${playerName}'s ${career.rival.winsAgainst} win${career.rival.winsAgainst > 1 ? 's' : ''} over ${rivalName} shift rivalry narrative`,
              `${rivalName} reportedly "obsessing" over losses to ${playerName}`,
              `"${playerName} is in my head" admits ${rivalName} to close friends`
            );
          }
          if (career.rival.winsAgainst === 0 && career.rival.encounterCount >= 2) {
            headlines.push(
              `${rivalName}'s perfect record against ${playerName} a source of pride`,
              `"${playerName} will never beat me" claims confident ${rivalName}`
            );
          }
        }

        // Tour-specific headlines
        if (career.currentTour === 'local') {
          headlines.push(
            `Local Tour qualifying rounds see fierce competition`,
            `Small-town courses becoming proving grounds for future champions`,
            `"Every legend started on the Local Tour" reminds veteran coach`
          );
        } else if (career.currentTour === 'amateur') {
          headlines.push(
            `Amateur Tour attracting nationwide television interest`,
            `Corporate sponsors increasingly targeting Amateur Tour rising stars`,
            `Amateur Tour players debate "going pro" timing strategies`
          );
        } else if (career.currentTour === 'pro') {
          headlines.push(
            `Pro Tour intensity "unlike anything else in golf" says newcomer`,
            `Pro Tour prize pools hit new records this season`,
            `Elite courses push Pro Tour players to their limits`,
            `Legend Tour scouts watching Pro Tour closely for promotions`
          );
        } else if (career.currentTour === 'legend') {
          headlines.push(
            `Legend Tour: Where golf immortals are made`,
            `Legend Tour courses push boundaries of course design`,
            `"Only the best survive here" - Legend Tour veteran`,
            `Historic Legend Tour venues draw global spectator crowds`,
            `Legend Tour champions secure endorsement deals worth millions`,
            `Aurora Borealis Course named "most beautiful hole" in golf history`
          );
        }

        // Sponsor-related headlines
        if (career.sponsors && career.sponsors.length > 0) {
          const sponsor = career.sponsors[Math.floor(Math.random() * career.sponsors.length)];
          headlines.push(
            `${sponsor.name} expands golf sponsorship portfolio`,
            `Sponsor watch: ${sponsor.name} seeking new ${tour.name} partnerships`,
            `${sponsor.name} executives spotted at multiple ${tour.name} events`
          );
        }

        // Promotion/season headlines
        if (career.rankingPoints >= tour.promotionPoints * 0.7) {
          headlines.push(
            `Several players on cusp of tour promotion as season heats up`,
            `Promotion race intensifies in final stretch of ${tour.name} season`
          );
        }

        // Random chance for "breaking news" style
        if (Math.random() < 0.1) {
          const breakingNews = [
            `BREAKING: Surprise weather delay possible for weekend events`,
            `BREAKING: Famous actor spotted in ${tour.name} gallery`,
            `BREAKING: New course record set at nearby amateur event`,
            `UPDATE: Equipment malfunction rules clarified by tour officials`,
            `DEVELOPING: Controversy over slow play penalties sparks debate`
          ];
          return 'ðŸš¨ ' + breakingNews[Math.floor(Math.random() * breakingNews.length)];
        }

        return 'ðŸ“° DAILY NEWS: ' + headlines[Math.floor(Math.random() * headlines.length)];
      },

      showTournamentSelection() {
        // Auto-select tournament based on current week
        const career = this.activeCareer;
        const tour = this.tours[career.currentTour];

        const tournamentNames = [
          'Local Open', 'Hometown Classic', 'City Championship',
          'Regional Cup', 'County Invitational', 'State Qualifier',
          'Amateur Challenge', 'Rising Stars Open'
        ];

        const tournamentNum = ((career.seasonWeek - 1) % tour.tournamentCount) + 1;
        const name = tournamentNames[(career.seasonWeek - 1) % tournamentNames.length];
        const seed = career.currentSeason * 1000 + career.seasonWeek;
        const prize = tour.basePrize;

        // Show confirmation overlay
        document.getElementById('career-hub-overlay').classList.add('hidden');
        document.getElementById('career-tournament-overlay').classList.remove('hidden');

        document.getElementById('career-tour-title').textContent = tour.name;
        document.getElementById('career-week-label').textContent = `Tournament ${tournamentNum} of ${tour.tournamentCount}`;

        const container = document.getElementById('career-tournament-list');
        container.innerHTML = `
          <div class="tournament-confirm">
            <div class="tournament-confirm-name">${name}</div>
            <div class="tournament-confirm-details">
              <div class="confirm-detail"><span>ðŸ“</span> 9 Holes</div>
              <div class="confirm-detail"><span>ðŸ’µ</span> ${tour.entryFee > 0 ? 'Entry: $' + tour.entryFee : 'Free Entry'}</div>
              <div class="confirm-detail"><span>ðŸ†</span> Prize: $${prize}</div>
            </div>
            <button class="career-btn primary tournament-start-btn" id="start-tournament-btn">
              Tee Off!
            </button>
          </div>
        `;

        document.getElementById('start-tournament-btn').addEventListener('click', () => {
          this.startTournament(name, seed, tour.entryFee, prize);
        });
      },

      startTournament(name, seed, entryFee, prize) {
        if (this.activeCareer.careerGolfBucks < entryFee) {
          alert('Not enough Golf Bucks!');
          return;
        }

        this.activeCareer.careerGolfBucks -= entryFee;
        this.saveActiveCareer();

        this.activeTournament = {
          name,
          seed,
          entryFee,
          prize,
          tour: this.activeCareer.currentTour
        };

        document.getElementById('career-tournament-overlay').classList.add('hidden');

        // Show pre-tournament interview for all tournaments
        this.showPreTournamentInterview();
      },

      // Interview questions with response options and fanbase gains
      interviewQuestions: [
        {
          question: "How are you feeling heading into today's tournament?",
          responses: [
            { text: "I'm confident. I've been practicing hard and I'm ready to compete.", fans: 50 },
            { text: "A little nervous honestly, but that's what keeps you sharp out there.", fans: 75 },
            { text: "I just want to thank my fans for all their support. This one's for them!", fans: 100 },
            { text: "Ready to dominate. Everyone else is playing for second place.", fans: 25 }
          ]
        },
        {
          question: "What's your game plan for today?",
          responses: [
            { text: "Stay patient, hit smart shots, and let the birdies come naturally.", fans: 75 },
            { text: "Attack the course. I'm going for pins and making putts.", fans: 50 },
            { text: "Focus on each shot one at a time. The score takes care of itself.", fans: 60 },
            { text: "Whatever it takes to win. I didn't come here to play safe.", fans: 40 }
          ]
        },
        {
          question: "Your fans have been incredible. Any message for them?",
          responses: [
            { text: "Every single one of you means the world to me. Thank you!", fans: 150 },
            { text: "Keep cheering! Your energy pushes me to be better.", fans: 100 },
            { text: "The support has been amazing. I won't let you down.", fans: 125 },
            { text: "Tell them to keep watching. They're about to see something special.", fans: 75 }
          ]
        },
        {
          question: "What drives you to compete at this level?",
          responses: [
            { text: "I love the game. Golf has given me everything.", fans: 80 },
            { text: "Proving doubters wrong. They said I couldn't make it.", fans: 60 },
            { text: "My family. Everything I do is to make them proud.", fans: 100 },
            { text: "The thrill of competition. There's nothing like it.", fans: 70 }
          ]
        },
        {
          question: "Any thoughts on your competition today?",
          responses: [
            { text: "Talented field, but I'm focused on my own game.", fans: 75 },
            { text: "Respect to everyone, but I came here to win.", fans: 60 },
            { text: "Some great players out here. May the best golfer win!", fans: 90 },
            { text: "They should be worried about me, not the other way around.", fans: 30 }
          ]
        }
      ],

      interviewStep: 0,
      selectedResponses: [],
      totalFansGained: 0,

      async showPreTournamentInterview() {
        const career = this.activeCareer;

        // Initialize fanbase if not exists
        if (!career.fanbase) career.fanbase = 0;

        this.interviewStep = 0;
        this.selectedResponses = [];
        this.totalFansGained = 0;

        // Pick 2 random questions
        const shuffled = [...this.interviewQuestions].sort(() => Math.random() - 0.5);
        this.currentInterviewQuestions = shuffled.slice(0, 2);

        document.getElementById('interview-overlay').classList.remove('hidden');
        document.getElementById('interview-player-name').textContent = career.playerName;

        // Draw player character - full body
        const playerCanvas = document.getElementById('interview-player-canvas');
        await this.drawCharacter(playerCanvas, career.character, 'idle');

        // Draw reporter - full body
        const reporterCanvas = document.getElementById('interview-reporter-canvas');
        await this.drawReporter(reporterCanvas);

        // Setup continue button
        document.getElementById('interview-continue-btn').onclick = () => this.advanceInterview();
        document.getElementById('interview-skip-btn').onclick = () => this.skipInterview();

        // Show first dialogue
        this.showInterviewDialogue();
      },

      showInterviewDialogue() {
        const career = this.activeCareer;
        const textEl = document.getElementById('interview-text');
        const speakerEl = document.getElementById('interview-speaker');
        const continueBtn = document.getElementById('interview-continue-btn');
        const skipBtn = document.getElementById('interview-skip-btn');

        // Step 0: Reporter intro
        if (this.interviewStep === 0) {
          speakerEl.textContent = 'Sarah Collins';
          textEl.innerHTML = `Good morning golf fans! I'm here with <strong>${career.playerName}</strong> just before tee time at the ${this.activeTournament.name}. Let's get their thoughts heading into today's round.`;
          continueBtn.textContent = 'Continue';
          continueBtn.classList.remove('hidden');
          skipBtn.classList.add('hidden');
        }
        // Question steps
        else if (this.interviewStep <= this.currentInterviewQuestions.length) {
          const q = this.currentInterviewQuestions[this.interviewStep - 1];
          speakerEl.textContent = 'Sarah Collins';
          textEl.innerHTML = `"${q.question}"`;

          // Add response buttons
          const responsesHTML = q.responses.map((r, i) =>
            `<button class="interview-response-btn" data-index="${i}">${r.text}</button>`
          ).join('');

          textEl.innerHTML += `<div class="interview-responses">${responsesHTML}</div>`;

          // Setup response handlers
          textEl.querySelectorAll('.interview-response-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
              const idx = parseInt(e.target.dataset.index);
              this.selectInterviewResponse(idx);
            });
          });

          continueBtn.classList.add('hidden');
          skipBtn.classList.remove('hidden');
        }
        // Final step: closing
        else {
          speakerEl.textContent = 'Sarah Collins';
          textEl.innerHTML = `Thank you ${career.playerName}! Best of luck out there today. Back to you in the booth.`;
          continueBtn.textContent = 'Start Tournament';
          continueBtn.classList.remove('hidden');
          skipBtn.classList.add('hidden');

          // Show fanbase gain
          if (this.totalFansGained > 0) {
            this.showFanbaseGain(this.totalFansGained);
          }
        }
      },

      selectInterviewResponse(index) {
        const q = this.currentInterviewQuestions[this.interviewStep - 1];
        const response = q.responses[index];

        // Mark selected
        document.querySelectorAll('.interview-response-btn').forEach(btn => {
          btn.classList.remove('selected');
        });
        document.querySelector(`.interview-response-btn[data-index="${index}"]`).classList.add('selected');

        // Track response
        this.selectedResponses.push({ question: q.question, response: response.text, fans: response.fans });
        this.totalFansGained += response.fans;

        // Show player saying the response
        setTimeout(() => {
          const speakerEl = document.getElementById('interview-speaker');
          const textEl = document.getElementById('interview-text');
          const career = this.activeCareer;

          speakerEl.textContent = career.playerName;
          textEl.innerHTML = `"${response.text}"`;

          // Show continue button
          document.getElementById('interview-continue-btn').classList.remove('hidden');
          document.getElementById('interview-continue-btn').textContent = 'Continue';
          document.getElementById('interview-skip-btn').classList.add('hidden');
        }, 300);
      },

      advanceInterview() {
        this.interviewStep++;
        if (this.interviewStep > this.currentInterviewQuestions.length + 1) {
          // Apply fanbase gains and start tournament
          const career = this.activeCareer;
          career.fanbase = (career.fanbase || 0) + this.totalFansGained;
          this.saveActiveCareer();

          document.getElementById('interview-overlay').classList.add('hidden');

          // Check for milestone rewards
          const milestones = this.checkFanbaseMilestones();

          // Delay tournament start if milestone was reached
          const delay = milestones.length > 0 ? 4500 : 500;

          // Announce on tee after interview
          setTimeout(() => {
            Announcer.announceOnTee(career.playerName);
          }, delay);

          setTimeout(() => {
            this.actuallyStartTournament();
          }, delay + 500);
        } else {
          this.showInterviewDialogue();
        }
      },

      skipInterview() {
        // Skip gives minimal fanbase
        this.totalFansGained += 10;
        this.interviewStep++;
        if (this.interviewStep > this.currentInterviewQuestions.length) {
          this.interviewStep = this.currentInterviewQuestions.length + 1;
        }
        this.showInterviewDialogue();
      },

      showFanbaseGain(amount) {
        const popup = document.createElement('div');
        popup.className = 'fanbase-gain';
        popup.innerHTML = `+${amount} Fans!`;
        document.body.appendChild(popup);

        setTimeout(() => popup.remove(), 2500);
      },

      // Fanbase milestone rewards
      fanbaseMilestones: [
        { fans: 100, name: 'Rising Star', reward: { tourCoins: 50 }, message: 'You\'re getting noticed!' },
        { fans: 500, name: 'Fan Favorite', reward: { tourCoins: 100, golfBucks: 200 }, message: 'Fans are wearing your colors!' },
        { fans: 1000, name: 'Local Celebrity', reward: { tourCoins: 200, golfBucks: 500, bonusEarnings: 0.05 }, message: '+5% tournament earnings!' },
        { fans: 2500, name: 'Tour Star', reward: { tourCoins: 300, golfBucks: 1000, bonusEarnings: 0.10 }, message: '+10% tournament earnings!' },
        { fans: 5000, name: 'Golf Icon', reward: { tourCoins: 500, golfBucks: 2000, bonusEarnings: 0.15, unlock: 'gold_club' }, message: '+15% earnings + Gold Club unlocked!' },
        { fans: 10000, name: 'Superstar', reward: { tourCoins: 750, golfBucks: 5000, bonusEarnings: 0.20, unlock: 'diamond_ball' }, message: '+20% earnings + Diamond Ball unlocked!' },
        { fans: 25000, name: 'Legend', reward: { tourCoins: 1000, golfBucks: 10000, bonusEarnings: 0.25, unlock: 'legend_outfit' }, message: '+25% earnings + Legend Outfit unlocked!' },
        { fans: 50000, name: 'GOAT', reward: { tourCoins: 2000, golfBucks: 25000, bonusEarnings: 0.30, unlock: 'goat_trophy' }, message: 'The Greatest of All Time! +30% earnings!' }
      ],

      checkFanbaseMilestones() {
        const career = this.activeCareer;
        if (!career.fanbaseMilestonesReached) {
          career.fanbaseMilestonesReached = [];
        }

        const newMilestones = [];
        for (const milestone of this.fanbaseMilestones) {
          if (career.fanbase >= milestone.fans && !career.fanbaseMilestonesReached.includes(milestone.fans)) {
            career.fanbaseMilestonesReached.push(milestone.fans);
            newMilestones.push(milestone);

            // Apply rewards
            if (milestone.reward.tourCoins) {
              career.tourCoins += milestone.reward.tourCoins;
            }
            if (milestone.reward.golfBucks) {
              career.careerGolfBucks += milestone.reward.golfBucks;
            }
            if (milestone.reward.bonusEarnings) {
              career.fanbaseBonus = milestone.reward.bonusEarnings;
            }
            if (milestone.reward.unlock) {
              if (!career.unlockedItems) career.unlockedItems = [];
              career.unlockedItems.push(milestone.reward.unlock);
            }
          }
        }

        if (newMilestones.length > 0) {
          this.saveActiveCareer();
          this.showMilestoneReward(newMilestones[newMilestones.length - 1]);
        }

        return newMilestones;
      },

      showMilestoneReward(milestone) {
        const popup = document.createElement('div');
        popup.className = 'milestone-popup';
        popup.innerHTML = `
          <div class="milestone-badge">â­</div>
          <div class="milestone-title">${milestone.name}</div>
          <div class="milestone-fans">${milestone.fans.toLocaleString()} Fans!</div>
          <div class="milestone-message">${milestone.message}</div>
          <div class="milestone-rewards">
            ${milestone.reward.tourCoins ? `<span>ðŸª™ +${milestone.reward.tourCoins}</span>` : ''}
            ${milestone.reward.golfBucks ? `<span>ðŸ’µ +$${milestone.reward.golfBucks}</span>` : ''}
          </div>
        `;
        document.body.appendChild(popup);

        // Announce it
        Announcer.speak(`Congratulations! You've reached ${milestone.name} status with ${milestone.fans.toLocaleString()} fans!`, { rate: 0.9 });

        setTimeout(() => popup.remove(), 4000);
      },

      getFanbaseBonus() {
        const career = this.activeCareer;
        return career?.fanbaseBonus || 0;
      },

      getFanbaseLevel() {
        const career = this.activeCareer;
        if (!career?.fanbase) return null;

        let currentLevel = null;
        for (const milestone of this.fanbaseMilestones) {
          if (career.fanbase >= milestone.fans) {
            currentLevel = milestone;
          }
        }
        return currentLevel;
      },

      debutScene: 0,

      async showDebutCutscene() {
        this.debutScene = 0;
        document.getElementById('debut-cutscene-overlay').classList.remove('hidden');
        this.showDebutScene(0);

        // Draw player avatar
        const smallCanvas = document.getElementById('debut-player-canvas');
        const largeCanvas = document.getElementById('debut-golfer-canvas');
        await this.drawCharacterAvatar(smallCanvas, this.activeCareer.character, 0.9);
        await this.drawCharacter(largeCanvas, this.activeCareer.character, 'idle');

        // Set player name
        document.getElementById('debut-player-name').textContent = this.activeCareer.playerName;

        // Setup continue button
        const continueBtn = document.getElementById('debut-continue-btn');
        continueBtn.onclick = () => this.advanceDebutScene();
      },

      showDebutScene(sceneNum) {
        // Hide all scenes
        document.getElementById('debut-scene-1').classList.add('hidden');
        document.getElementById('debut-scene-2').classList.add('hidden');
        document.getElementById('debut-scene-3').classList.add('hidden');

        const career = this.activeCareer;

        if (sceneNum === 0) {
          // Announcer scene
          document.getElementById('debut-scene-1').classList.remove('hidden');
          document.getElementById('debut-text-1').innerHTML =
            `<div style="margin-bottom: 20px;">Welcome to the <span style="color: #A78BFA; font-weight: bold;">Local Tour!</span></div>
             <div>Today marks a special occasion as we welcome a promising new talent to the tour...</div>`;
        } else if (sceneNum === 1) {
          // Interview scene
          document.getElementById('debut-scene-2').classList.remove('hidden');
          document.getElementById('interview-question').textContent =
            `"${career.playerName}, you're about to make your professional debut. How are you feeling heading into your first tournament?"`;
          document.getElementById('player-response').textContent =
            `"I've been working towards this moment my whole life. I'm ready to show everyone what I can do out there. Let's make some history!"`;
        } else if (sceneNum === 2) {
          // Tee intro scene
          document.getElementById('debut-scene-3').classList.remove('hidden');
          document.getElementById('debut-continue-btn').textContent = 'Start Tournament';
        }
      },

      advanceDebutScene() {
        this.debutScene++;
        if (this.debutScene < 3) {
          this.showDebutScene(this.debutScene);
        } else {
          // End cutscene, start tournament
          document.getElementById('debut-cutscene-overlay').classList.add('hidden');
          const rivalType = this.shouldShowRival();
          if (rivalType) {
            this.showRivalEncounter(rivalType);
          } else {
            this.actuallyStartTournament();
          }
        }
      },

      shouldShowRival() {
        const career = this.activeCareer;
        const roundsPlayed = career.stats.roundsPlayed;

        // First encounter after debut (round 2)
        if (roundsPlayed === 1 && !career.rival?.firstMet) return 'firstMeet';

        // Show rival on Legend Tour first tournament
        if (career.currentTour === 'legend' && !career.rival?.legendMet) return 'legend';

        // Regular encounters every 3-4 tournaments
        if (roundsPlayed > 1 && roundsPlayed % 3 === 0) return 'regular';

        // Random chance (20%) for any tournament
        if (Math.random() < 0.2) return 'regular';

        return false;
      },

      showRivalEncounter(type = 'regular') {
        const career = this.activeCareer;

        // Initialize rival tracking if needed
        if (!career.rival) {
          career.rival = { encounterCount: 0, winsAgainst: 0, firstMet: false, legendMet: false };
        }

        let phrases;
        if (type === 'firstMeet') {
          phrases = this.rival.phrases.firstMeet;
          career.rival.firstMet = true;
        } else if (type === 'legend') {
          phrases = this.rival.phrases.legend;
          career.rival.legendMet = true;
        } else {
          phrases = this.rival.phrases.intro;
        }

        career.rival.encounterCount++;
        this.saveActiveCareer();

        const phrase = phrases[Math.floor(Math.random() * phrases.length)];

        document.getElementById('dialogue-portrait').textContent = this.rival.portrait;
        document.getElementById('dialogue-speaker').textContent = this.rival.name;
        document.getElementById('dialogue-text').textContent = phrase;
        document.getElementById('career-dialogue-overlay').classList.remove('hidden');
      },

      continueDialogue() {
        document.getElementById('career-dialogue-overlay').classList.add('hidden');
        this.actuallyStartTournament();
      },

      // === TOUR COINS SHOP ===
      openShop() {
        document.getElementById('career-hub-overlay').classList.add('hidden');
        document.getElementById('tour-coins-shop-overlay').classList.remove('hidden');
        document.getElementById('shop-coin-balance').textContent = this.activeCareer.tourCoins;
        this.currentShopTab = 'hats';
        this.selectedShopItem = null;
        this.shopPreviewItem = null; // Item being "tried on"
        this.renderShopItems();
        this.updateShopCharacter();
        this.updateEquippedList();
      },

      closeShop() {
        document.getElementById('tour-coins-shop-overlay').classList.add('hidden');
        this.shopPreviewItem = null;
        this.showCareerHub();
      },

      switchShopTab(tab) {
        this.currentShopTab = tab;
        this.selectedShopItem = null;
        this.shopPreviewItem = null;
        document.querySelectorAll('.shop-tab').forEach(t => t.classList.remove('active'));
        document.querySelector(`.shop-tab[data-tab="${tab}"]`).classList.add('active');
        this.renderShopItems();
        this.updateShopCharacter();
        document.getElementById('shop-trying-on').textContent = '';
      },

      renderShopItems() {
        const items = this.shopItems[this.currentShopTab];
        const grid = document.getElementById('shop-items-grid');
        const career = this.activeCareer;

        // Toggle grid layout for sets
        grid.classList.toggle('sets-grid', this.currentShopTab === 'sets');

        if (this.currentShopTab === 'sets') {
          // Special rendering for sets
          grid.innerHTML = items.map(item => {
            const owned = career.character.ownedSets?.includes(item.id);
            const selected = this.selectedShopItem?.id === item.id;

            let badge = owned ? '<span class="shop-item-badge owned-badge">OWNED</span>' : '';
            let itemClass = selected ? 'selected ' : '';
            itemClass += owned ? 'owned' : '';

            // Show what's in the set
            const hatName = item.hat ? this.shopItems.hats.find(h => h.id === item.hat)?.name || item.hat : 'None';
            const glassesName = item.glasses ? this.shopItems.glasses.find(g => g.id === item.glasses)?.name || item.glasses : 'None';

            let btnHtml = '';
            if (owned) {
              btnHtml = `<button class="shop-item-btn equip-btn" data-action="equip" data-item-id="${item.id}">Equip Set</button>`;
            } else {
              const canAfford = career.tourCoins >= item.price;
              btnHtml = `<button class="shop-item-btn buy-btn" data-action="buy" data-item-id="${item.id}" ${canAfford ? '' : 'disabled'}>Buy ðŸª™${item.price}</button>`;
            }

            return `
              <div class="shop-item set-item ${itemClass}" data-item-id="${item.id}">
                ${badge}
                <div class="shop-item-preview">${item.icon}</div>
                <div class="shop-item-name">${item.name}</div>
                <div class="shop-set-contents">
                  <span>ðŸ§¢ ${hatName}</span>
                  <span>ðŸ•¶ï¸ ${glassesName}</span>
                  <span>ðŸ‘” Outfit</span>
                </div>
                ${btnHtml}
              </div>
            `;
          }).join('');
        } else {
          // Regular items (hats, glasses, outfits)
          grid.innerHTML = items.map(item => {
            const owned = career.character.accessories?.includes(item.id) ||
                          career.character.ownedOutfits?.includes(item.id);
            const equipped = career.character.equippedHat === item.id ||
                            career.character.equippedGlasses === item.id ||
                            (this.currentShopTab === 'outfits' && career.character.outfitDesign === item.design);
            const selected = this.selectedShopItem?.id === item.id;

            let badge = '';
            if (equipped) badge = '<span class="shop-item-badge equipped-badge">EQUIPPED</span>';
            else if (owned) badge = '<span class="shop-item-badge owned-badge">OWNED</span>';

            let itemClass = selected ? 'selected ' : '';
            itemClass += equipped ? 'equipped' : (owned ? 'owned' : '');

            // Button for each item
            let btnHtml = '';
            if (equipped) {
              btnHtml = `<button class="shop-item-btn unequip-btn" data-action="unequip" data-item-id="${item.id}">Unequip</button>`;
            } else if (owned) {
              btnHtml = `<button class="shop-item-btn equip-btn" data-action="equip" data-item-id="${item.id}">Equip</button>`;
            } else {
              const canAfford = career.tourCoins >= item.price;
              btnHtml = `<button class="shop-item-btn buy-btn" data-action="buy" data-item-id="${item.id}" ${canAfford ? '' : 'disabled'}>Buy ðŸª™${item.price}</button>`;
            }

            return `
              <div class="shop-item ${itemClass}" data-item-id="${item.id}">
                ${badge}
                <div class="shop-item-preview">${item.icon}</div>
                <div class="shop-item-name">${item.name}</div>
                ${btnHtml}
              </div>
            `;
          }).join('');
        }

        // Add click handlers for item cards (try on)
        grid.querySelectorAll('.shop-item').forEach(el => {
          el.addEventListener('click', (e) => {
            // Don't trigger if clicking the button
            if (e.target.classList.contains('shop-item-btn')) return;
            const itemId = el.dataset.itemId;
            this.selectShopItem(itemId);
          });
        });

        // Add click handlers for action buttons
        grid.querySelectorAll('.shop-item-btn').forEach(btn => {
          btn.addEventListener('click', (e) => {
            e.stopPropagation();
            const itemId = btn.dataset.itemId;
            const action = btn.dataset.action;
            this.shopItemAction(itemId, action);
          });
        });
      },

      selectShopItem(itemId) {
        const items = this.shopItems[this.currentShopTab];
        const item = items.find(i => i.id === itemId);
        if (!item) return;

        // Toggle selection - if same item clicked, deselect
        if (this.selectedShopItem?.id === itemId) {
          this.selectedShopItem = null;
          this.shopPreviewItem = null;
          document.getElementById('shop-trying-on').textContent = '';
        } else {
          this.selectedShopItem = item;
          this.shopPreviewItem = item;
          document.getElementById('shop-trying-on').textContent = `Trying: ${item.name}`;
        }

        // Update visual selection
        document.querySelectorAll('.shop-item').forEach(el => {
          el.classList.toggle('selected', el.dataset.itemId === this.selectedShopItem?.id);
        });

        // Update character preview with item
        this.updateShopCharacter();
      },

      async updateShopCharacter() {
        const canvas = document.getElementById('shop-character-canvas');
        const previewChar = { ...this.activeCareer.character };

        // If trying on an item, apply it temporarily
        if (this.shopPreviewItem) {
          const item = this.shopPreviewItem;
          if (this.currentShopTab === 'hats') {
            previewChar.equippedHat = item.id;
          } else if (this.currentShopTab === 'glasses') {
            previewChar.equippedGlasses = item.id;
          } else if (this.currentShopTab === 'outfits') {
            if (item.shirtColor) previewChar.outfitShirt = item.shirtColor;
            if (item.pantsColor) previewChar.outfitPants = item.pantsColor;
            previewChar.outfitDesign = item.design || null;
            previewChar.outfitStripeColor = item.stripeColor || null;
            previewChar.outfitGradientTo = item.gradientTo || null;
            previewChar.outfitPatternColor = item.patternColor || null;
          } else if (this.currentShopTab === 'sets') {
            // Preview full set
            previewChar.equippedHat = item.hat || null;
            previewChar.equippedGlasses = item.glasses || null;
            if (item.outfit) {
              if (item.outfit.shirtColor) previewChar.outfitShirt = item.outfit.shirtColor;
              if (item.outfit.pantsColor) previewChar.outfitPants = item.outfit.pantsColor;
              previewChar.outfitDesign = item.outfit.design || null;
              previewChar.outfitStripeColor = item.outfit.stripeColor || null;
              previewChar.outfitGradientTo = item.outfit.gradientTo || null;
              previewChar.outfitPatternColor = item.outfit.patternColor || null;
            }
          }
        }

        await this.drawCharacter(canvas, previewChar, 'idle');
      },

      updateEquippedList() {
        const career = this.activeCareer;
        const container = document.getElementById('shop-equipped-list');
        let html = '';

        // Find equipped hat name
        if (career.character.equippedHat) {
          const hat = this.shopItems.hats.find(h => h.id === career.character.equippedHat);
          if (hat) html += `<div class="shop-equipped-item"><span>ðŸ§¢</span><span>${hat.name}</span></div>`;
        }

        // Find equipped glasses name
        if (career.character.equippedGlasses) {
          const glasses = this.shopItems.glasses.find(g => g.id === career.character.equippedGlasses);
          if (glasses) html += `<div class="shop-equipped-item"><span>ðŸ•¶ï¸</span><span>${glasses.name}</span></div>`;
        }

        if (!html) html = '<div style="text-align:center; color: rgba(255,255,255,0.4); font-size: 10px;">No accessories equipped</div>';
        container.innerHTML = html;
      },

      shopItemAction(itemId, action) {
        const career = this.activeCareer;

        // Check if it's a set
        const setItem = this.shopItems.sets.find(s => s.id === itemId);
        if (setItem) {
          if (action === 'buy') {
            if (career.tourCoins < setItem.price) return;
            career.tourCoins -= setItem.price;
            document.getElementById('shop-coin-balance').textContent = career.tourCoins;

            // Add set to owned
            if (!career.character.ownedSets) career.character.ownedSets = [];
            career.character.ownedSets.push(setItem.id);

            // Auto-equip the set
            this.equipSet(setItem);
          } else if (action === 'equip') {
            this.equipSet(setItem);
          }
        } else {
          // Regular item
          const allItems = [...this.shopItems.hats, ...this.shopItems.glasses, ...this.shopItems.outfits];
          const item = allItems.find(i => i.id === itemId);
          if (!item) return;

          // Determine item type
          let itemType = 'hats';
          if (this.shopItems.glasses.find(g => g.id === itemId)) itemType = 'glasses';
          else if (this.shopItems.outfits.find(o => o.id === itemId)) itemType = 'outfits';

          if (action === 'unequip') {
            if (itemType === 'hats') {
              career.character.equippedHat = null;
            } else if (itemType === 'glasses') {
              career.character.equippedGlasses = null;
            }
          } else if (action === 'equip') {
            if (itemType === 'hats') {
              career.character.equippedHat = item.id;
            } else if (itemType === 'glasses') {
              career.character.equippedGlasses = item.id;
            } else if (itemType === 'outfits') {
              this.applyOutfit(item);
            }
          } else if (action === 'buy') {
            if (career.tourCoins < item.price) return;

            career.tourCoins -= item.price;
            document.getElementById('shop-coin-balance').textContent = career.tourCoins;

            // Add to owned and auto-equip
            if (itemType === 'outfits') {
              if (!career.character.ownedOutfits) career.character.ownedOutfits = [];
              career.character.ownedOutfits.push(item.id);
              this.applyOutfit(item);
            } else {
              if (!career.character.accessories) career.character.accessories = [];
              career.character.accessories.push(item.id);
              if (itemType === 'hats') {
                career.character.equippedHat = item.id;
              } else if (itemType === 'glasses') {
                career.character.equippedGlasses = item.id;
              }
            }
          }
        }

        // Clear try-on state
        this.selectedShopItem = null;
        this.shopPreviewItem = null;
        document.getElementById('shop-trying-on').textContent = '';

        this.saveActiveCareer();
        this.renderShopItems();
        this.updateShopCharacter();
        this.updateEquippedList();
      },

      applyOutfit(outfit) {
        const char = this.activeCareer.character;
        if (outfit.shirtColor) char.outfitShirt = outfit.shirtColor;
        if (outfit.pantsColor) char.outfitPants = outfit.pantsColor;
        char.outfitDesign = outfit.design || null;
        char.outfitStripeColor = outfit.stripeColor || null;
        char.outfitGradientTo = outfit.gradientTo || null;
        char.outfitPatternColor = outfit.patternColor || null;
      },

      equipSet(set) {
        const char = this.activeCareer.character;
        // Equip hat (or remove if null)
        char.equippedHat = set.hat || null;
        // Equip glasses (or remove if null)
        char.equippedGlasses = set.glasses || null;
        // Apply outfit
        if (set.outfit) {
          this.applyOutfit(set.outfit);
        }
      },

      // === SPONSORS MANAGEMENT ===
      showSponsors() {
        document.getElementById('career-hub-overlay').classList.add('hidden');
        document.getElementById('sponsors-overlay').classList.remove('hidden');
        this.renderSponsorsContent();
      },

      renderSponsorsContent() {
        const career = this.activeCareer;
        const container = document.getElementById('sponsors-content');

        let html = '';

        // Equipment Sponsor Section
        html += '<div class="sponsor-section"><h3>ðŸŒï¸ Equipment Sponsor</h3>';
        if (career.equipmentSponsor) {
          const sponsor = this.equipmentSponsors[career.equipmentSponsor.id];
          const currentTier = sponsor.tiers.find(t => t.level === career.equipmentSponsor.level);
          const nextTier = sponsor.tiers.find(t => t.level === career.equipmentSponsor.level + 1);
          const xp = career.equipmentSponsor.xp || 0;
          const progress = nextTier ? Math.min(100, (xp / nextTier.xpRequired) * 100) : 100;

          html += `
            <div class="sponsor-card active">
              <div class="sponsor-info">
                <span class="sponsor-icon-large">${sponsor.icon}</span>
                <div class="sponsor-details">
                  <div class="sponsor-name">${sponsor.name}</div>
                  <div class="sponsor-level">Level ${career.equipmentSponsor.level}${nextTier ? ` â€¢ ${xp}/${nextTier.xpRequired} XP` : ' â€¢ MAX'}</div>
                </div>
              </div>
              <div class="sponsor-progress">
                <div class="sponsor-progress-fill" style="width: ${progress}%"></div>
              </div>
              <div class="sponsor-bonuses">
                <span class="sponsor-bonus">+${Math.round(currentTier.powerBonus * 100)}% Power</span>
                <span class="sponsor-bonus">+${Math.round(currentTier.accuracyBonus * 100)}% Accuracy</span>
                ${currentTier.reward ? `<span class="sponsor-bonus">${currentTier.reward}</span>` : ''}
              </div>
            </div>
          `;
        } else {
          html += '<div class="sponsor-card empty">No equipment sponsor yet.<br>Win tournaments to attract sponsors!</div>';
        }
        html += '</div>';

        // Apparel Sponsor Section
        html += '<div class="sponsor-section"><h3>ðŸ‘• Apparel Sponsor</h3>';
        if (career.apparelSponsor) {
          const sponsor = this.apparelSponsors[career.apparelSponsor.id];
          const currentTier = sponsor.tiers.find(t => t.level === career.apparelSponsor.level);
          const nextTier = sponsor.tiers.find(t => t.level === career.apparelSponsor.level + 1);
          const xp = career.apparelSponsor.xp || 0;
          const progress = nextTier ? Math.min(100, (xp / nextTier.xpRequired) * 100) : 100;

          html += `
            <div class="sponsor-card active">
              <div class="sponsor-info">
                <span class="sponsor-icon-large">${sponsor.icon}</span>
                <div class="sponsor-details">
                  <div class="sponsor-name">${sponsor.name}</div>
                  <div class="sponsor-level">Level ${career.apparelSponsor.level}${nextTier ? ` â€¢ ${xp}/${nextTier.xpRequired} XP` : ' â€¢ MAX'}</div>
                </div>
              </div>
              <div class="sponsor-progress">
                <div class="sponsor-progress-fill" style="width: ${progress}%"></div>
              </div>
              <div class="sponsor-bonuses">
                <span class="sponsor-bonus">+${currentTier.coinsPerRound} ðŸª™/round</span>
                ${currentTier.exclusiveOutfit ? `<span class="sponsor-bonus">Exclusive Outfit</span>` : ''}
              </div>
            </div>
          `;
        } else {
          html += '<div class="sponsor-card empty">No apparel sponsor yet.<br>Keep playing to get noticed!</div>';
        }
        html += '</div>';

        container.innerHTML = html;
      },

      async actuallyStartTournament() {
        this.isInCareerTournament = true;
        window.careerModeActive = true;

        // Use tour-specific themes (includes career-exclusive courses at higher tiers)
        const tour = this.tours[this.activeCareer.currentTour];
        const themes = tour.themes || ['classic', 'desert', 'winter', 'tropical'];
        const theme = themes[Math.floor(Math.random() * themes.length)];

        if (typeof gameEngine !== 'undefined') {
          await gameEngine.startNewRound(
            this.activeTournament.seed,
            this.activeCareer.playerName,
            'white',
            theme
          );
          gameEngine.start();

          // Show the player cutaway renderer
          if (typeof CareerPlayerRenderer !== 'undefined') {
            CareerPlayerRenderer.init();
          }

          // Announce player on the tee after a short delay
          setTimeout(() => {
            Announcer.announceOnTee(this.activeCareer.playerName);
          }, 1500);
        }
      },

      completeTournament(scoreRelativeToPar, totalStrokes) {
        if (!this.activeTournament || !this.isInCareerTournament) return null;

        const career = this.activeCareer;
        const tour = this.tours[career.currentTour];

        // Calculate position (simplified - based on score)
        let position = 1;
        if (scoreRelativeToPar > -5) position = Math.min(25, 1 + Math.floor((scoreRelativeToPar + 5) * 2));

        // Calculate earnings
        let earnings = 0;
        const prizePool = this.activeTournament.prize;
        if (position === 1) earnings = prizePool;
        else if (position === 2) earnings = Math.floor(prizePool * 0.6);
        else if (position === 3) earnings = Math.floor(prizePool * 0.4);
        else if (position <= 5) earnings = Math.floor(prizePool * 0.2);
        else if (position <= 10) earnings = Math.floor(prizePool * 0.1);

        // Calculate ranking points
        let points = 0;
        if (position === 1) points = 100;
        else if (position === 2) points = 70;
        else if (position === 3) points = 50;
        else if (position <= 5) points = 30;
        else if (position <= 10) points = 15;
        else if (position <= 15) points = 5;

        // Update career
        career.careerGolfBucks += earnings;
        career.rankingPoints += points;
        career.stats.roundsPlayed++;
        career.stats.totalEarnings += earnings;
        if (position === 1) {
          career.stats.tournamentsWon++;
          career.tourCoins += 10; // Bonus tour coins for winning
        }

        // Update best score
        if (!career.stats.bestScore || scoreRelativeToPar < career.stats.bestScore) {
          career.stats.bestScore = scoreRelativeToPar;
        }

        // Check for promotion
        if (tour.promotionPoints && career.rankingPoints >= tour.promotionPoints) {
          this.promoteTour();
        }

        // Advance week
        career.seasonWeek++;
        if (career.seasonWeek > tour.tournamentCount) {
          career.seasonWeek = 1;
          career.currentSeason++;
        }

        this.saveActiveCareer();
        this.isInCareerTournament = false;
        window.careerModeActive = false;
        this.activeTournament = null;

        // Check for sponsor offers
        if (position <= 5) {
          setTimeout(() => this.showSponsorOffers(position), 1000);
        }

        return { position, earnings, points };
      },

      promoteTour() {
        const tourOrder = ['local', 'amateur', 'pro', 'legend'];
        const currentIndex = tourOrder.indexOf(this.activeCareer.currentTour);
        if (currentIndex < tourOrder.length - 1) {
          this.activeCareer.currentTour = tourOrder[currentIndex + 1];
          this.activeCareer.tourCoins += 50; // Bonus for promotion
          this.activeCareer.tourHistory.push({
            tour: tourOrder[currentIndex],
            season: this.activeCareer.currentSeason,
            finalRanking: this.activeCareer.tourRanking
          });
        }
      },

      getEquipmentPowerBonus() {
        if (!this.activeCareer?.equipmentSponsor) return 0;
        const sponsor = this.equipmentSponsors[this.activeCareer.equipmentSponsor.id];
        if (!sponsor) return 0;
        const tier = sponsor.tiers.find(t => t.level === this.activeCareer.equipmentSponsor.level);
        return tier?.powerBonus || 0;
      },

      getEquipmentAccuracyBonus() {
        if (!this.activeCareer?.equipmentSponsor) return 0;
        const sponsor = this.equipmentSponsors[this.activeCareer.equipmentSponsor.id];
        if (!sponsor) return 0;
        const tier = sponsor.tiers.find(t => t.level === this.activeCareer.equipmentSponsor.level);
        return tier?.accuracyBonus || 0;
      },

      showSponsorOffers(position) {
        const career = this.activeCareer;
        const container = document.getElementById('sponsor-offer-content');
        container.innerHTML = '';

        // Get available sponsors for current tour
        const tourOrder = ['local', 'amateur', 'pro', 'legend'];
        const tourIndex = tourOrder.indexOf(career.currentTour);

        const availableEquip = Object.values(this.equipmentSponsors).filter(s => {
          const minIndex = tourOrder.indexOf(s.minTour);
          return minIndex <= tourIndex && (!career.equipmentSponsor || career.equipmentSponsor.id !== s.id);
        });

        const availableApparel = Object.values(this.apparelSponsors).filter(s => {
          const minIndex = tourOrder.indexOf(s.minTour);
          return minIndex <= tourIndex && (!career.apparelSponsor || career.apparelSponsor.id !== s.id);
        });

        if (availableEquip.length === 0 && availableApparel.length === 0) return;

        // Pick one random sponsor to offer
        const allAvailable = [...availableEquip, ...availableApparel];
        const offer = allAvailable[Math.floor(Math.random() * allAvailable.length)];

        const card = document.createElement('div');
        card.className = 'sponsor-card';
        card.innerHTML = `
          <div class="sponsor-card-header">
            <span class="sponsor-icon">${offer.icon}</span>
            <div>
              <div class="sponsor-name">${offer.name}</div>
              <div class="sponsor-type">${offer.type}</div>
            </div>
          </div>
          <div class="sponsor-benefits">
            ${offer.type === 'equipment' ?
              `+${Math.round(offer.tiers[0].powerBonus * 100)}% Power, +${Math.round(offer.tiers[0].accuracyBonus * 100)}% Accuracy` :
              'Unlock exclusive apparel rewards'}
          </div>
        `;
        card.addEventListener('click', () => {
          this.acceptSponsor(offer);
          document.getElementById('sponsor-offer-overlay').classList.add('hidden');
        });
        container.appendChild(card);

        document.getElementById('sponsor-offer-overlay').classList.remove('hidden');
      },

      acceptSponsor(sponsor) {
        if (sponsor.type === 'equipment') {
          this.activeCareer.equipmentSponsor = {
            id: sponsor.id,
            xp: 0,
            level: 1,
            tierClaimed: [1]
          };
        } else {
          this.activeCareer.apparelSponsor = {
            id: sponsor.id,
            xp: 0,
            level: 1,
            tierClaimed: [1]
          };
        }
        this.saveActiveCareer();
      }
    };

    // === CareerPlayerRenderer Module ===
    // Renders a cinematic cutaway showing the player hitting the ball
    const CareerPlayerRenderer = {
      canvas: null,
      ctx: null,
      isPlaying: false,
      animationFrame: null,
      startTime: 0,
      duration: 600,

      init() {
        this.canvas = document.getElementById('career-player-view');
        if (this.canvas) {
          this.ctx = this.canvas.getContext('2d');
          this.resizeCanvas();
          window.addEventListener('resize', () => this.resizeCanvas());
        }
      },

      resizeCanvas() {
        if (!this.canvas) return;
        const rect = this.canvas.parentElement?.getBoundingClientRect();
        if (rect) {
          this.canvas.width = rect.width;
          this.canvas.height = rect.height;
        }
      },

      triggerSwing() {
        if (!CareerSystem.isInCareerTournament || !CareerSystem.activeCareer) return;
        if (this.isPlaying) return;

        this.isPlaying = true;
        this.startTime = performance.now();
        this.resizeCanvas();

        this.canvas.classList.remove('hidden');
        this.canvas.classList.add('visible');
        this.animate();
      },

      animate() {
        const elapsed = performance.now() - this.startTime;
        const progress = Math.min(1, elapsed / this.duration);

        this.render(progress);

        if (progress < 1) {
          this.animationFrame = requestAnimationFrame(() => this.animate());
        } else {
          this.canvas.classList.remove('visible');
          this.canvas.classList.add('hidden');
          this.isPlaying = false;
        }
      },

      render(progress) {
        if (!this.ctx || !CareerSystem.activeCareer) return;

        const ctx = this.ctx;
        const char = CareerSystem.activeCareer.character;
        const width = this.canvas.width;
        const height = this.canvas.height;

        ctx.clearRect(0, 0, width, height);

        const letterboxHeight = height * 0.12;

        // Sky gradient
        const skyGradient = ctx.createLinearGradient(0, letterboxHeight, 0, height - letterboxHeight);
        skyGradient.addColorStop(0, '#87CEEB');
        skyGradient.addColorStop(0.4, '#B0E0E6');
        skyGradient.addColorStop(1, '#4CAF50');
        ctx.fillStyle = skyGradient;
        ctx.fillRect(0, letterboxHeight, width, height - letterboxHeight * 2);

        // Ground
        const groundY = height * 0.65;
        const groundGradient = ctx.createLinearGradient(0, groundY, 0, height - letterboxHeight);
        groundGradient.addColorStop(0, '#4CAF50');
        groundGradient.addColorStop(0.5, '#388E3C');
        groundGradient.addColorStop(1, '#2E7D32');
        ctx.fillStyle = groundGradient;
        ctx.fillRect(0, groundY, width, height - groundY - letterboxHeight);

        const charX = width * 0.4;
        const charY = height * 0.75;
        const scale = Math.min(width, height) / 180;

        // Swing animation
        let swingAngle = 0, clubAngle = 0, bodyRotation = 0;

        if (progress < 0.15) {
          const p = progress / 0.15;
          swingAngle = -Math.PI * 0.6 * p;
          clubAngle = -Math.PI * 0.7 * p;
          bodyRotation = -0.15 * p;
        } else if (progress < 0.35) {
          const p = (progress - 0.15) / 0.2;
          swingAngle = -Math.PI * 0.6 + Math.PI * 0.9 * p;
          clubAngle = -Math.PI * 0.7 + Math.PI * 1.1 * p;
          bodyRotation = -0.15 + 0.25 * p;
        } else if (progress < 0.5) {
          const p = (progress - 0.35) / 0.15;
          swingAngle = Math.PI * 0.3 + Math.PI * 0.2 * p;
          clubAngle = Math.PI * 0.4 + Math.PI * 0.2 * p;
          bodyRotation = 0.1 + 0.05 * p;
        } else {
          const p = (progress - 0.5) / 0.5;
          swingAngle = Math.PI * 0.5 + Math.PI * 0.15 * p;
          clubAngle = Math.PI * 0.6 + Math.PI * 0.2 * p;
          bodyRotation = 0.15 + 0.05 * p;
        }

        // Shadow
        ctx.fillStyle = 'rgba(0,0,0,0.25)';
        ctx.beginPath();
        ctx.ellipse(charX + 10, charY + 5, 40 * scale, 12 * scale, 0.2, 0, Math.PI * 2);
        ctx.fill();

        ctx.save();
        ctx.translate(charX, charY);
        ctx.rotate(bodyRotation);

        // Get sprite info for "Original" skin tone fallback
        const spriteInfo = CareerSystem.spriteMap[char.gender]?.[char.hairstyle];
        const skinTone = char.skinHex || spriteInfo?.skinHex || CareerSystem.skinTones[char.skinTone]?.hex || '#D4A574';

        // Legs
        ctx.fillStyle = char.outfitPants || '#1565C0';
        ctx.beginPath();
        ctx.ellipse(-8 * scale, 0, 10 * scale, 30 * scale, 0.1, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.ellipse(12 * scale, 0, 10 * scale, 30 * scale, -0.1, 0, Math.PI * 2);
        ctx.fill();

        // Torso
        ctx.fillStyle = char.outfitShirt || '#E53935';
        ctx.beginPath();
        ctx.ellipse(2 * scale, -45 * scale, 22 * scale, 30 * scale, 0, 0, Math.PI * 2);
        ctx.fill();

        // Arms
        ctx.save();
        ctx.translate(5 * scale, -55 * scale);
        ctx.rotate(swingAngle);

        ctx.fillStyle = skinTone;
        ctx.beginPath();
        ctx.ellipse(0, 20 * scale, 8 * scale, 22 * scale, 0, 0, Math.PI * 2);
        ctx.fill();

        ctx.beginPath();
        ctx.arc(0, 38 * scale, 7 * scale, 0, Math.PI * 2);
        ctx.fill();

        // Club
        ctx.save();
        ctx.translate(0, 38 * scale);
        ctx.rotate(clubAngle - swingAngle);

        ctx.strokeStyle = '#555';
        ctx.lineWidth = 4 * scale;
        ctx.lineCap = 'round';
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(0, 55 * scale);
        ctx.stroke();

        ctx.fillStyle = '#333';
        ctx.beginPath();
        ctx.ellipse(0, 60 * scale, 12 * scale, 5 * scale, 0.4, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();
        ctx.restore();

        // Head
        ctx.fillStyle = skinTone;
        ctx.beginPath();
        ctx.arc(0, -80 * scale, 18 * scale, 0, Math.PI * 2);
        ctx.fill();

        // Hair
        ctx.fillStyle = char.hairColor || '#4A3728';
        ctx.beginPath();
        ctx.arc(0, -83 * scale, 17 * scale, Math.PI + 0.3, -0.3);
        ctx.fill();

        // Eye
        ctx.fillStyle = '#333';
        ctx.beginPath();
        ctx.arc(10 * scale, -82 * scale, 3 * scale, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();

        // Impact flash
        if (progress > 0.33 && progress < 0.45) {
          const flashIntensity = 1 - Math.abs(progress - 0.39) / 0.06;
          ctx.fillStyle = `rgba(255, 255, 255, ${flashIntensity * 0.4})`;
          ctx.fillRect(0, letterboxHeight, width, height - letterboxHeight * 2);
        }

        // Ball flying
        if (progress > 0.4) {
          const ballProgress = (progress - 0.4) / 0.6;
          const ballX = charX + 80 + ballProgress * width * 0.5;
          const ballY = charY - 50 - Math.sin(ballProgress * Math.PI * 0.6) * 200;
          const ballSize = Math.max(2, 6 - ballProgress * 4);

          ctx.fillStyle = '#fff';
          ctx.beginPath();
          ctx.arc(ballX, ballY, ballSize, 0, Math.PI * 2);
          ctx.fill();
        }

        // Letterbox bars
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, width, letterboxHeight);
        ctx.fillRect(0, height - letterboxHeight, width, letterboxHeight);

        // Player name
        ctx.fillStyle = '#fff';
        ctx.font = `bold ${14 * (scale / 5)}px -apple-system, sans-serif`;
        ctx.textAlign = 'left';
        ctx.fillText(CareerSystem.activeCareer.playerName, 20, letterboxHeight - 8);

        ctx.textAlign = 'right';
        ctx.font = `${12 * (scale / 5)}px -apple-system, sans-serif`;
        ctx.fillStyle = 'rgba(255,255,255,0.7)';
        ctx.fillText('Career Mode', width - 20, letterboxHeight - 8);
      },

      update(gameState) {
        // Cutaway handles its own visibility
      },

      hide() {
        if (this.canvas) {
          this.canvas.classList.remove('visible');
          this.canvas.classList.add('hidden');
        }
        this.isPlaying = false;
        if (this.animationFrame) {
          cancelAnimationFrame(this.animationFrame);
        }
      }
    };

    // === MiniGameManager Module ===
    const MiniGameManager = {
      currentGame: null,
      isActive: false,
      timer: 0,
      score: 0,
      highScores: {},
      completedDates: {}, // Track which dates each challenge was completed
      storageKey: 'golf-minigame-scores',
      completedKey: 'golf-minigame-completed',
      dailySeed: 0, // Seeded random for consistent daily layouts

      games: {
        closestToPin: {
          name: 'Closest to Pin',
          icon: 'ðŸŽ¯',
          desc: 'Get as close to the hole as possible from 150 yards!',
          duration: 0, // Single shot, no timer
          scoreUnit: 'ft',
          lowerIsBetter: true
        },
        longestDrive: {
          name: 'Longest Drive',
          icon: 'ðŸ’ª',
          desc: 'Hit the ball as far as you can! 3 attempts.',
          duration: 0,
          scoreUnit: 'yds',
          lowerIsBetter: false
        },
        puttingChallenge: {
          name: 'Putting Challenge',
          icon: 'â›³',
          desc: 'Sink as many putts as you can! 10 attempts.',
          duration: 0, // No time limit
          scoreUnit: ' sunk',
          lowerIsBetter: false,
          totalAttempts: 10
        }
      },

      init() {
        this.load();
        this.loadCompleted();
        this.updateTodayLabel();
      },

      load() {
        try {
          const data = localStorage.getItem(this.storageKey);
          if (data) {
            this.highScores = JSON.parse(data);
          }
        } catch (e) {
          console.error('Failed to load mini-game scores:', e);
        }
      },

      loadCompleted() {
        try {
          const data = localStorage.getItem(this.completedKey);
          if (data) {
            this.completedDates = JSON.parse(data);
          }
        } catch (e) {
          console.error('Failed to load completion dates:', e);
        }
      },

      save() {
        try {
          localStorage.setItem(this.storageKey, JSON.stringify(this.highScores));
        } catch (e) {
          console.error('Failed to save mini-game scores:', e);
        }
      },

      saveCompleted() {
        try {
          localStorage.setItem(this.completedKey, JSON.stringify(this.completedDates));
        } catch (e) {
          console.error('Failed to save completion dates:', e);
        }
      },

      // Get today's date string for tracking
      getTodayDateString() {
        const now = new Date();
        return `${now.getFullYear()}-${now.getMonth() + 1}-${now.getDate()}`;
      },

      // Check if today's challenge has been completed
      hasCompletedToday() {
        const todayGame = this.getTodayGame();
        const todayDate = this.getTodayDateString();
        return this.completedDates[todayGame] === todayDate;
      },

      // Mark today's challenge as completed
      markCompleted() {
        const todayGame = this.getTodayGame();
        const todayDate = this.getTodayDateString();
        this.completedDates[todayGame] = todayDate;
        this.saveCompleted();
      },

      // Seeded random number generator for consistent daily layouts
      seededRandom() {
        this.dailySeed = (this.dailySeed * 9301 + 49297) % 233280;
        return this.dailySeed / 233280;
      },

      // Initialize seed based on date
      initDailySeed() {
        const now = new Date();
        // Create seed from date - same seed for same day
        this.dailySeed = now.getFullYear() * 10000 + (now.getMonth() + 1) * 100 + now.getDate();
      },

      // Get today's mini-game based on 3-day rotation
      getTodayGame() {
        const dayOfYear = Math.floor(Date.now() / (1000 * 60 * 60 * 24));
        const gameKeys = Object.keys(this.games);
        const index = dayOfYear % gameKeys.length;
        return gameKeys[index];
      },

      updateTodayLabel() {
        const todayGameKey = this.getTodayGame();
        const todayGame = this.games[todayGameKey];
        const label = document.getElementById('minigame-today-label');
        if (label) {
          label.textContent = `Today: ${todayGame.name}`;
        }

        // Highlight today's game button
        const btn = document.getElementById('minigame-play-btn');
        if (btn) {
          btn.classList.add('daily-highlight');
        }
      },

      showSelection() {
        const overlay = document.getElementById('minigame-overlay');
        const content = document.getElementById('minigame-content');
        const todayGameKey = this.getTodayGame();
        const todayGame = this.games[todayGameKey];
        const highScore = this.highScores[todayGameKey];
        const highScoreText = highScore !== undefined ?
          `Best: ${highScore}${todayGame.scoreUnit}` : 'No record yet';
        const alreadyCompleted = this.hasCompletedToday();

        let html;
        if (alreadyCompleted) {
          // Already completed today - show completion message
          html = `
            <div class="minigame-result">
              <h3>ðŸŽ¯ Today's Challenge</h3>
              <div style="display: flex; flex-direction: column; gap: 15px; margin-top: 20px;">
                <div class="game-mode-btn" style="padding: 20px; opacity: 0.7; cursor: default;">
                  <span class="mode-icon" style="font-size: 48px;">${todayGame.icon}</span>
                  <span class="mode-title" style="font-size: 24px;">${todayGame.name}</span>
                  <span class="mode-subtitle" style="color: #4CAF50;">âœ“ Completed Today!</span>
                  <span style="font-size: 14px; color: #4CAF50; margin-top: 10px; display: block;">${highScoreText}</span>
                </div>
              </div>
              <p style="color: #888; margin-top: 15px;">Come back tomorrow for a new challenge!</p>
              <button class="button" id="minigame-close-btn" style="margin-top: 20px;">Back</button>
            </div>
          `;
        } else {
          // Not completed - show play button
          html = `
            <div class="minigame-result">
              <h3>ðŸŽ¯ Today's Challenge</h3>
              <div style="display: flex; flex-direction: column; gap: 15px; margin-top: 20px;">
                <button class="game-mode-btn daily-highlight" id="start-daily-challenge" style="padding: 20px;">
                  <span class="mode-icon" style="font-size: 48px;">${todayGame.icon}</span>
                  <span class="mode-title" style="font-size: 24px;">${todayGame.name}</span>
                  <span class="mode-subtitle">${todayGame.desc}</span>
                  <span style="font-size: 14px; color: #4CAF50; margin-top: 10px; display: block;">${highScoreText}</span>
                </button>
              </div>
              <p style="color: #888; margin-top: 15px;">One attempt per day!</p>
              <button class="button" id="minigame-close-btn" style="margin-top: 20px;">Back</button>
            </div>
          `;
        }

        content.innerHTML = html;
        overlay.classList.remove('hidden');

        // Add event listener for today's challenge (only if not completed)
        const startBtn = document.getElementById('start-daily-challenge');
        if (startBtn) {
          startBtn.addEventListener('click', () => {
            this.startGame(todayGameKey);
          });
        }

        document.getElementById('minigame-close-btn').addEventListener('click', () => {
          overlay.classList.add('hidden');
        });
      },

      startGame(gameKey) {
        console.log('=== MINIGAME START ===', gameKey);
        const game = this.games[gameKey];
        if (!game) { console.error('Game not found:', gameKey); return; }

        // Initialize daily seed for consistent layouts
        this.initDailySeed();

        this.currentGame = gameKey;
        this.isActive = true;
        console.log('Game active:', { currentGame: this.currentGame, isActive: this.isActive });
        this.score = 0;
        this.timer = game.duration;
        this.attempts = gameKey === 'longestDrive' ? 3 : 1;
        this.bestAttempt = 0;

        document.getElementById('minigame-overlay').classList.add('hidden');
        document.getElementById('game-mode-overlay').classList.add('hidden');
        document.getElementById('menu-overlay').classList.add('hidden');

        // Initialize game engine state for mini-game
        if (window.gameEngine) {
          const canvas = document.getElementById('game-canvas');
          const rect = canvas.getBoundingClientRect();

          // Use CourseGenerator for proper hole with rendering support
          const seed = Date.now();
          CourseGenerator.init(seed);
          const miniGameHole = CourseGenerator.generateHole(1, rect.width, rect.height);

          // Initialize gameState if it doesn't exist
          window.gameEngine.gameState = {
            currentHole: miniGameHole,
            round: {
              roundId: 'minigame-' + Date.now(),
              startTime: Date.now(),
              endTime: null,
              currentHoleNumber: 1,
              isComplete: false,
              holeScores: [],
              totalStrokes: 0,
              totalPar: 0,
              scoreRelativeToPar: 0,
              currentStrokeCount: 0
            },
            ball: window.gameEngine.createBall(miniGameHole, 'white'),
            selectedClub: 'driver',
            seed: seed,
            playerName: localStorage.getItem('golf-player-name') || 'Player',
            ballColor: 'white',
            isMiniGame: true
          };

          window.gameEngine.currentHole = miniGameHole;
          console.log('MiniGame setup complete:', { currentHole: !!window.gameEngine.currentHole, isActive: this.isActive, gameKey: gameKey });

          // Reset hole completion flag for fresh game
          window.gameEngine.holeCompleting = false;

          // Generate wind for the mini-game
          WindSystem.generateWind(1);

          // Start the game engine if not already running
          window.gameEngine.start();
        }

        // Show HUD only for timed games
        const hud = document.getElementById('minigame-hud');
        if (game.duration > 0) {
          hud.classList.remove('hidden');
          hud.style.padding = '10px 30px';
          hud.style.background = 'rgba(0,0,0,0.8)';
          document.getElementById('minigame-timer').textContent = this.timer;
          document.getElementById('minigame-score').textContent = '0';
        } else {
          // Hide HUD for single-shot games
          hud.classList.add('hidden');
        }

        // Setup the game
        if (gameKey === 'closestToPin') {
          this.setupClosestToPin();
        } else if (gameKey === 'longestDrive') {
          this.setupLongestDrive();
        } else if (gameKey === 'puttingChallenge') {
          this.setupPuttingChallenge();
        }
      },

      setupClosestToPin() {
        // Position ball 150 yards from hole
        if (window.gameEngine && window.gameEngine.gameState) {
          const hole = window.gameEngine.gameState.currentHole;

          // Position ball 150 yards from the generated hole
          const holeX = hole.holePosition.x;
          const holeY = hole.holePosition.y;
          const ballX = Math.max(50, holeX - (150 * YARDS_TO_PIXELS));
          const ballY = holeY + (Math.random() - 0.5) * 50;

          const ball = window.gameEngine.gameState.ball;
          ball.x = ballX;
          ball.y = ballY;
          ball.velocityX = 0;
          ball.velocityY = 0;
          ball.isMoving = false;
          ball.lastSafePosition = { x: ballX, y: ballY };
          ball.distanceFromHole = PhysicsEngine.distance(
            { x: ballX, y: ballY }, hole.holePosition
          );

          // Reset hole state so ball is visible
          ball.inHole = false;
          ball.holeProgress = undefined;
          delete ball.holeStartTime;

          // Update selected club for the distance
          window.gameEngine.gameState.selectedClub = ClubSystem.getRecommendedClub(
            ball, hole.holePosition
          ) || 'iron7';

          this.showMessage('ðŸŽ¯ Closest to Pin', 'Get as close to the hole as you can!', 2000);
        }
      },

      setupLongestDrive() {
        if (window.gameEngine && window.gameEngine.gameState) {
          const hole = window.gameEngine.gameState.currentHole;

          // Use tee position from generated hole
          const ballX = hole.teePosition.x;
          const ballY = hole.teePosition.y;

          const ball = window.gameEngine.gameState.ball;
          ball.x = ballX;
          ball.y = ballY;
          ball.velocityX = 0;
          ball.velocityY = 0;
          ball.isMoving = false;
          ball.lastSafePosition = { x: ballX, y: ballY };
          ball.distanceFromHole = PhysicsEngine.distance(
            { x: ballX, y: ballY }, hole.holePosition
          );

          // Reset hole state so ball is visible
          ball.inHole = false;
          ball.holeProgress = undefined;
          delete ball.holeStartTime;

          // Use driver for longest drive
          window.gameEngine.gameState.selectedClub = 'driver';

          this.showMessage('ðŸ’ª Longest Drive', `Attempt ${4 - this.attempts} of 3 - Hit it far!`, 2000);
        }
      },

      setupPuttingChallenge() {
        if (window.gameEngine && window.gameEngine.gameState) {
          // Initialize putting challenge state
          this.puttingState = {
            currentPutt: 0,
            totalPutts: 10,
            sunkCount: 0,
            teePositions: [] // Pre-generated positions for the day
          };

          // Hide regular scoreboard for mini-game
          document.getElementById('scoreboard').classList.add('hidden');

          // Create the putting green and generate tee positions
          this.createPuttingGreen();

          // Start first putt
          this.setupNextPutt();

          this.showMessage('â›³ Putting Challenge', `Sink as many as you can! Putt 1 of ${this.puttingState.totalPutts}`, 2000);
        }
      },

      createPuttingGreen() {
        const canvas = document.getElementById('game-canvas');
        // Use CSS display dimensions (getBoundingClientRect), NOT canvas.width which is DPR-scaled
        // The rendering context is scaled by devicePixelRatio, so all coordinates should be in CSS display space
        const rect = canvas.getBoundingClientRect();
        const canvasW = rect.width || 800;
        const canvasH = rect.height || 600;
        const centerX = canvasW / 2;
        const centerY = canvasH / 2;

        // Hole position (centered)
        const holeX = centerX;
        const holeY = centerY;

        // Generate obstacles around the hole (but not blocking direct paths)
        const obstacles = this.generatePuttingObstacles(holeX, holeY, { width: canvasW, height: canvasH });

        // Generate 10 preset tee positions at visually good distances
        // Use screen-relative distances that look and play well
        this.puttingState.teePositions = [];
        const minScreenDist = Math.min(canvasW, canvasH) * 0.15; // 15% of smaller dimension
        const maxScreenDist = Math.min(canvasW, canvasH) * 0.4;  // 40% of smaller dimension

        for (let i = 0; i < 10; i++) {
          const angle = this.seededRandom() * Math.PI * 2;
          const distance = minScreenDist + this.seededRandom() * (maxScreenDist - minScreenDist);

          let ballX = holeX + Math.cos(angle) * distance;
          let ballY = holeY + Math.sin(angle) * distance;

          // Keep within bounds with good margin
          const margin = 60;
          ballX = Math.max(margin, Math.min(canvasW - margin, ballX));
          ballY = Math.max(margin, Math.min(canvasH - margin, ballY));

          this.puttingState.teePositions.push({ x: ballX, y: ballY });
        }

        // Create a pure putting green - entire screen is green
        const puttingHole = {
          holePosition: { x: holeX, y: holeY },
          teePosition: this.puttingState.teePositions[0],
          par: 1,
          greenPosition: { x: centerX, y: centerY },
          greenRadius: Math.max(canvasW, canvasH) * 2, // Cover way beyond screen
          // No fairway path - pure green
          fairwayPath: null,
          fairwayWidth: 0,
          obstacles: obstacles,
          bunkers: [],
          water: [],
          trees: [],
          isPuttingGreen: true,
          isMinigamePuttingGreen: true
        };

        window.gameEngine.gameState.currentHole = puttingHole;
        window.gameEngine.currentHole = puttingHole;
      },

      generatePuttingObstacles(holeX, holeY, rect) {
        const obstacles = [];
        const numObstacles = 3 + Math.floor(this.seededRandom() * 3); // 3-5 obstacles
        const screenMin = Math.min(rect.width, rect.height);

        for (let i = 0; i < numObstacles; i++) {
          const angle = this.seededRandom() * Math.PI * 2;
          // Place obstacles at 20-45% of screen size from hole
          const distance = screenMin * (0.2 + this.seededRandom() * 0.25);

          const obsX = holeX + Math.cos(angle) * distance;
          const obsY = holeY + Math.sin(angle) * distance;

          // Keep within bounds
          const margin = 80;
          if (obsX < margin || obsX > rect.width - margin || obsY < margin || obsY > rect.height - margin) {
            continue;
          }

          // Screen-relative rock sizes (2-4% of screen)
          const rockRadius = screenMin * (0.02 + this.seededRandom() * 0.02);
          obstacles.push({
            type: 'rock',
            x: obsX,
            y: obsY,
            radius: rockRadius,
            width: 0,
            height: 0,
            shape: 'circle'
          });
        }

        return obstacles;
      },

      setupNextPutt() {
        if (!window.gameEngine || !window.gameEngine.gameState) return;

        const state = this.puttingState;
        if (!state || !state.teePositions || state.currentPutt >= state.teePositions.length) return;

        const hole = window.gameEngine.gameState.currentHole;
        if (!hole) return;

        const teePos = state.teePositions[state.currentPutt];
        if (!teePos) return;

        // Get current ball color
        const ballColor = window.gameEngine.gameState.ball?.color || 'white';

        // Create a completely fresh ball at the new tee position
        const newBall = {
          x: teePos.x,
          y: teePos.y,
          velocityX: 0,
          velocityY: 0,
          spin: 0,
          isAirborne: false,
          isMoving: false,
          rotation: 0,
          groundY: teePos.y,
          holePosition: hole.holePosition,
          distanceFromHole: PhysicsEngine.distance(teePos, hole.holePosition),
          lastSafePosition: { x: teePos.x, y: teePos.y },
          waterPenalty: false,
          color: ballColor,
          // Explicitly ensure hole state is clear - use undefined to skip fade check entirely
          inHole: false,
          holeProgress: undefined
        };

        // Replace the ball entirely
        window.gameEngine.gameState.ball = newBall;

        // Reset holeCompleting flag - this gets set to true when ball sinks in mini-game
        // but needs to be reset for the next putt to work properly
        window.gameEngine.holeCompleting = false;

        // Reset round state for fresh putt
        if (window.gameEngine.gameState.round) {
          window.gameEngine.gameState.round.isComplete = false;
          window.gameEngine.gameState.round.currentStrokeCount = 0;
        }

        // Force putter only - lock club selection
        window.gameEngine.gameState.selectedClub = 'putter';
        window.gameEngine.gameState.puttingMiniGame = true; // Flag to lock club

        // Update HUD
        this.updatePuttingHUD();
      },

      updatePuttingHUD() {
        const state = this.puttingState;
        const hud = document.getElementById('minigame-hud');
        hud.classList.remove('hidden');

        // Calculate distance as approximate power needed (putter-friendly scale)
        const ball = window.gameEngine.gameState.ball;
        const hole = window.gameEngine.gameState.currentHole;
        const distPixels = PhysicsEngine.distance(ball, hole.holePosition);
        // Scale distance to feel right: ~150px = short putt, ~300px = medium, ~450px = long
        // Show as percentage of "max putt" to help player gauge power
        const powerNeeded = Math.min(100, Math.round((distPixels / 300) * 50));

        // Repurpose the HUD for putting
        document.getElementById('minigame-timer').textContent = `${state.currentPutt + 1}/${state.totalPutts}`;
        document.getElementById('minigame-score').textContent = `${state.sunkCount} | ~${powerNeeded}%`;

        // Update labels
        const timerLabel = hud.querySelector('.minigame-hud-item:first-child .minigame-hud-label');
        const scoreLabel = hud.querySelector('.minigame-hud-item:last-child .minigame-hud-label');
        if (timerLabel) timerLabel.textContent = 'Putt';
        if (scoreLabel) scoreLabel.textContent = 'Sunk | Power';
      },

      showMessage(title, msg, duration) {
        const popup = document.createElement('div');
        popup.className = 'ufo-popup';
        popup.style.background = 'linear-gradient(135deg, #1a1a2e, #16213e)';
        popup.style.color = '#FFD700';
        popup.innerHTML = `<span style="font-size: 32px;">${title.split(' ')[0]}</span><br><span style="color: #fff; font-size: 16px;">${msg}</span>`;
        document.body.appendChild(popup);
        setTimeout(() => popup.classList.add('show'), 10);
        setTimeout(() => {
          popup.classList.remove('show');
          setTimeout(() => popup.remove(), 500);
        }, duration);
      },

      // Called when ball stops after a shot
      onShotComplete(ball, hole) {
        if (!this.isActive) return;

        if (this.currentGame === 'closestToPin') {
          // Prevent further shots immediately - this is a single-shot game
          this.isActive = false;

          // Check if ball went in the hole (hole-in-one!)
          if (ball.inHole) {
            this.score = 0;
            this.showMessage('ðŸŽ‰ HOLE IN ONE!', 'You sunk it! 0 feet from the hole!', 2500);
            AudioManager.playCrowdClap && AudioManager.playCrowdClap();
            // Reset ball state for clean game end
            ball.inHole = false;
            ball.holeProgress = undefined;
            delete ball.holeStartTime;
            setTimeout(() => this.endGame(), 3000);
          } else {
            const dx = ball.x - hole.holePosition.x;
            const dy = ball.y - hole.holePosition.y;
            const distancePixels = Math.sqrt(dx * dx + dy * dy);
            const distanceFeet = Math.round(distancePixels / 3); // ~3 pixels per foot

            this.score = distanceFeet;
            this.showMessage('ðŸŽ¯ Result', `${distanceFeet} feet from the hole!`, 2000);
            setTimeout(() => this.endGame(), 2500);
          }

        } else if (this.currentGame === 'longestDrive') {
          const dx = ball.x - hole.teePosition.x;
          const distanceYards = Math.round(dx * PIXELS_TO_YARDS);

          // Check if ball went backwards or didn't really go forward (out of bounds)
          if (distanceYards <= 0) {
            // Ball went backwards or didn't move forward - doesn't count, give attempt back
            this.showMessage('âš ï¸ Out of Bounds!', 'Ball went backwards - try again!', 1500);
            setTimeout(() => this.setupLongestDrive(), 2000);
            return; // Don't decrement attempts
          }

          if (distanceYards > this.bestAttempt) {
            this.bestAttempt = distanceYards;
          }

          this.attempts--;
          if (this.attempts > 0) {
            this.showMessage('ðŸ’ª Drive', `${distanceYards} yards! ${this.attempts} attempts left.`, 1500);
            setTimeout(() => this.setupLongestDrive(), 2000);
          } else {
            this.score = this.bestAttempt;
            this.showMessage('ðŸ’ª Final', `Best drive: ${this.bestAttempt} yards!`, 2000);
            setTimeout(() => this.endGame(), 2500);
          }

        } else if (this.currentGame === 'puttingChallenge') {
          const state = this.puttingState;
          if (!state) return;

          // Check if ball went in hole (sound already played by update loop)
          const madeIt = ball.inHole;
          if (madeIt) {
            state.sunkCount++;
            this.score = state.sunkCount;
          }

          // Move to next putt
          state.currentPutt++;

          if (state.currentPutt >= state.totalPutts) {
            // All putts done - end game
            const msg = state.sunkCount === state.totalPutts ? 'ðŸŽ‰ Perfect!' :
                       state.sunkCount >= 7 ? 'ðŸ‘ Great putting!' :
                       state.sunkCount >= 5 ? 'ðŸ‘ Nice job!' : 'Keep practicing!';
            this.showMessage('â›³ Complete', `${state.sunkCount}/${state.totalPutts} sunk! ${msg}`, 2000);
            setTimeout(() => this.endGame(), 2500);
          } else if (state.currentPutt < state.teePositions.length) {
            // Next putt - verify tee position exists
            const result = madeIt ? 'âœ“ Sunk!' : 'âœ— Miss';
            this.showMessage(result, `Putt ${state.currentPutt + 1} of ${state.totalPutts}`, 1000);
            setTimeout(() => this.setupNextPutt(), 1200);
          }
        }
      },

      // Handle out of bounds for minigames - gives the attempt back
      handleOutOfBounds() {
        if (!this.isActive) return;

        const ball = window.gameEngine.gameState.ball;
        const hole = window.gameEngine.gameState.currentHole;
        const canvas = window.gameEngine.canvas;
        const canvasRect = canvas.getBoundingClientRect();

        // Determine which boundary was crossed for a specific message
        let boundaryMsg = 'Ball left the playing area';
        if (ball.x < 0) {
          boundaryMsg = 'Ball went off the left side';
        } else if (ball.x > canvasRect.width) {
          boundaryMsg = 'Ball went off the right side';
        } else if (ball.y < 0) {
          boundaryMsg = 'Ball went off the top';
        } else if (ball.y > canvasRect.height) {
          boundaryMsg = 'Ball went off the bottom';
        }

        // For longest drive, check if ball went backwards
        if (this.currentGame === 'longestDrive' && hole && hole.teePosition) {
          if (ball.x < hole.teePosition.x) {
            boundaryMsg = 'Ball went backwards';
          }
        }

        // Show out of bounds message with specific boundary info
        this.showMessage('âš ï¸ Out of Bounds!', `${boundaryMsg} - try again!`, 1500);

        // Reset ball to last safe position (the starting position for current attempt)
        if (ball.lastSafePosition) {
          ball.x = ball.lastSafePosition.x;
          ball.y = ball.lastSafePosition.y;
        } else if (hole && hole.teePosition) {
          ball.x = hole.teePosition.x;
          ball.y = hole.teePosition.y;
        }

        ball.velocityX = 0;
        ball.velocityY = 0;
        ball.isMoving = false;
        ball.isAirborne = false;

        // Reset hole state in case ball was heading into hole
        ball.inHole = false;
        ball.holeProgress = undefined;
        delete ball.holeStartTime;

        // Clear hole completing flag to allow next shot
        window.gameEngine.holeCompleting = false;

        // Game-specific handling to give attempt back
        if (this.currentGame === 'longestDrive') {
          // Reset for next attempt
          setTimeout(() => this.setupLongestDrive(), 2000);
        } else if (this.currentGame === 'puttingChallenge') {
          // Reset for same putt attempt (don't advance counter)
          // The putt counter is incremented in onShotComplete, which won't be called for OOB
        } else if (this.currentGame === 'closestToPin') {
          // For closest to pin, reset to allow another shot
          // This is a single-shot game, but if they hit OOB they should get another try
          this.isActive = true; // Re-enable in case it was disabled
        }
      },

      // Medal thresholds for each game
      getMedal(gameKey, score) {
        const thresholds = {
          closestToPin: { gold: 5, silver: 15, bronze: Infinity }, // lower is better (feet)
          longestDrive: { gold: 300, silver: 250, bronze: 0 }, // higher is better (yards)
          puttingChallenge: { gold: 10, silver: 7, bronze: 0 } // higher is better (sunk)
        };

        const t = thresholds[gameKey];
        const game = this.games[gameKey];

        if (game.lowerIsBetter) {
          if (score <= t.gold) return { type: 'gold', icon: 'ðŸ¥‡', name: 'Gold' };
          if (score <= t.silver) return { type: 'silver', icon: 'ðŸ¥ˆ', name: 'Silver' };
          return { type: 'bronze', icon: 'ðŸ¥‰', name: 'Bronze' };
        } else {
          if (score >= t.gold) return { type: 'gold', icon: 'ðŸ¥‡', name: 'Gold' };
          if (score >= t.silver) return { type: 'silver', icon: 'ðŸ¥ˆ', name: 'Silver' };
          return { type: 'bronze', icon: 'ðŸ¥‰', name: 'Bronze' };
        }
      },

      getMedalReward(medalType) {
        const rewards = { gold: 150, silver: 100, bronze: 50 };
        return rewards[medalType] || 50;
      },

      endGame() {
        this.isActive = false;
        clearInterval(this.timerInterval);

        document.getElementById('minigame-hud').classList.add('hidden');

        const game = this.games[this.currentGame];
        const oldHighScore = this.highScores[this.currentGame];
        let isNewRecord = false;

        if (oldHighScore === undefined) {
          isNewRecord = true;
        } else if (game.lowerIsBetter) {
          isNewRecord = this.score < oldHighScore;
        } else {
          isNewRecord = this.score > oldHighScore;
        }

        if (isNewRecord) {
          this.highScores[this.currentGame] = this.score;
          this.save();
        }

        // Mark today's challenge as completed (one attempt per day)
        this.markCompleted();

        // Calculate medal and reward
        const medal = this.getMedal(this.currentGame, this.score);
        const baseReward = this.getMedalReward(medal.type);
        const reward = isNewRecord ? baseReward + 50 : baseReward; // Bonus 50 for new record
        ShopSystem.addBucks(reward, 'Mini-Game Reward');

        // Show results
        const overlay = document.getElementById('minigame-overlay');
        const content = document.getElementById('minigame-content');
        const gameKey = this.currentGame;

        content.innerHTML = `
          <div class="minigame-result">
            <h3>${game.icon} ${game.name}</h3>
            <div style="font-size: 64px; margin: 10px 0;">${medal.icon}</div>
            <div style="font-size: 24px; color: ${medal.type === 'gold' ? '#FFD700' : medal.type === 'silver' ? '#C0C0C0' : '#CD7F32'}; font-weight: bold; margin-bottom: 10px;">${medal.name} Medal</div>
            <div class="final-score">${this.score}${game.scoreUnit}</div>
            <div class="high-score">${isNewRecord ? 'ðŸŽ‰ NEW RECORD!' : `Best: ${this.highScores[this.currentGame]}${game.scoreUnit}`}</div>
            <div class="reward" style="font-size: 20px; color: #4CAF50; margin: 15px 0;">+${reward} Golf Bucks${isNewRecord ? ' (includes record bonus!)' : ''}</div>
            <div style="color: rgba(255,255,255,0.6); font-size: 14px; margin-top: 10px;">Returning to lobby in <span id="minigame-countdown">4</span>s...</div>
          </div>
        `;

        overlay.classList.remove('hidden');

        // Show scoreboard again
        document.getElementById('scoreboard').classList.remove('hidden');

        // Auto-return to lobby after countdown
        let countdown = 4;
        const countdownEl = document.getElementById('minigame-countdown');
        const countdownInterval = setInterval(() => {
          countdown--;
          if (countdownEl) countdownEl.textContent = countdown;
          if (countdown <= 0) {
            clearInterval(countdownInterval);
            this.returnToLobby();
          }
        }, 1000);

        // Allow clicking anywhere on the overlay to return immediately
        const clickHandler = () => {
          clearInterval(countdownInterval);
          overlay.removeEventListener('click', clickHandler);
          this.returnToLobby();
        };
        overlay.addEventListener('click', clickHandler);

        // Add to mailbox
        MailboxManager.addNotification(
          'achievement',
          `${medal.icon} ${game.name} - ${medal.name}`,
          `Score: ${this.score}${game.scoreUnit}${isNewRecord ? ' (New Record!)' : ''} - Earned ${reward} GB`
        );
      },

      returnToLobby() {
        const overlay = document.getElementById('minigame-overlay');
        overlay.classList.add('hidden');
        this.currentGame = null;
        this.puttingState = null;

        // Return to main menu
        document.getElementById('game-mode-overlay').classList.add('hidden');
        document.getElementById('menu-overlay').classList.remove('hidden');

        // Clear mini-game state
        if (window.gameEngine && window.gameEngine.gameState) {
          window.gameEngine.gameState.isMiniGame = false;
          window.gameEngine.gameState.puttingMiniGame = false;
          window.gameEngine.gameState = null;
        }
        window.gameEngine.holeCompleting = false;
      }
    };

    // === RandomEventManager Module (T108-T115: Random Events & Humor) ===
    const RandomEventManager = {
      activeEvent: null,
      cooldownTimer: 0,
      minCooldown: 8,
      triggerChance: 0.25,

      // Ball interaction state for UFO pickup
      ballInteraction: {
        active: false,
        targetBall: null,
        originalPosition: { x: 0, y: 0 },
        dropPosition: { x: 0, y: 0 },
        phase: 'none', // 'lifting' | 'carrying' | 'dropping'
        progress: 0
      },

      // Event types with their configs
      eventTypes: ['streaker', 'golfCart', 'ufo', 'squirrel'],

      configs: {
        streaker: { speed: 600, size: 40, color: '#FFD6B3', warning: 'STREAKER INCOMING!' },
        golfCart: { speed: 450, size: 60, color: '#FFFFFF', warning: 'RUNAWAY GOLF CART!' },
        ufo: { speed: 200, size: 50, color: '#88FF88', warning: 'ðŸ‘½ UFO SIGHTING!' },
        squirrel: { speed: 800, size: 25, color: '#8B4513', warning: 'SQUIRREL ATTACK!' }
      },

      reset() {
        this.activeEvent = null;
        this.cooldownTimer = 0;
        this.ballInteraction = {
          active: false, targetBall: null, originalPosition: { x: 0, y: 0 },
          dropPosition: { x: 0, y: 0 }, phase: 'none', progress: 0
        };
      },

      checkTrigger() {
        if (this.cooldownTimer > 0) return false;
        if (this.activeEvent) return false;

        if (Math.random() < this.triggerChance) {
          // Pick random event type
          const eventType = this.eventTypes[Math.floor(Math.random() * this.eventTypes.length)];
          this.spawnEvent(eventType);
          return true;
        }
        return false;
      },

      spawnEvent(type) {
        const canvas = document.getElementById('game-canvas');
        // Use visual dimensions, not scaled pixel dimensions
        const rect = canvas.getBoundingClientRect();
        const height = rect.height;
        const width = rect.width;
        const config = this.configs[type];

        const goingRight = Math.random() > 0.5;
        let yPos = height * 0.5;

        // UFO flies higher, squirrel lower
        if (type === 'ufo') yPos = height * 0.25;
        if (type === 'squirrel') yPos = height * 0.7;

        this.activeEvent = {
          type: type,
          x: goingRight ? -80 : width + 80,
          y: yPos,
          targetX: goingRight ? width + 80 : -80,
          direction: goingRight ? 1 : -1,
          animationPhase: 0,
          trail: [],
          warningTimer: 1.0,
          started: false,
          config: config
        };

        this.cooldownTimer = this.minCooldown + Math.random() * 10;
      },

      update(deltaTime) {
        if (this.cooldownTimer > 0) {
          this.cooldownTimer -= deltaTime;
        }

        // Update ball interaction (UFO pickup)
        this.updateBallInteraction(deltaTime);

        if (this.activeEvent) {
          const e = this.activeEvent;

          // Warning phase
          if (e.warningTimer > 0) {
            e.warningTimer -= deltaTime;
            if (e.warningTimer <= 0) {
              e.started = true;
              if (e.type === 'streaker') AudioManager.playStreakerSound();
            }
            return;
          }

          // Move event
          e.x += e.config.speed * e.direction * deltaTime;
          e.animationPhase += deltaTime * 15;

          // Trail
          e.trail.push({ x: e.x, y: e.y, alpha: 1 });
          if (e.trail.length > 8) e.trail.shift();
          for (const t of e.trail) t.alpha *= 0.85;

          // Check exit
          if ((e.direction > 0 && e.x > e.targetX) ||
              (e.direction < 0 && e.x < e.targetX)) {
            this.activeEvent = null;
          }
        }
      },

      // Check if UFO should pick up the ball
      checkBallCollision(ball, courseWidth, courseHeight) {
        if (!this.activeEvent || !this.activeEvent.started) return false;
        if (this.ballInteraction.active) return false;
        if (ball.isMoving) return false; // Only interact with stationary ball
        if (this.activeEvent.type !== 'ufo') return false;

        const e = this.activeEvent;
        const dist = Math.sqrt(Math.pow(e.x - ball.x, 2) + Math.pow(e.y - ball.y, 2));

        // UFO picks up ball when it passes near it
        if (dist < 80) {
          return this.startUFOPickup(ball, courseWidth, courseHeight);
        }
        return false;
      },

      // Start UFO ball pickup sequence
      startUFOPickup(ball, courseWidth, courseHeight) {
        // Calculate random drop position on course
        const margin = 100;
        const dropX = margin + Math.random() * (courseWidth - margin * 2);
        const dropY = courseHeight * 0.3 + Math.random() * (courseHeight * 0.4);

        this.ballInteraction = {
          active: true,
          targetBall: ball,
          originalPosition: { x: ball.x, y: ball.y },
          dropPosition: { x: dropX, y: dropY },
          phase: 'lifting',
          progress: 0
        };

        // Play sound
        if (AudioManager.playAchievement) AudioManager.playAchievement();
        return true;
      },

      // Update ball during UFO interaction
      updateBallInteraction(deltaTime) {
        if (!this.ballInteraction.active) return;

        const bi = this.ballInteraction;
        bi.progress += deltaTime * 1.5; // Speed of animation

        if (bi.phase === 'lifting') {
          // Move ball up toward UFO
          const t = Math.min(bi.progress, 1);
          bi.targetBall.x = bi.originalPosition.x;
          bi.targetBall.y = bi.originalPosition.y - t * 60;

          if (bi.progress >= 1) {
            bi.phase = 'carrying';
            bi.progress = 0;
          }
        } else if (bi.phase === 'carrying') {
          // Ball follows UFO
          if (this.activeEvent) {
            bi.targetBall.x = this.activeEvent.x;
            bi.targetBall.y = this.activeEvent.y + 35;
          }

          // Drop at the random position when UFO passes over it
          if (this.activeEvent && Math.abs(this.activeEvent.x - bi.dropPosition.x) < 40) {
            bi.phase = 'dropping';
            bi.progress = 0;
          }

          // Also drop if UFO is about to exit
          if (!this.activeEvent) {
            bi.phase = 'dropping';
            bi.progress = 0;
          }
        } else if (bi.phase === 'dropping') {
          // Drop ball at drop position
          const t = Math.min(bi.progress, 1);
          const startY = this.activeEvent ? this.activeEvent.y + 35 : bi.targetBall.y;
          bi.targetBall.x = bi.dropPosition.x;
          bi.targetBall.y = startY + (bi.dropPosition.y - startY) * t;

          if (bi.progress >= 1) {
            bi.targetBall.x = bi.dropPosition.x;
            bi.targetBall.y = bi.dropPosition.y;
            bi.targetBall.lastSafePosition = { x: bi.dropPosition.x, y: bi.dropPosition.y };
            bi.targetBall.velocityX = 0;
            bi.targetBall.velocityY = 0;

            this.ballInteraction.active = false;
            this.ballInteraction.phase = 'none';

            // Show UFO popup
            this.showUFODropPopup();
          }
        }
      },

      showUFODropPopup() {
        const popup = document.createElement('div');
        popup.className = 'ufo-popup';
        popup.innerHTML = `<span style="font-size: 28px;">ðŸ‘½</span><br>UFO relocated your ball!`;
        document.body.appendChild(popup);
        setTimeout(() => popup.classList.add('show'), 10);
        setTimeout(() => {
          popup.classList.remove('show');
          setTimeout(() => popup.remove(), 500);
        }, 2500);

      },

      draw(ctx) {
        if (!this.activeEvent) return;

        const e = this.activeEvent;
        const canvas = ctx.canvas;
        // Use visual dimensions for positioning
        const rect = canvas.getBoundingClientRect();
        const centerX = rect.width / 2;
        const centerY = rect.height / 2;

        // Warning phase
        if (e.warningTimer > 0) {
          ctx.save();
          const pulse = 1 + Math.sin(e.warningTimer * 15) * 0.1;
          ctx.font = `bold ${50 * pulse}px Arial`;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
          ctx.fillText(e.config.warning, centerX + 3, centerY + 3);
          ctx.fillStyle = '#FF4444';
          ctx.fillText(e.config.warning, centerX, centerY);
          ctx.strokeStyle = '#FFFFFF';
          ctx.lineWidth = 2;
          ctx.strokeText(e.config.warning, centerX, centerY);
          ctx.restore();
          return;
        }

        // Draw trail
        for (const t of e.trail) {
          ctx.save();
          ctx.globalAlpha = t.alpha * 0.4;
          ctx.fillStyle = e.config.color;
          ctx.beginPath();
          ctx.arc(t.x, t.y, e.config.size * 0.3, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        }

        ctx.save();
        const bob = Math.sin(e.animationPhase) * 5;
        ctx.translate(e.x, e.y + (e.type !== 'ufo' ? bob : 0));
        if (e.direction < 0) ctx.scale(-1, 1);

        // Draw based on type
        if (e.type === 'streaker') {
          this.drawStreaker(ctx, e);
        } else if (e.type === 'golfCart') {
          this.drawGolfCart(ctx, e);
        } else if (e.type === 'ufo') {
          this.drawUFO(ctx, e);
        } else if (e.type === 'squirrel') {
          this.drawSquirrel(ctx, e);
        }

        ctx.restore();
      },

      drawStreaker(ctx, e) {
        const size = e.config.size;
        const color = e.config.color;
        const armSwing = Math.sin(e.animationPhase) * 0.5;
        const legSwing = Math.sin(e.animationPhase + Math.PI) * 0.4;

        // Body
        ctx.fillStyle = color;
        ctx.strokeStyle = '#CC9966';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.ellipse(0, 0, size * 0.25, size * 0.4, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();

        // Head
        ctx.beginPath();
        ctx.arc(0, -size * 0.55, size * 0.2, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();

        // Arms & legs
        ctx.lineWidth = 6;
        ctx.lineCap = 'round';
        ctx.strokeStyle = color;

        ctx.save();
        ctx.rotate(armSwing - 0.3);
        ctx.beginPath();
        ctx.moveTo(0, -size * 0.2);
        ctx.lineTo(-size * 0.35, size * 0.1);
        ctx.stroke();
        ctx.restore();

        ctx.save();
        ctx.rotate(-armSwing + 0.3);
        ctx.beginPath();
        ctx.moveTo(0, -size * 0.2);
        ctx.lineTo(size * 0.35, size * 0.1);
        ctx.stroke();
        ctx.restore();

        ctx.save();
        ctx.rotate(legSwing);
        ctx.beginPath();
        ctx.moveTo(0, size * 0.25);
        ctx.lineTo(-size * 0.15, size * 0.6);
        ctx.stroke();
        ctx.restore();

        ctx.save();
        ctx.rotate(-legSwing);
        ctx.beginPath();
        ctx.moveTo(0, size * 0.25);
        ctx.lineTo(size * 0.15, size * 0.6);
        ctx.stroke();
        ctx.restore();

        // Wild hair
        ctx.strokeStyle = '#8B4513';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(-size * 0.1, -size * 0.7);
        ctx.lineTo(-size * 0.2, -size * 0.85);
        ctx.moveTo(0, -size * 0.75);
        ctx.lineTo(0, -size * 0.9);
        ctx.stroke();
      },

      drawGolfCart(ctx, e) {
        const size = e.config.size;

        // Cart body
        ctx.fillStyle = '#FFFFFF';
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 2;

        // Main body
        ctx.fillRect(-size * 0.5, -size * 0.3, size, size * 0.5);
        ctx.strokeRect(-size * 0.5, -size * 0.3, size, size * 0.5);

        // Roof
        ctx.fillStyle = '#4CAF50';
        ctx.fillRect(-size * 0.45, -size * 0.6, size * 0.9, size * 0.3);

        // Wheels (spinning)
        ctx.fillStyle = '#333';
        const wheelSpin = e.animationPhase * 2;
        [-size * 0.35, size * 0.35].forEach(wx => {
          ctx.beginPath();
          ctx.arc(wx, size * 0.2, size * 0.15, 0, Math.PI * 2);
          ctx.fill();
          // Spokes
          ctx.strokeStyle = '#666';
          ctx.lineWidth = 2;
          for (let i = 0; i < 4; i++) {
            const angle = wheelSpin + i * Math.PI / 2;
            ctx.beginPath();
            ctx.moveTo(wx, size * 0.2);
            ctx.lineTo(wx + Math.cos(angle) * size * 0.12, size * 0.2 + Math.sin(angle) * size * 0.12);
            ctx.stroke();
          }
        });

        // Driver (panicked)
        ctx.fillStyle = '#FFD6B3';
        ctx.beginPath();
        ctx.arc(0, -size * 0.15, size * 0.15, 0, Math.PI * 2);
        ctx.fill();

        // Panicked expression
        ctx.fillStyle = '#000';
        ctx.beginPath();
        ctx.arc(-size * 0.05, -size * 0.18, 3, 0, Math.PI * 2);
        ctx.arc(size * 0.05, -size * 0.18, 3, 0, Math.PI * 2);
        ctx.fill();

        // Open mouth (screaming)
        ctx.beginPath();
        ctx.ellipse(0, -size * 0.08, 5, 8, 0, 0, Math.PI * 2);
        ctx.fill();
      },

      drawUFO(ctx, e) {
        const size = e.config.size;
        const hover = Math.sin(e.animationPhase * 0.5) * 3;

        ctx.translate(0, hover);

        // Beam
        ctx.fillStyle = 'rgba(136, 255, 136, 0.2)';
        ctx.beginPath();
        ctx.moveTo(-size * 0.2, size * 0.2);
        ctx.lineTo(size * 0.2, size * 0.2);
        ctx.lineTo(size * 0.5, size * 1.2);
        ctx.lineTo(-size * 0.5, size * 1.2);
        ctx.closePath();
        ctx.fill();

        // Saucer bottom
        ctx.fillStyle = '#666';
        ctx.beginPath();
        ctx.ellipse(0, size * 0.1, size * 0.6, size * 0.15, 0, 0, Math.PI * 2);
        ctx.fill();

        // Saucer top
        ctx.fillStyle = '#88FF88';
        ctx.beginPath();
        ctx.ellipse(0, 0, size * 0.5, size * 0.25, 0, 0, Math.PI * 2);
        ctx.fill();

        // Dome
        ctx.fillStyle = 'rgba(150, 255, 150, 0.7)';
        ctx.beginPath();
        ctx.arc(0, -size * 0.1, size * 0.25, Math.PI, 0);
        ctx.fill();

        // Lights (blinking)
        const blink = Math.sin(e.animationPhase * 3) > 0;
        ctx.fillStyle = blink ? '#FF0' : '#F80';
        [-size * 0.35, 0, size * 0.35].forEach(lx => {
          ctx.beginPath();
          ctx.arc(lx, size * 0.05, 4, 0, Math.PI * 2);
          ctx.fill();
        });

        // Alien eyes
        ctx.fillStyle = '#000';
        ctx.beginPath();
        ctx.ellipse(-size * 0.08, -size * 0.15, 4, 6, 0, 0, Math.PI * 2);
        ctx.ellipse(size * 0.08, -size * 0.15, 4, 6, 0, 0, Math.PI * 2);
        ctx.fill();
      },

      drawSquirrel(ctx, e) {
        const size = e.config.size;
        const legMove = Math.sin(e.animationPhase * 2) * 0.3;

        // Body
        ctx.fillStyle = e.config.color;
        ctx.beginPath();
        ctx.ellipse(0, 0, size * 0.4, size * 0.25, 0, 0, Math.PI * 2);
        ctx.fill();

        // Head
        ctx.beginPath();
        ctx.arc(size * 0.35, -size * 0.1, size * 0.2, 0, Math.PI * 2);
        ctx.fill();

        // Ears
        ctx.beginPath();
        ctx.arc(size * 0.3, -size * 0.3, size * 0.08, 0, Math.PI * 2);
        ctx.arc(size * 0.45, -size * 0.28, size * 0.08, 0, Math.PI * 2);
        ctx.fill();

        // Fluffy tail
        ctx.beginPath();
        ctx.arc(-size * 0.5, -size * 0.3, size * 0.3, 0, Math.PI * 2);
        ctx.fill();

        // Eye
        ctx.fillStyle = '#000';
        ctx.beginPath();
        ctx.arc(size * 0.42, -size * 0.12, 3, 0, Math.PI * 2);
        ctx.fill();

        // Legs (running fast!)
        ctx.strokeStyle = e.config.color;
        ctx.lineWidth = 4;
        ctx.lineCap = 'round';

        // Front legs
        ctx.save();
        ctx.rotate(legMove);
        ctx.beginPath();
        ctx.moveTo(size * 0.2, size * 0.15);
        ctx.lineTo(size * 0.25, size * 0.35);
        ctx.stroke();
        ctx.restore();

        // Back legs
        ctx.save();
        ctx.rotate(-legMove);
        ctx.beginPath();
        ctx.moveTo(-size * 0.2, size * 0.15);
        ctx.lineTo(-size * 0.25, size * 0.35);
        ctx.stroke();
        ctx.restore();

        // Acorn in mouth
        ctx.fillStyle = '#DEB887';
        ctx.beginPath();
        ctx.ellipse(size * 0.55, -size * 0.05, size * 0.1, size * 0.08, 0.3, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#8B4513';
        ctx.fillRect(size * 0.5, -size * 0.15, size * 0.08, size * 0.06);
      },

      isActive() {
        return this.activeEvent !== null;
      }
    };

    // === TutorialManager Module (T082-T089: Tutorial System) ===
    const TutorialManager = {
      steps: [
        {
          title: "Welcome to Howlett Golf Chaos!",
          text: "Let's learn by playing a practice hole! Tap 'Next' to begin.",
          highlight: null,
          action: null,
          waitForAction: false
        },
        {
          title: "Step 1: Choose Your Club",
          text: "The GLOWING club in your bag is recommended for the distance. On short holes like par 3s, use irons instead of driver! You can change clubs anytime.",
          highlight: 'club-selector',
          action: null,
          waitForAction: false
        },
        {
          title: "Step 2: The Tee Shot",
          text: "Now drag BACKWARD from the ball and release to shoot FORWARD! The longer you drag, the more power.",
          highlight: 'game-canvas',
          action: 'swing',
          waitForAction: true
        },
        {
          title: "Nice Shot!",
          text: "Great job! The ball moves opposite to your drag direction. Notice how the recommended club changed based on your new distance.",
          highlight: null,
          action: null,
          waitForAction: false
        },
        {
          title: "Watch the Wind!",
          text: "See the WIND indicator in the top-right? The arrow shows wind direction and speed. Strong winds will push your ball off course - aim to compensate!",
          highlight: 'wind-indicator',
          action: null,
          waitForAction: false
        },
        {
          title: "Step 3: Switch Clubs",
          text: "Tap a different club to select it. Driver hits farthest, Woods/Irons for mid-range, Wedge for short shots, Putter on the green.",
          highlight: 'club-selector',
          action: 'selectClub',
          waitForAction: true
        },
        {
          title: "Step 4: Sink the Ball!",
          text: "Keep hitting until you get the ball in the hole! Watch the distance display and switch clubs as needed.",
          highlight: null,
          action: 'holeComplete',
          waitForAction: true
        },
        {
          title: "Hole Complete!",
          text: "Awesome! Remember: Choose the right club for each shot based on distance. The glowing club is your best choice. Now you're ready for the real game!",
          highlight: null,
          action: null,
          waitForAction: false
        }
      ],

      currentStep: 0,
      isActive: false,
      gameEngine: null,
      waitingForAction: false,

      start(gameEngine) {
        this.gameEngine = gameEngine;
        this.currentStep = 0;
        this.isActive = true;
        this.waitingForAction = false;

        // Start a tutorial practice hole
        this.startPracticeHole();

        this.showStep();
        document.getElementById('tutorial-overlay').classList.remove('hidden');
      },

      startPracticeHole() {
        if (!this.gameEngine) return;

        const canvas = this.gameEngine.canvas;
        const canvasRect = canvas.getBoundingClientRect();

        // Use the real course generator to create a proper hole
        CourseGenerator.init(12345); // Fixed seed for consistent tutorial

        // Generate hole 1 (a short par 3) but clear obstacles for easier practice
        const practiceHole = CourseGenerator.generateHole(1, canvasRect.width, canvasRect.height);
        practiceHole.obstacles = []; // Remove obstacles for tutorial
        practiceHole.holeNumber = 0; // Mark as tutorial hole

        // Use the engine's createBall method for proper ball setup
        const ball = this.gameEngine.createBall(practiceHole, 'white');

        // Get recommended club for the tutorial hole distance
        const recommendedClub = ClubSystem.getRecommendedClub(ball, practiceHole.holePosition);
        // Default to driver if no caddie recommendation
        const defaultClub = recommendedClub || 'driver';

        this.gameEngine.gameState = {
          currentHole: practiceHole,
          round: {
            roundId: 'tutorial',
            startTime: Date.now(),
            endTime: null,
            currentHoleNumber: 0,
            isComplete: false,
            holeScores: [],
            totalStrokes: 0,
            totalPar: 0,
            scoreRelativeToPar: 0,
            currentStrokeCount: 0
          },
          ball: ball,
          selectedClub: defaultClub,
          seed: 12345,
          playerName: 'Student',
          isTutorial: true
        };

        this.gameEngine.updateUI();
        this.gameEngine.updateClubSelector();

        // Generate wind for tutorial (moderate wind so it's noticeable)
        WindSystem.generateWind(3); // Use hole 3 params for moderate wind

        // Hide menu, show game
        document.getElementById('menu-overlay').classList.add('hidden');
        document.getElementById('club-selector-container').style.display = 'block';
      },

      showStep() {
        const step = this.steps[this.currentStep];
        document.getElementById('tutorial-title').textContent = step.title;
        document.getElementById('tutorial-text').textContent = step.text;
        document.getElementById('tutorial-progress').textContent =
          `Step ${this.currentStep + 1} of ${this.steps.length}`;

        // Update button visibility based on whether we're waiting for action
        const nextBtn = document.getElementById('tutorial-next-btn');
        const skipBtn = document.getElementById('tutorial-skip-btn');

        if (step.waitForAction) {
          nextBtn.style.display = 'none';
          this.waitingForAction = true;
        } else {
          nextBtn.style.display = 'inline-block';
          nextBtn.textContent = this.currentStep === this.steps.length - 1 ? "Start Game!" : "Next";
          this.waitingForAction = false;
        }

        // Handle highlighting
        this.unhighlightAll();
        if (step.highlight) {
          this.highlightElement(step.highlight);
        }
      },

      // Called by game when player performs an action
      onAction(actionType) {
        if (!this.isActive || !this.waitingForAction) return;

        const step = this.steps[this.currentStep];
        if (step.action === actionType) {
          // Action completed! Move to next step
          setTimeout(() => {
            this.nextStep();
          }, actionType === 'holeComplete' ? 1500 : 500);
        }
      },

      // Check if ball is allowed to go in hole (only on the "Sink the Ball!" step)
      canBallEnterHole() {
        if (!this.isActive) return true; // Not in tutorial, allow
        // Step 6 (index 6) is "Sink the Ball!" step that waits for holeComplete
        return this.currentStep >= 6;
      },

      nextStep() {
        this.unhighlightAll();
        this.currentStep++;

        if (this.currentStep >= this.steps.length) {
          this.complete();
        } else {
          this.showStep();
        }
      },

      skip() {
        this.unhighlightAll();
        this.complete();
      },

      complete() {
        this.isActive = false;
        this.currentStep = 0;
        this.waitingForAction = false;
        document.getElementById('tutorial-overlay').classList.add('hidden');
        document.getElementById('tutorial-next-btn').style.display = 'inline-block';

        // Mark tutorial as completed
        const settings = StorageManager.loadSettings();
        settings.tutorialCompleted = true;
        StorageManager.saveSettings(settings);

        // Return to main menu - hide all game UI first, then show menu
        if (this.gameEngine) {
          // Hide all game UI elements
          document.getElementById('club-selector-container').style.display = 'none';
          document.getElementById('scoreboard').style.display = 'none';
          document.getElementById('ball-state').style.display = 'none';
          document.getElementById('wind-indicator').classList.add('hidden');
          document.getElementById('distance-display').classList.add('hidden');

          // Clear game state
          this.gameEngine.gameState = null;

          // Show menu after a brief delay to prevent flicker
          setTimeout(() => {
            document.getElementById('menu-overlay').classList.remove('hidden');
            // Restore UI element display for next game
            document.getElementById('scoreboard').style.display = '';
            document.getElementById('ball-state').style.display = '';
          }, 100);
        }
      },

      highlightElement(id) {
        const element = document.getElementById(id);
        if (element) {
          element.classList.add('tutorial-highlight');
        }
      },

      unhighlightAll() {
        document.querySelectorAll('.tutorial-highlight').forEach(el => {
          el.classList.remove('tutorial-highlight');
        });
      }
    };

    // === GameEngine Module (T007, T011, T013-T025) ===
    class GameEngine {
      constructor(canvas) {
        this.canvas = canvas;
        this.isRunning = false;
        this.isPaused = false;
        this.lastFrameTime = 0;
        this.fps = 60;
        this.debugMode = false;
        this.holeCompleting = false;
        this.animationTime = 0; // Global animation time for visual effects

        this.gameState = null;

        Renderer.init(canvas);
        InputHandler.init(canvas, this);

        this.checkDebugMode();
      }

      checkDebugMode() {
        const params = new URLSearchParams(window.location.search);
        this.debugMode = params.get('debug') === 'true';
        if (this.debugMode) {
          document.getElementById('debug-info').classList.remove('hidden');
        }
        // Debug: Add Golf Bucks via URL parameter (e.g., ?bucks=1000000)
        const bucks = parseInt(params.get('bucks'));
        if (bucks > 0 && !sessionStorage.getItem('bucks-added')) {
          ShopSystem.golfBucks += bucks;
          ShopSystem.save();
          ShopSystem.updateBalanceDisplay();
          sessionStorage.setItem('bucks-added', 'true');
          console.log(`Added ${bucks} Golf Bucks!`);
        }
      }

      start() {
        if (this.isRunning) {
          console.log('Game engine already running, skipping start');
          return;
        }
        console.log('Starting game engine');
        this.isRunning = true;
        this.lastFrameTime = performance.now();
        requestAnimationFrame((t) => this.update(t));
      }

      pause() {
        this.isPaused = true;
      }

      resume() {
        this.isPaused = false;
        this.lastFrameTime = performance.now();
      }

      // Check if ball is out of bounds
      isBallOutOfBounds(ball) {
        if (!ball) return false;
        const canvas = this.canvas;
        const rect = canvas.getBoundingClientRect();
        const margin = 100; // Extra margin before out of bounds

        return ball.x < -margin ||
               ball.x > rect.width + margin ||
               ball.y < -margin ||
               ball.y > rect.height + margin;
      }

      // Handle ball going out of bounds
      handleOutOfBounds() {
        const ball = this.gameState.ball;

        // Return to last safe position
        if (ball.lastSafePosition) {
          ball.x = ball.lastSafePosition.x;
          ball.y = ball.lastSafePosition.y;
        } else {
          // Fallback to tee position
          ball.x = this.gameState.currentHole.teePosition.x;
          ball.y = this.gameState.currentHole.teePosition.y;
        }

        ball.velocityX = 0;
        ball.velocityY = 0;
        ball.isMoving = false;
        ball.isAirborne = false;

        // Add 1-stroke penalty
        this.gameState.round.currentStrokeCount++;
        this.gameState.round.totalStrokes++;

        // Update score display
        this.updateScoreDisplay();

        // Show out-of-bounds popup
        const popup = document.createElement('div');
        popup.className = 'oob-popup';
        popup.innerHTML = `<span style="font-size: 28px;">âš ï¸</span><br>Out of Bounds!<br><small>+1 Stroke Penalty</small>`;
        document.body.appendChild(popup);
        setTimeout(() => popup.classList.add('show'), 10);
        setTimeout(() => {
          popup.classList.remove('show');
          setTimeout(() => popup.remove(), 500);
        }, 2500);

      }

      async startNewRound(seed = null, playerName = 'Player', ballColor = 'white', themeOverride = null) {
        const usedSeed = seed || Date.now();
        CourseGenerator.init(usedSeed);

        const canvasRect = this.canvas.getBoundingClientRect();
        const hole = CourseGenerator.generateHole(1, canvasRect.width, canvasRect.height);

        const ball = this.createBall(hole, ballColor);

        // Get recommended club for the tee shot based on hole distance
        const recommendedClub = ClubSystem.getRecommendedClub(ball, hole.holePosition);
        // Default to driver if no caddie recommendation
        const defaultClub = recommendedClub || 'driver';

        this.gameState = {
          currentHole: hole,
          round: {
            roundId: 'round-' + Date.now(),
            startTime: Date.now(),
            endTime: null,
            currentHoleNumber: 1,
            isComplete: false,
            holeScores: [],
            totalStrokes: 0,
            totalPar: 0,
            scoreRelativeToPar: 0,
            currentStrokeCount: 0
          },
          ball: ball,
          selectedClub: defaultClub,
          seed: usedSeed,
          playerName: playerName,
          ballColor: ballColor,
          themeOverride: themeOverride // For tournaments, override the shop theme
        };

        this.updateUI();
        document.getElementById('menu-overlay').classList.add('hidden');

        // Reset random events for new round
        RandomEventManager.reset();

        // Power-ups disabled for now
        // PowerUpManager.reset();
        // PowerUpManager.spawnPowerUps(hole, canvasRect.width, canvasRect.height);

        // Reset achievement stats for new round
        AchievementManager.resetRoundStats();

        // Generate wind for hole 1
        WindSystem.generateWind(1);

        // Start background music and crowd ambience
        AudioManager.startBackgroundMusic();
        AudioManager.startCrowdAmbience();

        // Initialize ghost system for hole 1
        GhostSystem.loadGhostForHole(1);
        GhostSystem.startRecording(1);

        await StorageManager.clearGameState();
      }

      async loadRound() {
        try {
          const savedState = await StorageManager.loadGameState();
          if (!savedState) {
            console.error('No saved game state found');
            return false;
          }

          CourseGenerator.init(savedState.seed);

          const canvasRect = this.canvas.getBoundingClientRect();
          const hole = CourseGenerator.generateHole(
            savedState.round.currentHoleNumber,
            canvasRect.width,
            canvasRect.height
          );

          const ballColor = savedState.ballColor || savedState.ball?.color || 'white';
          this.gameState = {
            currentHole: hole,
            round: savedState.round,
            ball: this.createBall(hole, ballColor),
            selectedClub: savedState.selectedClub,
            seed: savedState.seed,
            ballColor: ballColor
          };

          this.gameState.ball.x = savedState.ball.x;
          this.gameState.ball.y = savedState.ball.y;
          this.gameState.ball.velocityX = savedState.ball.velocityX;
          this.gameState.ball.velocityY = savedState.ball.velocityY;
          this.gameState.ball.isMoving = savedState.ball.isMoving;
          this.gameState.ball.lastSafePosition = savedState.ball.lastSafePosition;

          // Ensure ball is never loaded in a "in hole" state (prevents infinite loop bug)
          this.gameState.ball.inHole = false;
          this.gameState.ball.holeProgress = 0;
          delete this.gameState.ball.holeStartTime;

          this.updateUI();
          this.updateRoundProgress();
          document.getElementById('menu-overlay').classList.add('hidden');

          return true;
        } catch (error) {
          console.error('Failed to load saved game:', error);
          return false;
        }
      }

      createBall(hole, color = 'white') {
        return {
          x: hole.teePosition.x,
          y: hole.teePosition.y,
          velocityX: 0,
          velocityY: 0,
          spin: 0,
          isAirborne: false,
          isMoving: false,
          rotation: 0,
          groundY: hole.teePosition.y,
          holePosition: hole.holePosition,
          distanceFromHole: PhysicsEngine.distance(hole.teePosition, hole.holePosition),
          lastSafePosition: { x: hole.teePosition.x, y: hole.teePosition.y },
          waterPenalty: false,
          color: color
        };
      }

      updateUI() {
        const round = this.gameState.round;
        const hole = this.gameState.currentHole;

        document.getElementById('hole-number').textContent = round.currentHoleNumber;
        document.getElementById('hole-par').textContent = hole.par;
        document.getElementById('stroke-count').textContent = round.currentStrokeCount;
        document.getElementById('total-score').textContent = ScoreKeeper.getScoreDisplay(round.scoreRelativeToPar);

        const club = ClubSystem.getClub(this.gameState.selectedClub);
        document.getElementById('current-club').textContent = club.name;

        // Convert distance from pixels to yards
        const distance = Math.round(this.gameState.ball.distanceFromHole * PIXELS_TO_YARDS);
        document.getElementById('distance-to-hole').textContent = distance;

        // Update real-time distance display in lower right
        const distanceDisplay = document.getElementById('distance-display');
        const distanceValue = document.getElementById('distance-value');
        if (distanceDisplay && distanceValue) {
          distanceValue.textContent = distance;
          distanceDisplay.classList.remove('hidden');
        }

        this.updateClubSelector();
      }

      selectClub(clubId) {
        if (!this.gameState || !this.gameState.ball) return;
        if (this.gameState.ball.isMoving) return;
        // Lock to putter during putting mini-game
        if (this.gameState.puttingMiniGame) return;

        this.gameState.selectedClub = clubId;

        const club = ClubSystem.getClub(clubId);
        document.getElementById('current-club').textContent = club.name;

        this.updateClubSelector();

        // Notify tutorial of club selection
        if (TutorialManager.isActive) {
          TutorialManager.onAction('selectClub');
        }
      }

      updateClubSelector() {
        if (!this.gameState) return;

        const isFirstStroke = this.gameState.round.currentStrokeCount === 0;
        const availableClubs = ClubSystem.getAvailableClubs(isFirstStroke);
        const selectedClub = this.gameState.selectedClub;

        const clubSelector = document.getElementById('club-selector');
        clubSelector.innerHTML = '';

        // Get ball lie for caddie recommendation
        const ball = this.gameState.ball;
        let lie = 'fairway';
        if (ball.inSand) lie = 'sand';
        else if (ball.inRough) lie = 'rough';

        // Get wind for Master Caddie
        const wind = {
          dx: Math.cos(WindSystem.direction),
          dy: Math.sin(WindSystem.direction),
          strength: WindSystem.speed
        };

        const recommendation = ClubSystem.getRecommendedClub(ball, this.gameState.currentHole.holePosition, wind, lie);

        // Handle both string (lower tiers) and object (master tier) recommendation formats
        let recommendedClubId = null;
        let caddieTip = null;
        if (recommendation) {
          if (typeof recommendation === 'object') {
            recommendedClubId = recommendation.clubId;
            caddieTip = recommendation;
          } else {
            recommendedClubId = recommendation;
          }
        }

        // Display caddie tip for master tier
        const caddieTipEl = document.getElementById('caddie-tip');
        if (caddieTipEl) {
          if (caddieTip) {
            const clubName = ClubSystem.getClub(caddieTip.clubId)?.name || caddieTip.clubId;
            caddieTipEl.innerHTML = `<span class="caddie-icon">ðŸ‘‘</span> Hit <strong>${clubName}</strong> at <strong>${caddieTip.powerPercent}%</strong> power (${caddieTip.targetYards}yd to hole)`;
            caddieTipEl.classList.remove('hidden');
          } else if (recommendedClubId && CaddieSystem.getOwnedTier() > 0) {
            const clubName = ClubSystem.getClub(recommendedClubId)?.name || recommendedClubId;
            const icon = CaddieSystem.getCaddieIcon();
            caddieTipEl.innerHTML = `<span class="caddie-icon">${icon}</span> Recommended: <strong>${clubName}</strong>`;
            caddieTipEl.classList.remove('hidden');
          } else {
            caddieTipEl.classList.add('hidden');
          }
        }

        // Helper to get club type for styling
        const getClubType = (clubId) => {
          if (clubId === 'driver') return 'driver';
          if (clubId.includes('wood')) return 'wood';
          if (clubId === 'wedge') return 'wedge';
          if (clubId === 'putter') return 'putter';
          return 'iron';
        };

        // Helper to get short label for club head
        const getClubLabel = (club) => {
          if (club.id === 'driver') return 'D';
          if (club.id === 'wood3') return '3W';
          if (club.id === 'wood5') return '5W';
          if (club.id === 'wedge') return 'W';
          if (club.id === 'putter') return 'P';
          // Irons: extract number
          const match = club.id.match(/iron(\d)/);
          return match ? match[1] : club.name.charAt(0);
        };

        for (const club of availableClubs) {
          const maxDistance = ClubSystem.getMaxDistance(club.id);
          const clubType = getClubType(club.id);
          const label = getClubLabel(club);

          const slot = document.createElement('div');
          slot.className = 'club-slot';
          slot.dataset.club = club.id;

          // Add tier class for styling
          const clubTier = ShopSystem.getOwnedTier(club.id);
          slot.classList.add(`tier-${clubTier}`);

          if (club.id === selectedClub) {
            slot.classList.add('selected');
          }

          if (club.id === recommendedClubId) {
            slot.classList.add('recommended');
          }

          slot.innerHTML = `
            <div class="club-head ${clubType}">${label}</div>
            <div class="club-shaft"></div>
            <div class="club-distance">${maxDistance}yd</div>
          `;

          // Apply club skin to this slot
          ShopSystem.applyClubSkinToElement(slot);

          slot.addEventListener('click', () => this.selectClub(club.id));
          clubSelector.appendChild(slot);
        }

        const clubContainer = document.getElementById('club-selector-container');
        clubContainer.style.display = 'block';
      }

      executeSwing(swingVector) {
        if (!this.gameState || !this.gameState.ball) return;
        if (this.gameState.ball.isMoving) return;
        if (this.gameState.round.isComplete) return; // Prevent strokes after round ends

        // Start follow-through animation timer (show golfer for 800ms after hitting)
        this.followThroughEndTime = performance.now() + 800;

        // Track tee shot position for long drive achievement
        const isTeeShot = this.gameState.round.currentStrokeCount === 0;
        if (isTeeShot) {
          this.gameState.ball.teePosition = { x: this.gameState.ball.x, y: this.gameState.ball.y };
          // Start ghost playback on first shot of hole
          GhostSystem.startPlayback();
        }

        this.gameState.ball.lastSafePosition = { x: this.gameState.ball.x, y: this.gameState.ball.y };
        this.gameState.ball.waterPenalty = false;

        const modifiedSwing = ClubSystem.applyClubToSwing(swingVector, this.gameState.selectedClub);

        // Get club stats for accuracy and forgiveness
        const clubStats = ShopSystem.getTierStats(this.gameState.selectedClub);
        const accuracy = clubStats.accuracy;
        const forgiveness = clubStats.forgiveness;

        // Apply accuracy spread - lower accuracy = more random angle deviation
        // Max deviation: +/- 5 degrees for lowest accuracy club
        const maxDeviation = 0.087; // ~5 degrees in radians
        const accuracySpread = (1 - accuracy) * maxDeviation;
        const angleDeviation = (Math.random() - 0.5) * 2 * accuracySpread;
        modifiedSwing.angle += angleDeviation;

        // Apply sand penalty - 50% power reduction when hitting from bunker
        // Forgiveness reduces the penalty (at 100% forgiveness, still 50% penalty; at 70%, 65% penalty)
        if (this.gameState.ball.inSand) {
          const sandPenalty = 0.5 + (1 - forgiveness) * 0.3; // 50-80% penalty based on forgiveness
          modifiedSwing.power *= (1 - sandPenalty);
          this.gameState.ball.leavingSand = true;  // Flag to allow escape from sand
        }

        // Apply rough penalty - 20% power reduction when hitting from rough
        // Forgiveness reduces the penalty
        if (this.gameState.ball.inRough) {
          const basePenalty = 1 - PhysicsEngine.roughPowerMultiplier; // ~0.2 (20% loss)
          const reducedPenalty = basePenalty * (2 - forgiveness); // At 100% forgiveness: 20% loss; at 70%: 26% loss
          modifiedSwing.power *= (1 - reducedPenalty);
        }

        // Apply power-up modifiers
        // Power-ups disabled
        const powerUpMods = { powerMultiplier: 1, ignoreWind: false, freeStroke: false, hasMagnet: false };
        if (powerUpMods.powerMultiplier !== 1) {
          modifiedSwing.power *= powerUpMods.powerMultiplier;
        }
        // Store wind immunity on ball for physics to check
        this.gameState.ball.windImmune = powerUpMods.ignoreWind;
        // Store magnet effect for physics
        this.gameState.ball.hasMagnet = powerUpMods.hasMagnet;

        PhysicsEngine.applySwing(this.gameState.ball, modifiedSwing);

        // Check for mulligan - don't count stroke if mulligan active
        if (!powerUpMods.freeStroke) {
          ScoreKeeper.recordStroke(this.gameState.round);
        }

        this.gameState.strikeFlash = { active: true, progress: 0, startTime: performance.now() };

        AudioManager.playHitSound(swingVector.power);

        // Cutscene removed - user prefers direct gameplay without cinematic interruption

        if (this.gameState.ball.waterPenalty) {
          ScoreKeeper.recordStroke(this.gameState.round);
        }

        // Check for random event trigger (streaker) - not during tutorial, only if events enabled
        const eventsEnabled = StorageManager.loadSettings().eventsEnabled !== false;
        if (!this.gameState.isTutorial && eventsEnabled) {
          RandomEventManager.checkTrigger();
        }

        // Notify tutorial of swing
        if (TutorialManager.isActive) {
          TutorialManager.onAction('swing');
        }

        // Only save if ball is not in hole (prevents corrupted state on reload)
        if (!this.gameState.ball.inHole && !this.holeCompleting && !this.gameState.isTutorial) {
          StorageManager.saveGameState(this.gameState);
        }
      }

      update(timestamp) {
        if (!this.isRunning) return;

        // Cap deltaTime to prevent physics jumps on slow devices or when resuming
        const rawDeltaTime = (timestamp - this.lastFrameTime) / 1000;
        const deltaTime = Math.min(rawDeltaTime, 1/30);
        this.lastFrameTime = timestamp;

        if (!this.isPaused && this.gameState) {
          this.updateFPS(deltaTime);

          // Update animation time for visual effects
          this.animationTime += deltaTime;

          if (this.gameState.strikeFlash && this.gameState.strikeFlash.active) {
            const elapsed = timestamp - this.gameState.strikeFlash.startTime;
            this.gameState.strikeFlash.progress = Math.min(elapsed / 300, 1);
            if (this.gameState.strikeFlash.progress >= 1) {
              this.gameState.strikeFlash.active = false;
            }
          }

          if (this.gameState.ball) {
            const obstacles = this.gameState.currentHole.obstacles || [];
            // Update animated obstacles (windmills, moving rocks)
            this.updateObstacles(obstacles, deltaTime);
            PhysicsEngine.updateBall(this.gameState.ball, deltaTime, obstacles, this.gameState.currentHole);

            // Sample ball position for ghost recording
            if (GhostSystem.isRecording && this.gameState.ball.isMoving) {
              GhostSystem.samplePosition(this.gameState.ball);
            }

            // Check for out of bounds
            if (this.isBallOutOfBounds(this.gameState.ball) && !this.gameState.ball.inHole) {
              // For minigames, handle out of bounds differently
              if (this.gameState.isMiniGame && MiniGameManager.isActive) {
                MiniGameManager.handleOutOfBounds();
              } else {
                this.handleOutOfBounds();
              }
            }

            // Check if ball can enter hole (tutorial blocks until "Sink the Ball!" step)
            const canEnterHole = TutorialManager.canBallEnterHole();
            if (PhysicsEngine.isBallInHole(this.gameState.ball) && !this.holeCompleting && canEnterHole) {
              if (!this.gameState.ball.inHole) {
                this.gameState.ball.inHole = true;
                this.gameState.ball.holeProgress = 0;
                this.gameState.ball.holeStartTime = timestamp;
                AudioManager.playHoleSound();
                AudioManager.playCrowdClap();  // Polite applause for holing out
              }
            }

            if (this.gameState.ball.inHole) {
              const elapsed = timestamp - this.gameState.ball.holeStartTime;
              this.gameState.ball.holeProgress = Math.min(elapsed / 800, 1);

              if (this.gameState.ball.holeProgress >= 1 && !this.holeCompleting && !this.gameState.round.isComplete) {
                this.completeHole();
              }
            }

            this.updateBallStateIndicator();
          }

          // Update confetti particles
          ConfettiSystem.update(deltaTime);

          // Update wind gusts
          WindSystem.update(deltaTime);

          // Update random events (streaker)
          RandomEventManager.update(deltaTime);

          // Power-ups disabled
          // if (this.gameState.ball && this.gameState.ball.isMoving) {
          //   PowerUpManager.checkCollection(this.gameState.ball);
          // }

          // Check for UFO ball pickup
          if (this.gameState.ball && !this.gameState.ball.isMoving) {
            const canvas = document.getElementById('game-canvas');
            const rect = canvas.getBoundingClientRect();
            RandomEventManager.checkBallCollision(this.gameState.ball, rect.width, rect.height);
          }

          Renderer.renderFrame(this.gameState, this.animationTime);
        }

        requestAnimationFrame((t) => this.update(t));
      }

      updateObstacles(obstacles, deltaTime) {
        for (const obstacle of obstacles) {
          if (obstacle.type === 'windmill') {
            // Rotate windmill blades
            const rotationSpeed = obstacle.rotationSpeed || 1.5;
            obstacle.angle = (obstacle.angle || 0) + rotationSpeed * deltaTime;
            if (obstacle.angle > Math.PI * 2) {
              obstacle.angle -= Math.PI * 2;
            }
          } else if (obstacle.type === 'movingRock') {
            // Move rock back and forth
            const speed = obstacle.moveSpeed || 60;
            const range = obstacle.moveRange || 80;

            // Initialize position tracking if not set
            if (obstacle.startX === undefined) {
              obstacle.startX = obstacle.x;
              obstacle.moveOffset = 0;
              obstacle.moveDir = 1;
            }

            obstacle.moveOffset += speed * deltaTime * obstacle.moveDir;

            // Reverse direction at range limits
            if (obstacle.moveOffset >= range) {
              obstacle.moveDir = -1;
              obstacle.moveOffset = range;
            } else if (obstacle.moveOffset <= -range) {
              obstacle.moveDir = 1;
              obstacle.moveOffset = -range;
            }

            obstacle.x = obstacle.startX + obstacle.moveOffset;
          }
        }
      }

      updateBallStateIndicator() {
        const ball = this.gameState.ball;
        const stateElement = document.getElementById('ball-state');
        if (!stateElement) {
          console.log('No ball-state element found!');
          return;
        }

        const wasMoving = this.ballWasMoving || false;
        this.ballWasMoving = ball.isMoving;

        // Update distance display in real-time
        const distance = Math.round(ball.distanceFromHole * PIXELS_TO_YARDS); // Convert to yards
        const distanceValue = document.getElementById('distance-value');
        if (distanceValue) {
          distanceValue.textContent = distance;
        }

        if (ball.isMoving) {
          const speed = Math.sqrt(ball.velocityX * ball.velocityX + ball.velocityY * ball.velocityY);
          if (speed > 100) {
            stateElement.textContent = 'ðŸŒï¸ Flying';
            stateElement.style.color = '#FF6B35';
          } else {
            stateElement.textContent = 'â›³ Rolling';
            stateElement.style.color = '#4ECDC4';
          }
        } else if (ball.inSand) {
          stateElement.textContent = 'ðŸ–ï¸ In Bunker (-50% power)';
          stateElement.style.color = '#D4A574';
        } else if (ball.inRough) {
          stateElement.textContent = 'ðŸŒ¿ In Rough (-20% power)';
          stateElement.style.color = '#6B8E23';
        } else {
          stateElement.textContent = 'ðŸ”´ Ready';
          stateElement.style.color = '#2E8B57';
        }

        // Shot completion check - must happen regardless of terrain
        if (wasMoving && !ball.isMoving) {
          this.updateClubSelector();

          // Check for long drive achievement (after tee shot)
          if (ball.teePosition && this.gameState.round.currentStrokeCount === 1) {
            const dx = ball.x - ball.teePosition.x;
            const dy = ball.y - ball.teePosition.y;
            const distancePixels = Math.sqrt(dx * dx + dy * dy);
            const distanceYards = Math.round(distancePixels * PIXELS_TO_YARDS);
            AchievementManager.onDriveHit(distanceYards);
            DailyChallengeSystem.onLongDrive(distanceYards);
            // Announce great drives (250+ yards)
            if (distanceYards >= 250) {
              Announcer.announceShot('great_drive');
            }
            ball.teePosition = null; // Clear after checking
          }

          // Notify mini-game manager that shot completed
          // Use either this.currentHole or gameState.currentHole (both should work)
          const hole = this.currentHole || this.gameState.currentHole;
          if (MiniGameManager.isActive && hole) {
            MiniGameManager.onShotComplete(ball, hole);
          }
        }
      }

      completeHole() {
        // Skip normal hole completion for mini-games (but set flag to prevent repeated calls)
        if (this.gameState && this.gameState.isMiniGame) {
          this.holeCompleting = true;
          return;
        }

        const round = this.gameState.round;
        const hole = this.gameState.currentHole;

        // Prevent completing hole without hitting the ball
        if (round.currentStrokeCount === 0) {
          return;
        }

        // Prevent multiple simultaneous completions
        if (this.holeCompleting) {
          return;
        }

        this.holeCompleting = true;

        // Notify tutorial of hole completion
        if (TutorialManager.isActive) {
          TutorialManager.onAction('holeComplete');
          // Skip the normal hole complete flow for tutorial
          this.holeCompleting = false;
          return;
        }

        const holeScore = ScoreKeeper.completeHole(round, hole);

        // Stop ghost recording and save if best run
        GhostSystem.stopRecording(holeScore.strokes);

        this.updateRoundProgress();

        const scoreName = ScoreKeeper.getScoreName(holeScore.scoreRelativeToPar);

        // Notify achievement system
        AchievementManager.onHoleComplete(
          hole.holeNumber,
          holeScore.strokes,
          hole.par,
          AchievementManager.stats.hadWater,
          AchievementManager.stats.hadSand,
          0 // putts not tracked
        );

        // Track daily challenges - hole completion
        DailyChallengeSystem.onHoleComplete(
          AchievementManager.stats.hadSand,
          AchievementManager.stats.hadWater
        );

        // Track par streak for daily challenges
        if (holeScore.scoreRelativeToPar <= 0) {
          this.parStreakCount = (this.parStreakCount || 0) + 1;
          DailyChallengeSystem.onParStreak(this.parStreakCount);
        } else {
          this.parStreakCount = 0;
        }

        // Reset hazard tracking for next hole
        AchievementManager.stats.hadWater = false;
        AchievementManager.stats.hadSand = false;

        // Spawn confetti at hole position for any completion
        const holeX = hole.holePosition.x;
        const holeY = hole.holePosition.y;
        ConfettiSystem.spawn(holeX, holeY, 25, 'standard');

        if (holeScore.scoreRelativeToPar <= -1 || holeScore.strokes === 1) {
          this.celebrateGoodScore(holeScore.scoreRelativeToPar, holeX, holeY, holeScore.strokes);
        }

        setTimeout(() => {
          this.showHoleCompleteModal(hole, round, holeScore, scoreName);
        }, 500);
      }

      showHoleCompleteModal(hole, round, holeScore, scoreName) {
        // Update modal content
        document.getElementById('hole-complete-number').textContent = hole.holeNumber;
        document.getElementById('hole-complete-strokes').textContent = holeScore.strokes;
        document.getElementById('hole-complete-par').textContent = hole.par;
        document.getElementById('hole-complete-total').textContent = ScoreKeeper.getScoreDisplay(round.scoreRelativeToPar);

        // Set score name and color class
        const scoreNameEl = document.getElementById('hole-complete-score-name');
        scoreNameEl.textContent = scoreName;
        scoreNameEl.className = 'hole-complete-score-name';

        if (holeScore.scoreRelativeToPar <= -2) {
          scoreNameEl.classList.add('eagle');
        } else if (holeScore.scoreRelativeToPar === -1) {
          scoreNameEl.classList.add('birdie');
        } else if (holeScore.scoreRelativeToPar === 0) {
          scoreNameEl.classList.add('par');
        } else if (holeScore.scoreRelativeToPar === 1) {
          scoreNameEl.classList.add('bogey');
        } else {
          scoreNameEl.classList.add('double-bogey');
        }

        // Update button text based on whether this is the last hole
        const btn = document.getElementById('hole-complete-btn');
        const isLastHole = round.currentHoleNumber >= 9;
        btn.textContent = isLastHole ? 'View Scorecard' : 'Next Hole';

        // Show modal
        document.getElementById('hole-complete-overlay').classList.remove('hidden');

        // Set up button handler (remove old listener first)
        const newBtn = btn.cloneNode(true);
        btn.parentNode.replaceChild(newBtn, btn);

        newBtn.addEventListener('click', () => {
          document.getElementById('hole-complete-overlay').classList.add('hidden');

          if (isLastHole) {
            round.isComplete = true;
            round.endTime = Date.now();
            // Notify achievement system of round completion
            AchievementManager.onRoundComplete(round.scoreRelativeToPar);
            // Notify daily challenges of round completion
            DailyChallengeSystem.onRoundComplete(round.scoreRelativeToPar);

            // Award Golf Bucks for completing round
            let roundReward = 50; // Base reward
            if (round.scoreRelativeToPar < 0) {
              // Bonus for under par: 25 per stroke under
              roundReward += Math.abs(round.scoreRelativeToPar) * 25;
              ShopSystem.addBucks(roundReward, 'Round Complete (Under Par!)');
            } else {
              ShopSystem.addBucks(roundReward, 'Round Complete');
            }

            this.showRoundSummary();
          } else {
            this.advanceToNextHole();
          }
        });
      }

      // === T098: Play cheer for exceptional shots ===
      celebrateGoodScore(scoreRelativeToPar, holeX, holeY, strokes) {
        // Power-ups disabled
        const goldenMultiplier = 1;
        const goldenSuffix = '';

        if (strokes === 1) {
          // Hole in one!
          console.log('ðŸŽ¯ HOLE IN ONE! ðŸŽ¯');
          AudioManager.playCheerSound();
          AudioManager.playCrowdCheer();  // Crowd goes wild!
          ConfettiSystem.spawn(holeX, holeY, 80, 'eagle');
          ShopSystem.addBucks(250 * goldenMultiplier, 'Hole in One!' + goldenSuffix);
          DailyChallengeSystem.onHoleInOne();
          Announcer.announceShot('hole_in_one');
        } else if (scoreRelativeToPar <= -2) {
          console.log('ðŸŽ‰ EAGLE OR BETTER! ðŸŽ‰');
          AudioManager.playCheerSound();
          AudioManager.playCrowdCheer();  // Crowd cheers for eagle
          // Extra confetti burst for eagle or better
          ConfettiSystem.spawn(holeX, holeY, 60, 'eagle');
          ShopSystem.addBucks(75 * goldenMultiplier, 'Eagle!' + goldenSuffix);
          DailyChallengeSystem.onEagle();
          Announcer.announceShot('eagle');
        } else if (scoreRelativeToPar === -1) {
          console.log('ðŸŽŠ BIRDIE! ðŸŽŠ');
          AudioManager.playCheerSound();
          AudioManager.playCrowdCheer();  // Crowd cheers for birdie
          // Extra confetti for birdie
          ConfettiSystem.spawn(holeX, holeY, 40, 'birdie');
          ShopSystem.addBucks(25 * goldenMultiplier, 'Birdie!' + goldenSuffix);
          DailyChallengeSystem.onBirdie();
          Announcer.announceShot('birdie');
        }
      }

      updateRoundProgress() {
        const summary = ScoreKeeper.getRoundSummary(this.gameState.round);
        const progressElement = document.getElementById('round-progress');
        const progressText = document.getElementById('progress-text');

        if (progressElement && progressText) {
          progressText.textContent = `${summary.completedHoles}/9 holes`;
          progressElement.classList.remove('hidden');
        }
      }

      advanceToNextHole() {
        const round = this.gameState.round;
        round.currentHoleNumber++;
        round.currentStrokeCount = 0;

        const canvasRect = this.canvas.getBoundingClientRect();
        const hole = CourseGenerator.generateHole(round.currentHoleNumber, canvasRect.width, canvasRect.height);

        this.gameState.currentHole = hole;
        this.gameState.ball = this.createBall(hole, this.gameState.ballColor || 'white');

        // Auto-select recommended club for the new hole's tee shot based on distance
        const recommendedClub = ClubSystem.getRecommendedClub(this.gameState.ball, hole.holePosition);
        // Default to driver if no caddie recommendation
        this.gameState.selectedClub = recommendedClub || 'driver';

        // Generate new wind for this hole
        WindSystem.generateWind(round.currentHoleNumber);

        // Power-ups disabled
        // PowerUpManager.reset();
        // PowerUpManager.spawnPowerUps(hole, canvasRect.width, canvasRect.height);

        this.updateUI();
        this.updateClubSelector();

        // Reset flag to allow next hole completion
        this.holeCompleting = false;

        // Initialize ghost system for new hole
        GhostSystem.loadGhostForHole(round.currentHoleNumber);
        GhostSystem.startRecording(round.currentHoleNumber);

        StorageManager.saveGameState(this.gameState);

        // Announce hole (with delay for transition)
        setTimeout(() => {
          Announcer.announceHole(round.currentHoleNumber, hole.par);

          // Final hole pressure moment
          if (round.currentHoleNumber === 9) {
            setTimeout(() => {
              const summary = ScoreKeeper.getRoundSummary(round);
              if (summary.scoreRelativeToPar <= 0) {
                Announcer.announcePressure("Final hole. A chance to finish under par!");
              } else if (summary.scoreRelativeToPar <= 2) {
                Announcer.announcePressure("Last hole. Everything to play for!");
              } else {
                Announcer.announcePressure("The final hole.");
              }
            }, 2500);
          }
        }, 800);
      }

      async showRoundSummary() {
        const round = this.gameState.round;
        const summary = ScoreKeeper.getRoundSummary(round);

        let tableHTML = '<table class="scorecard-table">';
        tableHTML += '<tr><th>Hole</th><th>Par</th><th>Strokes</th><th>Score</th></tr>';

        for (const holeScore of round.holeScores) {
          const scoreClass = this.getScoreClass(holeScore.scoreRelativeToPar);
          const scoreDisplay = ScoreKeeper.getScoreDisplay(holeScore.scoreRelativeToPar);

          tableHTML += `<tr>`;
          tableHTML += `<td>${holeScore.holeNumber}</td>`;
          tableHTML += `<td>${holeScore.par}</td>`;
          tableHTML += `<td>${holeScore.strokes}</td>`;
          tableHTML += `<td class="${scoreClass}">${scoreDisplay}</td>`;
          tableHTML += `</tr>`;
        }

        tableHTML += '</table>';
        tableHTML += `<div style="margin-top: 20px; font-size: 18px;">`;
        tableHTML += `<strong>Total Strokes:</strong> ${summary.totalStrokes}<br>`;
        tableHTML += `<strong>Total Par:</strong> ${summary.totalPar}<br>`;
        tableHTML += `<strong>Final Score:</strong> <span style="color: ${ScoreKeeper.getScoreColor(summary.scoreRelativeToPar)}; font-weight: bold; font-size: 24px;">${ScoreKeeper.getScoreDisplay(summary.scoreRelativeToPar)}</span>`;
        tableHTML += `</div>`;

        document.getElementById('scorecard-content').innerHTML = tableHTML;
        document.getElementById('scorecard-overlay').classList.remove('hidden');
        document.getElementById('menu-overlay').classList.remove('hidden');

        // Add round completion to mailbox with scorecard data
        if (typeof MailboxManager !== 'undefined') {
          const scoreDisplay = ScoreKeeper.getScoreDisplay(summary.scoreRelativeToPar);
          MailboxManager.addNotification('round', `Round Complete: ${scoreDisplay}`,
            `${summary.totalStrokes} strokes over ${summary.completedHoles} holes`, {
              type: 'scorecard',
              holeScores: round.holeScores,
              totalStrokes: summary.totalStrokes,
              totalPar: summary.totalPar,
              scoreRelativeToPar: summary.scoreRelativeToPar,
              timestamp: Date.now()
            });
        }

        // === T078: Save to leaderboard ===
        await this.saveToLeaderboard(summary);

        // === Tournament integration ===
        if (TournamentSystem.isInTournament()) {
          // Record final score for single-round tournament
          TournamentSystem.recordScore(summary.scoreRelativeToPar, summary.totalStrokes);

          // Tournament is complete - show results with all 25 players
          const result = TournamentSystem.completeTournament();
          if (result) {
            // Track tournament achievement
            AchievementManager.onTournamentComplete(result.position);

            const config = TournamentSystem.tournaments[result.tournamentType];
            const inMoney = result.position <= 10;

            // Add tournament results with full leaderboard to scorecard
            const scorecardContent = document.getElementById('scorecard-content');
            scorecardContent.innerHTML += `
              <div class="tournament-complete-banner">
                <h3>ðŸ† ${result.tournament} Complete!</h3>
                <div class="tournament-final-position ${result.position <= 3 ? (result.position === 1 ? 'gold' : (result.position === 2 ? 'silver' : 'bronze')) : ''}">${TournamentSystem.getPositionText(result.position)} Place</div>
                <div class="tournament-final-details">out of ${result.totalPlayers} players</div>
                ${inMoney ?
                  `<div class="tournament-prize-won">+${result.prize} Golf Bucks!</div>` :
                  `<div class="tournament-lost-entry">${result.entryFee > 0 ? `Lost ${result.entryFee} Golf Bucks entry fee` : 'No prize - try again!'}</div>`
                }

                <div class="tournament-leaderboard-embed">
                  <h4>Final Standings</h4>
                  <div class="leaderboard-scroll">
                    ${result.leaderboard.map((entry, i) => `
                      <div class="leaderboard-entry ${entry.isPlayer ? 'player' : ''} ${i < 10 ? 'in-money' : 'out-money'}">
                        <span class="lb-rank">${i + 1}.</span>
                        <span class="lb-name">${entry.name}</span>
                        <span class="lb-score">${entry.score === 0 ? 'E' : (entry.score > 0 ? '+' + entry.score : entry.score)}</span>
                        <span class="lb-prize">${i < 10 ? `+${config.prizePool[i]}` : '-'}</span>
                      </div>
                    `).join('')}
                  </div>
                </div>
              </div>
            `;
          }

          TournamentSystem.updateIndicator();
        }

        // === Career Mode Tournament Completion ===
        if (CareerSystem.isInCareerTournament && CareerSystem.activeCareer) {
          // Get tournament name before completing (it gets cleared after)
          const tournamentName = CareerSystem.activeTournament?.name || 'Tournament';
          const result = CareerSystem.completeTournament(summary.scoreRelativeToPar);
          if (result) {
            // Generate position text
            const positionText = result.position === 1 ? '1st' :
                                 result.position === 2 ? '2nd' :
                                 result.position === 3 ? '3rd' :
                                 result.position + 'th';

            const scorecardContent = document.getElementById('scorecard-content');
            scorecardContent.innerHTML += `
              <div class="tournament-complete-banner">
                <h3>ðŸ† ${tournamentName} Complete!</h3>
                <div class="tournament-final-position ${result.position <= 3 ? (result.position === 1 ? 'gold' : (result.position === 2 ? 'silver' : 'bronze')) : ''}">${positionText} Place</div>
                <div class="tournament-final-details">out of 25 players</div>
                ${result.earnings > 0 ?
                  `<div class="tournament-prize-won">+$${result.earnings} Prize Money!</div>` :
                  `<div class="tournament-lost-entry">No prize this time - keep practicing!</div>`
                }
                ${result.points > 0 ? `<div class="tournament-points">+${result.points} Ranking Points</div>` : ''}
              </div>
            `;
          }
        }

        // Reset flag for next round
        this.holeCompleting = false;

        StorageManager.clearGameState();
      }

      // === T078, T080: Save round to leaderboard (global API) ===
      async saveToLeaderboard(summary) {
        const playerName = this.gameState?.playerName || 'Player';

        try {
          // Try to save to global leaderboard API
          const response = await fetch('/api/leaderboard', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              playerName: playerName,
              scoreRelativeToPar: summary.scoreRelativeToPar,
              totalStrokes: summary.totalStrokes
            })
          });

          if (response.ok) {
            const result = await response.json();
            console.log('Score saved to global leaderboard');

            // Check if made top 3
            if (result.rank && result.rank <= 3) {
              const medals = ['ðŸ¥‡', 'ðŸ¥ˆ', 'ðŸ¥‰'];
              console.log(`${medals[result.rank - 1]} NEW TOP SCORE! Rank #${result.rank}`);
            }
          } else {
            throw new Error('API response not ok');
          }
        } catch (error) {
          console.error('Failed to save to global leaderboard, saving locally:', error);
          // Fallback to local storage if API fails
          try {
            const entry = {
              scoreRelativeToPar: summary.scoreRelativeToPar,
              totalStrokes: summary.totalStrokes,
              completedAt: Date.now(),
              playerName: playerName
            };
            await StorageManager.addLeaderboardEntry(entry);
          } catch (localError) {
            console.error('Failed to save locally too:', localError);
          }
        }
      }

      // === T077, T081: Display leaderboard (global API with local fallback) ===
      static async showLeaderboard() {
        const content = document.getElementById('leaderboard-content');
        content.innerHTML = '<div class="leaderboard-empty">Loading...</div>';
        document.getElementById('leaderboard-overlay').classList.remove('hidden');

        let leaderboard = [];

        try {
          // Try to fetch from global API first
          const response = await fetch('/api/leaderboard');
          if (response.ok) {
            leaderboard = await response.json();
          } else {
            throw new Error('API response not ok');
          }
        } catch (error) {
          console.error('Failed to fetch global leaderboard, trying local:', error);
          // Fallback to local storage
          try {
            leaderboard = await StorageManager.getLeaderboard();
          } catch (localError) {
            console.error('Failed to load local leaderboard:', localError);
          }
        }

        if (!leaderboard || leaderboard.length === 0) {
          content.innerHTML = '<div class="leaderboard-empty">No scores yet. Complete a round to get on the leaderboard!</div>';
        } else {
          let tableHTML = '<table class="leaderboard-table">';
          tableHTML += '<tr><th>Rank</th><th>Player</th><th>Score</th><th>Strokes</th><th>Date</th></tr>';

          leaderboard.forEach((entry, index) => {
            const rank = index + 1;
            const rankClass = rank <= 3 ? `leaderboard-rank-${rank}` : '';
            let scoreClass = 'leaderboard-score-par';
            if (entry.scoreRelativeToPar < 0) scoreClass = 'leaderboard-score-under';
            else if (entry.scoreRelativeToPar > 0) scoreClass = 'leaderboard-score-over';

            const scoreDisplay = ScoreKeeper.getScoreDisplay(entry.scoreRelativeToPar);
            const date = new Date(entry.completedAt).toLocaleDateString();
            // Support both playerName (new) and playerInitials (old local data)
            const playerName = entry.playerName || entry.playerInitials || 'Unknown';

            tableHTML += `<tr>`;
            tableHTML += `<td class="leaderboard-rank ${rankClass}">#${rank}</td>`;
            tableHTML += `<td>${playerName}</td>`;
            tableHTML += `<td class="${scoreClass}">${scoreDisplay}</td>`;
            tableHTML += `<td>${entry.totalStrokes}</td>`;
            tableHTML += `<td>${date}</td>`;
            tableHTML += `</tr>`;
          });

          tableHTML += '</table>';
          content.innerHTML = tableHTML;
        }
      }

      getScoreClass(scoreRelativeToPar) {
        if (scoreRelativeToPar <= -2) return 'score-eagle';
        if (scoreRelativeToPar === -1) return 'score-birdie';
        if (scoreRelativeToPar === 0) return 'score-par';
        if (scoreRelativeToPar === 1) return 'score-bogey';
        return 'score-double';
      }

      updateFPS(deltaTime) {
        this.fps = Math.round(1 / deltaTime);
        if (this.debugMode) {
          const debugDiv = document.getElementById('debug-info');
          debugDiv.innerHTML = `FPS: ${this.fps}<br>Ball: (${Math.round(this.gameState.ball.x)}, ${Math.round(this.gameState.ball.y)})<br>Velocity: (${Math.round(this.gameState.ball.velocityX)}, ${Math.round(this.gameState.ball.velocityY)})<br>Moving: ${this.gameState.ball.isMoving}`;
        }
      }
    }

    // === Initialize Game (T005, T011, T012) ===
    window.addEventListener('DOMContentLoaded', async () => {
      console.log('DOM Content Loaded');

      const canvas = document.getElementById('game-canvas');
      if (!canvas) {
        console.error('Canvas element not found!');
        return;
      }

      console.log('Canvas found, initializing game engine...');

      let gameEngine;
      try {
        gameEngine = new GameEngine(canvas);
        window.gameEngine = gameEngine; // Expose for testing
        console.log('Game engine initialized successfully');
      } catch (error) {
        console.error('Error initializing game engine:', error);
        alert('Error initializing game: ' + error.message);
        return;
      }

      const newGameBtn = document.getElementById('new-game-btn');
      const resumeGameBtn = document.getElementById('resume-game-btn');

      if (!newGameBtn) {
        console.error('New game button not found!');
        return;
      }

      AudioManager.init();
      Announcer.init();
      AchievementManager.init();
      ShopSystem.init();
      DailyChallengeSystem.init();
      DailyChallengeSystem.updateUI();
      TournamentSystem.init();
      TournamentSystem.updateIndicator();
      MailboxManager.init();
      CaddieSystem.init();
      MiniGameManager.init();
      CareerSystem.init();
      ShopSystem.updateBalanceDisplay();

      // Set up shop click handlers using event delegation (handles dynamically created buttons)
      const shopOverlayEl = document.getElementById('shop-overlay');

      document.getElementById('shop-clubs-grid').addEventListener('click', function(e) {
        if (e.target.classList.contains('shop-buy-btn') && !e.target.disabled) {
          const clubId = e.target.dataset.club;
          e.target.disabled = true;
          e.target.textContent = '...';

          if (ShopSystem.purchaseClub(clubId)) {
            // Force full shop refresh
            ShopSystem.updateBalanceDisplay();
            ShopSystem.renderShop();
          } else {
            e.target.disabled = false;
            e.target.textContent = 'Upgrade';
          }
        }
      });

      document.getElementById('shop-balls-grid').addEventListener('click', function(e) {
        if (e.target.classList.contains('shop-buy-btn') && !e.target.disabled) {
          const skinId = e.target.dataset.skin;
          e.target.disabled = true;
          e.target.textContent = '...';

          if (ShopSystem.purchaseBallSkin(skinId)) {
            // Force full shop refresh
            ShopSystem.updateBalanceDisplay();
            ShopSystem.renderShop();
          } else {
            e.target.disabled = false;
            e.target.textContent = 'Buy';
          }
        }
      });

      // Add click sound to all menu buttons and start music on first interaction
      document.addEventListener('click', (e) => {
        if (e.target.classList.contains('menu-button')) {
          AudioManager.unlock(); // Ensure audio is unlocked
          AudioManager.playClickSound();
          // Start background music on first menu interaction (will be ignored if already playing)
          AudioManager.startBackgroundMusic();
        }
      });

      try {
        await StorageManager.init();
        const hasSavedGame = await StorageManager.hasSavedGame();

        if (hasSavedGame) {
          resumeGameBtn.classList.remove('hidden');
        } else {
          resumeGameBtn.classList.add('hidden');
        }
      } catch (error) {
        console.error('Error checking for saved game:', error);
        resumeGameBtn.classList.add('hidden');
      }

      // Name entry modal elements
      const nameEntryOverlay = document.getElementById('name-entry-overlay');
      const playerNameInput = document.getElementById('player-name-input');
      const startWithNameBtn = document.getElementById('start-with-name-btn');
      const cancelNameEntryBtn = document.getElementById('cancel-name-entry-btn');
      const ballColorOptions = document.getElementById('ball-color-options');

      // Load last used name and ball color from localStorage
      const lastPlayerName = localStorage.getItem('golf-player-name') || '';
      let lastBallColor = localStorage.getItem('golf-ball-color') || 'white';
      playerNameInput.value = lastPlayerName;

      // Set up ball color selection
      let selectedBallColor = lastBallColor;

      // Function to dynamically render ball color options based on owned skins
      function renderBallColorPicker() {
        ballColorOptions.innerHTML = '';
        const ownedSkins = ShopSystem.ownedBallSkins;

        // If selected color is not owned, reset to white
        if (!ownedSkins.includes(selectedBallColor)) {
          selectedBallColor = 'white';
          lastBallColor = 'white';
        }

        for (const skinId of ownedSkins) {
          const colors = BallColors[skinId] || PremiumBallColors[skinId] || BallColors.white;
          const isAnimated = PremiumBallColors[skinId]?.animated;

          const option = document.createElement('div');
          option.className = 'ball-color-option' + (skinId === selectedBallColor ? ' selected' : '');
          if (isAnimated) option.classList.add('animated-ball');
          option.dataset.color = skinId;
          option.style.background = `linear-gradient(135deg, ${colors.highlight} 0%, ${colors.base} 100%)`;

          ballColorOptions.appendChild(option);
        }
      }

      // Initial render
      renderBallColorPicker();

      // Ball color click handlers (using event delegation)
      ballColorOptions.addEventListener('click', (e) => {
        const colorOption = e.target.closest('.ball-color-option');
        if (!colorOption) return;

        // Update selection
        ballColorOptions.querySelectorAll('.ball-color-option').forEach(btn => btn.classList.remove('selected'));
        colorOption.classList.add('selected');
        selectedBallColor = colorOption.dataset.color;
      });

      newGameBtn.addEventListener('click', () => {
        console.log('New Game button clicked');
        AudioManager.unlock();
        // Re-render ball picker to show any newly purchased skins
        renderBallColorPicker();
        // Show game mode selection
        document.getElementById('game-mode-overlay').classList.remove('hidden');
      });

      // Handle starting game with name
      const startGameWithName = async () => {
        const playerName = playerNameInput.value.trim() || 'Player';
        console.log('Starting game with player:', playerName, 'ball color:', selectedBallColor);

        // Save name and ball color for next time
        localStorage.setItem('golf-player-name', playerName);
        localStorage.setItem('golf-ball-color', selectedBallColor);

        // Hide name entry modal
        nameEntryOverlay.classList.add('hidden');

        try {
          await gameEngine.startNewRound(null, playerName, selectedBallColor);
          gameEngine.start();
          resumeGameBtn.classList.add('hidden');
          console.log('Game started successfully');
        } catch (error) {
          console.error('Error starting game:', error);
          alert('Error starting game: ' + error.message);
        }
      };

      startWithNameBtn.addEventListener('click', startGameWithName);

      // Allow Enter key to start game
      playerNameInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
          startGameWithName();
        }
      });

      // Cancel button
      cancelNameEntryBtn.addEventListener('click', () => {
        nameEntryOverlay.classList.add('hidden');
      });

      // === Game Mode Selection handlers ===
      const gameModeOverlay = document.getElementById('game-mode-overlay');
      const quickPlayBtn = document.getElementById('quick-play-btn');
      const tournamentPlayBtn = document.getElementById('tournament-play-btn');
      const cancelModeBtn = document.getElementById('cancel-mode-btn');

      quickPlayBtn.addEventListener('click', () => {
        gameModeOverlay.classList.add('hidden');
        nameEntryOverlay.classList.remove('hidden');
        playerNameInput.focus();
        playerNameInput.select();
      });

      tournamentPlayBtn.addEventListener('click', () => {
        gameModeOverlay.classList.add('hidden');
        document.getElementById('tournament-overlay').classList.remove('hidden');
        TournamentSystem.renderUI();
      });

      const minigamePlayBtn = document.getElementById('minigame-play-btn');
      minigamePlayBtn.addEventListener('click', () => {
        gameModeOverlay.classList.add('hidden');
        MiniGameManager.showSelection();
      });

      cancelModeBtn.addEventListener('click', () => {
        gameModeOverlay.classList.add('hidden');
      });

      // === Mailbox handlers ===
      const mailboxBtn = document.getElementById('mailbox-btn');
      const mailboxOverlay = document.getElementById('mailbox-overlay');
      const mailboxCloseBtn = document.getElementById('mailbox-close-btn');
      const markAllReadBtn = document.getElementById('mark-all-read-btn');

      mailboxBtn.addEventListener('click', () => {
        MailboxManager.renderMailbox();
        mailboxOverlay.classList.remove('hidden');
      });

      mailboxCloseBtn.addEventListener('click', () => {
        mailboxOverlay.classList.add('hidden');
      });

      markAllReadBtn.addEventListener('click', () => {
        MailboxManager.markAllAsRead();
        MailboxManager.renderMailbox();
      });

      // Mark notifications as read when clicking on them
      document.getElementById('mailbox-content').addEventListener('click', (e) => {
        const notificationItem = e.target.closest('.notification-item');
        if (notificationItem) {
          const id = notificationItem.dataset.id;
          MailboxManager.markAsRead(id);
          notificationItem.classList.remove('unread');
        }
      });

      resumeGameBtn.addEventListener('click', async () => {
        console.log('Resume Game button clicked');
        AudioManager.unlock();
        try {
          const loaded = await gameEngine.loadRound();
          if (loaded) {
            gameEngine.start();
            console.log('Game resumed successfully');
          } else {
            alert('Failed to load saved game');
            resumeGameBtn.classList.add('hidden');
          }
        } catch (error) {
          console.error('Error resuming game:', error);
          alert('Error resuming game: ' + error.message);
        }
      });

      // === T081: Leaderboard button handler ===
      const leaderboardBtn = document.getElementById('leaderboard-btn');
      if (leaderboardBtn) {
        leaderboardBtn.addEventListener('click', async () => {
          console.log('Leaderboard button clicked');
          await GameEngine.showLeaderboard();
        });
      }

      // === Music prompt button handler ===
      const musicPromptBtn = document.getElementById('music-prompt-btn');
      if (musicPromptBtn) {
        // Check if music is already playing (from settings)
        const settings = StorageManager.loadSettings();
        if (AudioManager.musicPlaying) {
          musicPromptBtn.innerHTML = 'ðŸŽµ Music Playing';
          musicPromptBtn.classList.add('playing');
        }

        musicPromptBtn.addEventListener('click', () => {
          AudioManager.unlock();
          const settings = StorageManager.loadSettings();

          if (AudioManager.musicPlaying) {
            // Stop music
            AudioManager.stopBackgroundMusic();
            musicPromptBtn.innerHTML = 'ðŸŽµ Tap for Music';
            musicPromptBtn.classList.remove('playing');
          } else {
            // Start music (if enabled in settings)
            if (settings.musicEnabled !== false) {
              AudioManager.startBackgroundMusic();
              musicPromptBtn.innerHTML = 'ðŸŽµ Music Playing';
              musicPromptBtn.classList.add('playing');
            }
          }
          AudioManager.playClickSound();
        });
      }

      // === Settings button handler ===
      const settingsBtn = document.getElementById('settings-btn');
      const settingsOverlay = document.getElementById('settings-overlay');
      const closeSettingsBtn = document.getElementById('close-settings-btn');
      const resetTutorialBtn = document.getElementById('reset-tutorial-btn');

      // Settings toggles
      const settingSound = document.getElementById('setting-sound');
      const settingMusic = document.getElementById('setting-music');
      const settingTrails = document.getElementById('setting-trails');
      const settingEvents = document.getElementById('setting-events');

      // Load current settings into toggles
      function loadSettingsIntoUI() {
        const settings = StorageManager.loadSettings();
        settingSound.checked = settings.soundEnabled !== false;
        settingMusic.checked = settings.musicEnabled !== false;
        settingTrails.checked = settings.trailsEnabled !== false;
        settingEvents.checked = settings.eventsEnabled !== false;

        // Update swing mode buttons
        const swingMode = settings.swingMode || 'easy';
        document.querySelectorAll('.swing-mode-btn').forEach(btn => {
          btn.classList.toggle('active', btn.dataset.mode === swingMode);
        });
      }

      if (settingsBtn) {
        settingsBtn.addEventListener('click', () => {
          loadSettingsIntoUI();
          settingsOverlay.classList.remove('hidden');
          AudioManager.playClickSound();
        });
      }

      // In-game settings button (accessible during gameplay)
      const ingameSettingsBtn = document.getElementById('ingame-settings-btn');
      if (ingameSettingsBtn) {
        ingameSettingsBtn.addEventListener('click', () => {
          loadSettingsIntoUI();
          settingsOverlay.classList.remove('hidden');
          AudioManager.playClickSound();
        });
      }

      if (closeSettingsBtn) {
        closeSettingsBtn.addEventListener('click', () => {
          settingsOverlay.classList.add('hidden');
          AudioManager.playClickSound();
        });
      }

      // Sound toggle
      if (settingSound) {
        settingSound.addEventListener('change', () => {
          const settings = StorageManager.loadSettings();
          settings.soundEnabled = settingSound.checked;
          StorageManager.saveSettings(settings);
          AudioManager.setMuted(!settingSound.checked);
        });
      }

      // Music toggle
      if (settingMusic) {
        settingMusic.addEventListener('change', () => {
          const settings = StorageManager.loadSettings();
          settings.musicEnabled = settingMusic.checked;
          StorageManager.saveSettings(settings);
          if (settingMusic.checked) {
            AudioManager.startBackgroundMusic();
            if (musicPromptBtn) {
              musicPromptBtn.innerHTML = 'ðŸŽµ Music Playing';
              musicPromptBtn.classList.add('playing');
            }
          } else {
            AudioManager.stopBackgroundMusic();
            if (musicPromptBtn) {
              musicPromptBtn.innerHTML = 'ðŸŽµ Tap for Music';
              musicPromptBtn.classList.remove('playing');
            }
          }
        });
      }

      // Trails toggle
      if (settingTrails) {
        settingTrails.addEventListener('change', () => {
          const settings = StorageManager.loadSettings();
          settings.trailsEnabled = settingTrails.checked;
          StorageManager.saveSettings(settings);
        });
      }

      // Events toggle
      if (settingEvents) {
        settingEvents.addEventListener('change', () => {
          const settings = StorageManager.loadSettings();
          settings.eventsEnabled = settingEvents.checked;
          StorageManager.saveSettings(settings);
        });
      }

      // Reset tutorial button
      if (resetTutorialBtn) {
        resetTutorialBtn.addEventListener('click', () => {
          const settings = StorageManager.loadSettings();
          settings.tutorialCompleted = false;
          StorageManager.saveSettings(settings);
          resetTutorialBtn.textContent = 'Done!';
          setTimeout(() => {
            resetTutorialBtn.textContent = 'Reset';
          }, 1500);
          AudioManager.playClickSound();
        });
      }

      // Swing mode selector
      const swingModeSelector = document.getElementById('swing-mode-selector');
      if (swingModeSelector) {
        swingModeSelector.addEventListener('click', (e) => {
          const btn = e.target.closest('.swing-mode-btn');
          if (!btn) return;

          const mode = btn.dataset.mode;
          const settings = StorageManager.loadSettings();
          settings.swingMode = mode;
          StorageManager.saveSettings(settings);

          // Update button states
          document.querySelectorAll('.swing-mode-btn').forEach(b => {
            b.classList.toggle('active', b.dataset.mode === mode);
          });

          AudioManager.playClickSound();
        });
      }

      // === Achievements button handler ===
      const achievementsBtn = document.getElementById('achievements-btn');
      const achievementsOverlay = document.getElementById('achievements-overlay');
      const closeAchievementsBtn = document.getElementById('close-achievements-btn');
      const achievementsGrid = document.getElementById('achievements-grid');
      const achievementsProgress = document.getElementById('achievements-progress');

      function populateAchievements() {
        const achievements = AchievementManager.achievements;
        const ids = Object.keys(achievements);
        const unlocked = ids.filter(id => achievements[id].unlocked).length;

        achievementsProgress.textContent = `${unlocked} / ${ids.length} unlocked`;

        achievementsGrid.innerHTML = '';
        ids.forEach(id => {
          const a = achievements[id];
          const card = document.createElement('div');
          card.className = `achievement-card ${a.unlocked ? 'unlocked' : 'locked'}`;
          card.innerHTML = `
            <div class="icon">${a.icon}</div>
            <div class="name">${a.name}</div>
            <div class="desc">${a.desc}</div>
          `;
          achievementsGrid.appendChild(card);
        });
      }

      if (achievementsBtn) {
        achievementsBtn.addEventListener('click', () => {
          populateAchievements();
          achievementsOverlay.classList.remove('hidden');
          AudioManager.playClickSound();
        });
      }

      if (closeAchievementsBtn) {
        closeAchievementsBtn.addEventListener('click', () => {
          achievementsOverlay.classList.add('hidden');
          AudioManager.playClickSound();
        });
      }

      // === Shop button handler ===
      const shopBtn = document.getElementById('shop-btn');
      const shopOverlay = document.getElementById('shop-overlay');
      const shopCloseBtn = document.getElementById('shop-close-btn');
      const menuBalance = document.getElementById('menu-balance');

      function openShop() {
        ShopSystem.renderShop();
        shopOverlay.classList.remove('hidden');
        AudioManager.playClickSound();
      }

      if (shopBtn) {
        shopBtn.addEventListener('click', openShop);
      }

      // Clicking balance also opens shop
      if (menuBalance) {
        menuBalance.addEventListener('click', openShop);
      }

      if (shopCloseBtn) {
        shopCloseBtn.addEventListener('click', () => {
          shopOverlay.classList.add('hidden');
          AudioManager.playClickSound();
        });
      }

      // === Shop Tab Switching ===
      const shopTabs = document.querySelectorAll('.shop-tab');
      shopTabs.forEach(tab => {
        tab.addEventListener('click', () => {
          // Remove active from all tabs and content
          shopTabs.forEach(t => t.classList.remove('active'));
          document.querySelectorAll('.shop-tab-content').forEach(c => c.classList.remove('active'));

          // Activate clicked tab and its content
          tab.classList.add('active');
          const tabId = tab.dataset.tab;
          const content = document.getElementById('shop-tab-' + tabId);
          if (content) content.classList.add('active');

          // Render caddie tab content when switching to it
          if (tabId === 'caddie') {
            document.getElementById('caddie-shop-content').innerHTML = CaddieSystem.renderShopTab();
          }

          AudioManager.playClickSound();
        });
      });

      // Caddie shop buy button handler
      document.getElementById('caddie-shop-content').addEventListener('click', (e) => {
        const btn = e.target.closest('.caddie-buy-btn');
        if (btn && !btn.disabled) {
          const tierIndex = parseInt(btn.dataset.tier);
          if (CaddieSystem.purchase(tierIndex)) {
            // Force balance update and re-render caddie tab
            ShopSystem.updateBalanceDisplay();
            document.getElementById('caddie-shop-content').innerHTML = CaddieSystem.renderShopTab();
            AudioManager.playClickSound();
          }
        }
      });

      // === Tournament button handlers ===
      const tournamentBtn = document.getElementById('tournament-btn');
      const tournamentOverlay = document.getElementById('tournament-overlay');
      const tournamentCloseBtn = document.getElementById('tournament-close-btn');
      const tournamentContent = document.getElementById('tournament-content');

      function openTournaments() {
        TournamentSystem.renderUI();
        TournamentSystem.updateIndicator();
        tournamentOverlay.classList.remove('hidden');
        AudioManager.playClickSound();
      }

      if (tournamentBtn) {
        tournamentBtn.addEventListener('click', openTournaments);
      }

      if (tournamentCloseBtn) {
        tournamentCloseBtn.addEventListener('click', () => {
          tournamentOverlay.classList.add('hidden');
          AudioManager.playClickSound();
        });
      }

      // Delegate click events for tournament content (cards and dynamic buttons)
      if (tournamentContent) {
        tournamentContent.addEventListener('click', async (e) => {
          // Join tournament queue (click on tournament card)
          const card = e.target.closest('.tournament-card:not(.locked)');
          if (card) {
            const tournamentType = card.dataset.tournament;
            if (tournamentType && TournamentSystem.joinQueue(tournamentType)) {
              AudioManager.playClickSound();
              TournamentSystem.renderUI(); // Show queue UI
              TournamentSystem.updateIndicator();
            }
            return;
          }

          // Start tournament button (after queue fills)
          if (e.target.id === 'start-tournament-btn') {
            AudioManager.playClickSound();
            tournamentOverlay.classList.add('hidden');
            document.getElementById('menu-overlay').classList.add('hidden');

            // Start game with tournament course theme
            const theme = TournamentSystem.getCourseTheme();
            const playerName = localStorage.getItem('golf-player-name') || 'Player';
            const ballColor = localStorage.getItem('golf-ball-color') || 'white';

            await gameEngine.startNewRound(null, playerName, ballColor, theme);
            gameEngine.start();
            TournamentSystem.updateIndicator();
            return;
          }

          // Continue/Play tournament button
          if (e.target.id === 'continue-tournament-btn') {
            AudioManager.playClickSound();
            tournamentOverlay.classList.add('hidden');
            document.getElementById('menu-overlay').classList.add('hidden');

            // Start game with tournament course theme
            const theme = TournamentSystem.getCourseTheme();
            const playerName = localStorage.getItem('golf-player-name') || 'Player';
            const ballColor = localStorage.getItem('golf-ball-color') || 'white';

            await gameEngine.startNewRound(null, playerName, ballColor, theme);
            gameEngine.start();
            TournamentSystem.updateIndicator();
            return;
          }

          // Leave queue button
          if (e.target.id === 'leave-queue-btn') {
            AudioManager.playClickSound();
            TournamentSystem.leaveQueue();
            TournamentSystem.renderUI();
            TournamentSystem.updateIndicator();
            return;
          }

          // Abandon tournament button
          if (e.target.id === 'abandon-tournament-btn') {
            AudioManager.playClickSound();
            TournamentSystem.abandonTournament();
            TournamentSystem.renderUI();
            TournamentSystem.updateIndicator();
            return;
          }

          // Done button after results
          if (e.target.id === 'tournament-done-btn') {
            AudioManager.playClickSound();
            tournamentOverlay.classList.add('hidden');
            return;
          }
        });
      }

      // === T082-T089: Tutorial handlers ===
      const tutorialBtn = document.getElementById('tutorial-btn');
      const tutorialNextBtn = document.getElementById('tutorial-next-btn');
      const tutorialSkipBtn = document.getElementById('tutorial-skip-btn');
      const tutorialYesBtn = document.getElementById('tutorial-yes-btn');
      const tutorialNoBtn = document.getElementById('tutorial-no-btn');
      const tutorialPromptOverlay = document.getElementById('tutorial-prompt-overlay');

      // Tutorial button in menu (manual replay)
      if (tutorialBtn) {
        tutorialBtn.addEventListener('click', () => {
          console.log('Tutorial button clicked');
          gameEngine.start(); // Make sure game engine is running
          TutorialManager.start(gameEngine);
        });
      }

      // Tutorial navigation buttons
      if (tutorialNextBtn) {
        tutorialNextBtn.addEventListener('click', () => {
          TutorialManager.nextStep();
        });
      }

      if (tutorialSkipBtn) {
        tutorialSkipBtn.addEventListener('click', () => {
          TutorialManager.skip();
        });
      }

      // First-time tutorial prompt handlers
      if (tutorialYesBtn) {
        tutorialYesBtn.addEventListener('click', () => {
          tutorialPromptOverlay.classList.add('hidden');
          gameEngine.start(); // Make sure game engine is running
          TutorialManager.start(gameEngine);
        });
      }

      if (tutorialNoBtn) {
        tutorialNoBtn.addEventListener('click', () => {
          tutorialPromptOverlay.classList.add('hidden');
          // Mark as completed so we don't ask again
          const settings = StorageManager.loadSettings();
          settings.tutorialCompleted = true;
          StorageManager.saveSettings(settings);
        });
      }

      // Check if first-time user and show tutorial prompt
      const settings = StorageManager.loadSettings();
      if (!settings.tutorialCompleted) {
        tutorialPromptOverlay.classList.remove('hidden');
      }

      // Club selector toggle button handler
      const clubToggleBtn = document.getElementById('club-toggle-btn');
      const clubSelector = document.getElementById('club-selector');
      if (clubToggleBtn && clubSelector) {
        clubToggleBtn.addEventListener('click', () => {
          clubSelector.classList.toggle('minimized');
          clubToggleBtn.textContent = clubSelector.classList.contains('minimized') ? 'Show Clubs' : 'Hide Clubs';
        });
      }

      console.log('Howlett Golf Chaos - Ready!');
    });
  </script>
</body>
</html>
