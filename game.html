<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-fullscreen">
  <title>Howlett Golf Chaos</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      user-select: none;
    }

    body {
      width: 100vw;
      height: 100vh;
      overflow: hidden;
      background: #87CEEB;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
      touch-action: none;
    }

    #game-canvas {
      display: block;
      width: 100%;
      height: 100%;
      touch-action: none;
    }

    #ui-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }

    #ui-overlay > * {
      pointer-events: auto;
    }

    #scoreboard {
      position: absolute;
      top: 20px;
      left: 20px;
      background: rgba(255, 255, 255, 0.95);
      padding: 15px 20px;
      border-radius: 12px;
      font-size: 18px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    }

    #scoreboard div {
      margin: 5px 0;
    }

    #ball-state {
      position: absolute;
      top: 20px;
      right: 20px;
      background: rgba(255, 255, 255, 0.95);
      padding: 10px 20px;
      border-radius: 12px;
      font-size: 16px;
      font-weight: bold;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    }

    #distance-display {
      position: absolute;
      bottom: 20px;
      right: 20px;
      background: rgba(255, 255, 255, 0.95);
      padding: 15px 25px;
      border-radius: 12px;
      font-size: 24px;
      font-weight: bold;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      color: #2196F3;
    }

    #distance-display .label {
      font-size: 12px;
      color: #666;
      font-weight: normal;
      display: block;
      margin-bottom: 5px;
    }

    #club-selector-container {
      position: absolute;
      bottom: 15px;
      left: 50%;
      transform: translateX(-50%);
      display: none;
    }

    #club-selector {
      display: flex;
      align-items: flex-end;
      justify-content: center;
      gap: 4px;
      padding: 15px 20px 10px 20px;
      background: linear-gradient(to bottom, #8B4513 0%, #654321 50%, #3d2817 100%);
      border-radius: 20px 20px 8px 8px;
      box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4), inset 0 2px 4px rgba(255,255,255,0.1);
      border: 3px solid #2d1810;
      position: relative;
    }

    #club-selector::before {
      content: '';
      position: absolute;
      top: 5px;
      left: 15px;
      right: 15px;
      height: 4px;
      background: linear-gradient(to right, transparent, rgba(255,215,0,0.3), transparent);
      border-radius: 2px;
    }

    #club-selector.minimized {
      display: none;
    }

    .club-slot {
      display: flex;
      flex-direction: column;
      align-items: center;
      cursor: pointer;
      transition: transform 0.15s ease;
      padding: 5px;
      border-radius: 8px;
    }

    .club-slot:hover {
      transform: translateY(-5px);
    }

    .club-slot.selected {
      transform: translateY(-12px);
    }

    .club-slot.selected .club-head {
      box-shadow: 0 0 15px rgba(255, 215, 0, 0.8), 0 4px 8px rgba(0,0,0,0.3);
    }

    .club-shaft {
      width: 4px;
      height: 35px;
      background: linear-gradient(to right, #888, #ccc, #888);
      border-radius: 2px;
      box-shadow: 1px 0 2px rgba(0,0,0,0.3);
    }

    .club-head {
      width: 44px;
      height: 44px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      font-size: 11px;
      color: white;
      text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
      box-shadow: 0 3px 6px rgba(0,0,0,0.3);
      border: 2px solid rgba(255,255,255,0.3);
      transition: box-shadow 0.15s ease;
    }

    .club-head.driver {
      background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
    }

    .club-head.wood {
      background: linear-gradient(135deg, #e67e22 0%, #d35400 100%);
    }

    .club-head.iron {
      background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
    }

    .club-head.wedge {
      background: linear-gradient(135deg, #f1c40f 0%, #f39c12 100%);
      color: #333;
      text-shadow: none;
    }

    .club-head.putter {
      background: linear-gradient(135deg, #2ecc71 0%, #27ae60 100%);
    }

    .club-distance {
      font-size: 9px;
      color: rgba(255,255,255,0.8);
      margin-top: 3px;
      text-align: center;
      text-shadow: 1px 1px 1px rgba(0,0,0,0.5);
    }

    .club-slot.recommended .club-head {
      animation: pulse-gold 1s ease-in-out infinite;
    }

    @keyframes pulse-gold {
      0%, 100% { box-shadow: 0 0 5px rgba(255, 215, 0, 0.5), 0 3px 6px rgba(0,0,0,0.3); }
      50% { box-shadow: 0 0 20px rgba(255, 215, 0, 0.9), 0 3px 6px rgba(0,0,0,0.3); }
    }

    #club-toggle-btn {
      background: linear-gradient(to bottom, #5a3d2b, #3d2817);
      border: 2px solid #2d1810;
      border-radius: 8px;
      padding: 8px 20px;
      font-size: 14px;
      font-weight: bold;
      color: #f4e4bc;
      cursor: pointer;
      box-shadow: 0 3px 6px rgba(0, 0, 0, 0.3);
      margin-top: 8px;
      width: 100%;
      text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
    }

    #club-toggle-btn:active {
      background: linear-gradient(to bottom, #4a3020, #2d1810);
    }

    .button {
      padding: 12px 24px;
      margin: 5px;
      background: #4CAF50;
      color: white;
      border: none;
      border-radius: 8px;
      font-size: 16px;
      cursor: pointer;
      font-weight: 600;
      transition: background 0.2s;
    }

    .button:active {
      background: #45a049;
    }

    .button.selected {
      background: #2196F3;
    }

    #debug-info {
      position: absolute;
      top: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 10px;
      border-radius: 8px;
      font-size: 14px;
      font-family: monospace;
    }

    #menu-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      justify-content: center;
      align-items: center;
      flex-direction: column;
    }

    #menu-overlay h1 {
      color: white;
      font-size: 48px;
      margin-bottom: 40px;
    }

    .menu-button {
      padding: 16px 48px;
      margin: 10px;
      background: #4CAF50;
      color: white;
      border: none;
      border-radius: 12px;
      font-size: 24px;
      cursor: pointer;
      font-weight: 700;
      transition: background 0.2s;
    }

    .menu-button:active {
      background: #45a049;
    }

    .hidden {
      display: none !important;
    }

    #scorecard-overlay {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(255, 255, 255, 0.98);
      padding: 30px;
      border-radius: 16px;
      box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
      max-width: 500px;
      max-height: 80vh;
      overflow-y: auto;
    }

    #scorecard-overlay h2 {
      margin-bottom: 20px;
      color: #333;
    }

    .scorecard-table {
      width: 100%;
      border-collapse: collapse;
      margin: 20px 0;
    }

    .scorecard-table th, .scorecard-table td {
      padding: 10px;
      text-align: center;
      border-bottom: 1px solid #ddd;
    }

    .scorecard-table th {
      background: #f5f5f5;
      font-weight: bold;
    }

    .score-birdie { color: #4CAF50; font-weight: bold; }
    .score-eagle { color: #FFD700; font-weight: bold; }
    .score-par { color: #2196F3; }
    .score-bogey { color: #FF9800; }
    .score-double { color: #F44336; }

    #round-progress {
      position: absolute;
      bottom: 80px;
      left: 20px;
      background: rgba(255, 255, 255, 0.95);
      padding: 10px 15px;
      border-radius: 8px;
      font-size: 14px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    }

    #reset-shot-btn {
      position: absolute;
      bottom: 100px;
      right: 20px;
      padding: 8px 16px;
      background: rgba(244, 67, 54, 0.9);
      color: white;
      border: none;
      border-radius: 8px;
      font-size: 14px;
      font-weight: bold;
      cursor: pointer;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
      z-index: 1000;
      transition: background 0.2s;
    }

    #reset-shot-btn:active {
      background: rgba(211, 47, 47, 0.95);
    }

    .club-power-info {
      font-size: 12px;
      color: #666;
      margin-top: 2px;
    }

    /* === Leaderboard Styles (T077) === */
    #leaderboard-overlay {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(255, 255, 255, 0.98);
      padding: 30px;
      border-radius: 16px;
      box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
      max-width: 600px;
      max-height: 80vh;
      overflow-y: auto;
      z-index: 1000;
    }

    #leaderboard-overlay h2 {
      margin-bottom: 20px;
      color: #333;
      text-align: center;
    }

    .leaderboard-table {
      width: 100%;
      border-collapse: collapse;
      margin: 20px 0;
    }

    .leaderboard-table th,
    .leaderboard-table td {
      padding: 12px;
      text-align: center;
      border-bottom: 1px solid #ddd;
    }

    .leaderboard-table th {
      background: #f5f5f5;
      font-weight: bold;
      position: sticky;
      top: 0;
    }

    .leaderboard-table tr:hover {
      background: #f9f9f9;
    }

    .leaderboard-rank {
      font-weight: bold;
      color: #666;
    }

    .leaderboard-rank-1 { color: #FFD700; }
    .leaderboard-rank-2 { color: #C0C0C0; }
    .leaderboard-rank-3 { color: #CD7F32; }

    .leaderboard-score-under { color: #4CAF50; font-weight: bold; }
    .leaderboard-score-par { color: #2196F3; }
    .leaderboard-score-over { color: #F44336; }

    .leaderboard-empty {
      text-align: center;
      padding: 40px 20px;
      color: #999;
      font-style: italic;
    }

    .new-best-indicator {
      background: #FFD700;
      color: #333;
      padding: 10px 20px;
      border-radius: 8px;
      margin-bottom: 20px;
      text-align: center;
      font-weight: bold;
      animation: pulse 1s ease-in-out;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }

    /* === Hole Complete Modal Styles === */
    #hole-complete-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.75);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1002;
      animation: fadeIn 0.3s ease-out;
    }

    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    @keyframes slideUp {
      from { transform: translate(-50%, -40%); opacity: 0; }
      to { transform: translate(-50%, -50%); opacity: 1; }
    }

    @keyframes scorePop {
      0% { transform: scale(0.5); opacity: 0; }
      70% { transform: scale(1.1); }
      100% { transform: scale(1); opacity: 1; }
    }

    .hole-complete-modal {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: linear-gradient(145deg, #ffffff 0%, #f0f0f0 100%);
      padding: 30px 40px;
      border-radius: 20px;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.4);
      text-align: center;
      min-width: 280px;
      max-width: 90%;
      animation: slideUp 0.4s ease-out;
    }

    .hole-complete-header {
      font-size: 16px;
      color: #666;
      text-transform: uppercase;
      letter-spacing: 2px;
      margin-bottom: 5px;
    }

    .hole-complete-number {
      font-size: 48px;
      font-weight: 800;
      color: #333;
      margin-bottom: 15px;
    }

    .hole-complete-score-name {
      font-size: 32px;
      font-weight: 700;
      margin-bottom: 10px;
      animation: scorePop 0.5s ease-out 0.2s both;
    }

    .hole-complete-score-name.eagle { color: #FFD700; text-shadow: 0 2px 10px rgba(255, 215, 0, 0.5); }
    .hole-complete-score-name.birdie { color: #4CAF50; }
    .hole-complete-score-name.par { color: #2196F3; }
    .hole-complete-score-name.bogey { color: #FF9800; }
    .hole-complete-score-name.double-bogey { color: #F44336; }

    .hole-complete-details {
      display: flex;
      justify-content: center;
      gap: 30px;
      margin: 20px 0;
      padding: 15px 0;
      border-top: 1px solid #e0e0e0;
      border-bottom: 1px solid #e0e0e0;
    }

    .hole-complete-stat {
      text-align: center;
    }

    .hole-complete-stat-value {
      font-size: 28px;
      font-weight: 700;
      color: #333;
    }

    .hole-complete-stat-label {
      font-size: 12px;
      color: #888;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .hole-complete-total {
      font-size: 18px;
      color: #555;
      margin-bottom: 25px;
    }

    .hole-complete-total span {
      font-weight: 700;
    }

    .hole-complete-btn {
      padding: 14px 40px;
      background: linear-gradient(145deg, #4CAF50 0%, #45a049 100%);
      color: white;
      border: none;
      border-radius: 30px;
      font-size: 18px;
      font-weight: 700;
      cursor: pointer;
      box-shadow: 0 4px 15px rgba(76, 175, 80, 0.4);
      transition: transform 0.2s, box-shadow 0.2s;
    }

    .hole-complete-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(76, 175, 80, 0.5);
    }

    .hole-complete-btn:active {
      transform: translateY(0);
    }

    /* === Name Entry Modal Styles === */
    #name-entry-overlay {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(255, 255, 255, 0.98);
      padding: 30px;
      border-radius: 16px;
      box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
      max-width: 400px;
      width: 90%;
      z-index: 1001;
      text-align: center;
    }

    #name-entry-overlay h2 {
      margin-bottom: 10px;
      color: #333;
    }

    #name-entry-overlay p {
      color: #666;
      margin-bottom: 20px;
      font-size: 14px;
    }

    #player-name-input {
      width: 100%;
      padding: 15px;
      font-size: 18px;
      border: 2px solid #ddd;
      border-radius: 8px;
      margin-bottom: 20px;
      text-align: center;
      outline: none;
      transition: border-color 0.2s;
    }

    #player-name-input:focus {
      border-color: #4CAF50;
    }

    .name-entry-buttons {
      display: flex;
      gap: 10px;
      justify-content: center;
    }

    .name-entry-buttons .button {
      flex: 1;
      max-width: 150px;
    }

    .name-entry-buttons .cancel-btn {
      background: #999;
    }

    .name-entry-buttons .cancel-btn:active {
      background: #777;
    }

    /* === Tutorial Styles === */
    #tutorial-overlay,
    #tutorial-prompt-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1002;
    }

    .tutorial-modal {
      background: rgba(255, 255, 255, 0.98);
      padding: 30px 40px;
      border-radius: 16px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
      max-width: 450px;
      width: 90%;
      text-align: center;
    }

    .tutorial-modal h2 {
      color: #333;
      margin: 0 0 15px 0;
      font-size: 28px;
    }

    .tutorial-modal p {
      color: #555;
      font-size: 18px;
      line-height: 1.5;
      margin: 0 0 25px 0;
    }

    .tutorial-buttons {
      display: flex;
      gap: 15px;
      justify-content: center;
      flex-wrap: wrap;
    }

    .tutorial-buttons .menu-button {
      padding: 12px 30px;
      font-size: 18px;
    }

    #tutorial-progress {
      margin-top: 20px;
      color: #888;
      font-size: 14px;
    }

    .tutorial-highlight {
      position: relative;
      box-shadow: 0 0 0 4px rgba(255, 165, 0, 0.8), 0 0 20px rgba(255, 165, 0, 0.5) !important;
      animation: tutorialPulse 1.5s ease-in-out infinite;
      z-index: 100;
    }

    @keyframes tutorialPulse {
      0%, 100% { box-shadow: 0 0 0 4px rgba(255, 165, 0, 0.8), 0 0 20px rgba(255, 165, 0, 0.5); }
      50% { box-shadow: 0 0 0 6px rgba(255, 165, 0, 1), 0 0 30px rgba(255, 165, 0, 0.7); }
    }

    /* === Ball Color Selector Styles === */
    .ball-color-section {
      margin: 20px 0;
    }

    .ball-color-section label {
      display: block;
      color: #333;
      font-weight: 600;
      margin-bottom: 12px;
    }

    .ball-color-options {
      display: flex;
      justify-content: center;
      gap: 12px;
      flex-wrap: wrap;
    }

    .ball-color-option {
      width: 44px;
      height: 44px;
      border-radius: 50%;
      border: 3px solid transparent;
      cursor: pointer;
      transition: transform 0.2s, border-color 0.2s, box-shadow 0.2s;
      position: relative;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }

    .ball-color-option:hover {
      transform: scale(1.1);
    }

    .ball-color-option.selected {
      border-color: #4CAF50;
      box-shadow: 0 0 0 3px rgba(76, 175, 80, 0.3), 0 2px 4px rgba(0, 0, 0, 0.2);
    }

    .ball-color-option::after {
      content: '';
      position: absolute;
      top: 4px;
      left: 8px;
      width: 12px;
      height: 8px;
      background: radial-gradient(ellipse at center, rgba(255,255,255,0.8) 0%, rgba(255,255,255,0) 70%);
      border-radius: 50%;
    }

    /* Mobile phone optimizations */
    @media (max-width: 480px) {
      #scoreboard {
        top: 10px;
        left: 10px;
        padding: 8px 12px;
        font-size: 14px;
        border-radius: 8px;
      }

      #scoreboard div {
        margin: 3px 0;
      }

      #ball-state {
        top: 10px;
        right: 10px;
        padding: 6px 12px;
        font-size: 13px;
        border-radius: 8px;
      }

      #distance-display {
        bottom: 10px;
        right: 10px;
        padding: 10px 15px;
        font-size: 18px;
        border-radius: 8px;
      }

      #distance-display .label {
        font-size: 10px;
      }

      #club-selector-container {
        bottom: 8px;
        max-width: calc(100% - 16px);
      }

      #club-selector {
        padding: 10px 12px 8px 12px;
        gap: 2px;
        overflow-x: auto;
        -webkit-overflow-scrolling: touch;
        border-radius: 15px 15px 6px 6px;
      }

      .club-slot {
        padding: 3px;
      }

      .club-head {
        width: 38px;
        height: 38px;
        font-size: 10px;
      }

      .club-shaft {
        height: 25px;
        width: 3px;
      }

      .club-distance {
        font-size: 8px;
      }

      #club-toggle-btn {
        padding: 6px 14px;
        font-size: 12px;
        margin-top: 5px;
      }

      .button {
        padding: 8px 16px;
        margin: 3px;
        font-size: 13px;
        border-radius: 6px;
      }

      #menu-container {
        padding: 20px 15px;
      }

      #menu-container h1 {
        font-size: 32px;
      }

      #round-progress {
        top: auto;
        bottom: 120px;
        left: 10px;
        font-size: 12px;
        padding: 6px 12px;
      }

      .overlay-panel {
        padding: 20px 15px;
        max-width: 95%;
      }

      .overlay-panel h2 {
        font-size: 22px;
      }

      .scorecard-table, .leaderboard-table {
        font-size: 13px;
      }

      .scorecard-table th,
      .scorecard-table td,
      .leaderboard-table th,
      .leaderboard-table td {
        padding: 6px 8px;
      }
    }

    /* Small tablets and large phones */
    @media (min-width: 481px) and (max-width: 768px) {
      #scoreboard {
        top: 15px;
        left: 15px;
        padding: 12px 16px;
        font-size: 16px;
      }

      #ball-state {
        top: 15px;
        right: 15px;
        padding: 8px 16px;
        font-size: 14px;
      }

      #distance-display {
        bottom: 15px;
        right: 15px;
        padding: 12px 20px;
        font-size: 20px;
      }

      #club-selector-container {
        bottom: 12px;
        max-width: calc(100% - 24px);
      }

      #club-selector {
        padding: 12px 16px 8px 16px;
        gap: 3px;
        overflow-x: auto;
        -webkit-overflow-scrolling: touch;
      }

      .club-head {
        width: 42px;
        height: 42px;
        font-size: 11px;
      }

      .club-shaft {
        height: 30px;
      }

      .button {
        padding: 10px 20px;
        margin: 4px;
        font-size: 15px;
      }
    }
  </style>
</head>
<body>
  <canvas id="game-canvas"></canvas>

  <div id="ui-overlay">
    <div id="scoreboard">
      <div><strong>Hole:</strong> <span id="hole-number">1</span>/9</div>
      <div><strong>Par:</strong> <span id="hole-par">3</span></div>
      <div><strong>Strokes:</strong> <span id="stroke-count">0</span></div>
      <div><strong>Score:</strong> <span id="total-score">E</span></div>
      <div><strong>Club:</strong> <span id="current-club">Driver</span></div>
      <div><strong>Distance:</strong> <span id="distance-to-hole">---</span>m</div>
    </div>

    <div id="ball-state">üî¥ Ready</div>

    <div id="distance-display" class="hidden">
      <span class="label">Distance to Hole</span>
      <span id="distance-value">---</span>yd
    </div>

    <div id="round-progress" class="hidden">
      <strong>Progress:</strong> <span id="progress-text">0/9 holes</span>
    </div>

    <div id="club-selector-container">
      <div id="club-selector">
        <button class="button selected" data-club="driver">Driver</button>
      </div>
      <button id="club-toggle-btn">Hide Clubs</button>
    </div>

    <div id="scorecard-overlay" class="hidden">
      <h2>Scorecard</h2>
      <div id="scorecard-content"></div>
      <button class="button" onclick="document.getElementById('scorecard-overlay').classList.add('hidden')">Close</button>
    </div>

    <div id="leaderboard-overlay" class="hidden">
      <h2>üèÜ Leaderboard - Top 10</h2>
      <div id="leaderboard-content"></div>
      <button class="button" onclick="document.getElementById('leaderboard-overlay').classList.add('hidden')">Close</button>
    </div>

    <div id="name-entry-overlay" class="hidden">
      <h2>Enter Your Name</h2>
      <p>Your scores will appear on the global leaderboard!</p>
      <input type="text" id="player-name-input" maxlength="20" placeholder="Your name" autocomplete="off">

      <div class="ball-color-section">
        <label>Choose Your Ball</label>
        <div class="ball-color-options" id="ball-color-options">
          <div class="ball-color-option selected" data-color="white" style="background: linear-gradient(135deg, #FFFFFF 0%, #CCCCCC 100%);"></div>
          <div class="ball-color-option" data-color="yellow" style="background: linear-gradient(135deg, #FFEB3B 0%, #FBC02D 100%);"></div>
          <div class="ball-color-option" data-color="orange" style="background: linear-gradient(135deg, #FF9800 0%, #F57C00 100%);"></div>
          <div class="ball-color-option" data-color="pink" style="background: linear-gradient(135deg, #FF69B4 0%, #DB7093 100%);"></div>
          <div class="ball-color-option" data-color="red" style="background: linear-gradient(135deg, #F44336 0%, #C62828 100%);"></div>
          <div class="ball-color-option" data-color="blue" style="background: linear-gradient(135deg, #2196F3 0%, #1565C0 100%);"></div>
          <div class="ball-color-option" data-color="green" style="background: linear-gradient(135deg, #4CAF50 0%, #2E7D32 100%);"></div>
          <div class="ball-color-option" data-color="purple" style="background: linear-gradient(135deg, #9C27B0 0%, #6A1B9A 100%);"></div>
        </div>
      </div>

      <div class="name-entry-buttons">
        <button class="button" id="start-with-name-btn">Start Game</button>
        <button class="button cancel-btn" id="cancel-name-entry-btn">Cancel</button>
      </div>
    </div>

    <div id="debug-info" class="hidden"></div>

    <button id="reset-shot-btn" class="hidden">Cancel Shot</button>

    <div id="hole-complete-overlay" class="hidden">
      <div class="hole-complete-modal">
        <div class="hole-complete-header">Hole Complete</div>
        <div class="hole-complete-number" id="hole-complete-number">1</div>
        <div class="hole-complete-score-name" id="hole-complete-score-name">Par</div>
        <div class="hole-complete-details">
          <div class="hole-complete-stat">
            <div class="hole-complete-stat-value" id="hole-complete-strokes">4</div>
            <div class="hole-complete-stat-label">Strokes</div>
          </div>
          <div class="hole-complete-stat">
            <div class="hole-complete-stat-value" id="hole-complete-par">4</div>
            <div class="hole-complete-stat-label">Par</div>
          </div>
        </div>
        <div class="hole-complete-total">Round Total: <span id="hole-complete-total">E</span></div>
        <button class="hole-complete-btn" id="hole-complete-btn">Next Hole</button>
      </div>
    </div>
  </div>

  <!-- Tutorial Overlay -->
  <div id="tutorial-overlay" class="hidden">
    <div class="tutorial-modal">
      <h2 id="tutorial-title">Welcome!</h2>
      <p id="tutorial-text">Tutorial text here</p>
      <div class="tutorial-buttons">
        <button id="tutorial-next-btn" class="menu-button">Next</button>
        <button id="tutorial-skip-btn" class="menu-button cancel-btn">Skip Tutorial</button>
      </div>
      <div id="tutorial-progress">Step 1 of 5</div>
    </div>
  </div>

  <!-- Tutorial Prompt Overlay -->
  <div id="tutorial-prompt-overlay" class="hidden">
    <div class="tutorial-modal">
      <h2>First Time Playing?</h2>
      <p>Would you like a quick tutorial to learn how to play?</p>
      <div class="tutorial-buttons">
        <button id="tutorial-yes-btn" class="menu-button">Yes, Show Me!</button>
        <button id="tutorial-no-btn" class="menu-button cancel-btn">No Thanks</button>
      </div>
    </div>
  </div>

  <div id="menu-overlay">
    <h1>Howlett Golf Chaos</h1>
    <p style="color: white; font-size: 18px; margin: 20px; max-width: 500px; text-align: center;">
      üñ±Ô∏è Desktop: Click and drag backward from the ball, then release to swing<br>
      üì± Touch: Drag backward from the ball, then release
    </p>
    <button class="menu-button" id="new-game-btn">New Game</button>
    <button class="menu-button hidden" id="resume-game-btn">Resume Game</button>
    <button class="menu-button" id="leaderboard-btn">Leaderboard</button>
    <button class="menu-button" id="tutorial-btn" style="background: #9C27B0;">Tutorial</button>
  </div>

  <script>
    'use strict';

    // T001-T005: Basic setup complete
    // T006-T012: Foundational modules below

    // === Ball Color Definitions ===
    const BallColors = {
      white:  { highlight: '#FFFFFF', base: '#CCCCCC', stroke: '#999999' },
      yellow: { highlight: '#FFEB3B', base: '#FBC02D', stroke: '#F9A825' },
      orange: { highlight: '#FF9800', base: '#F57C00', stroke: '#E65100' },
      pink:   { highlight: '#FF69B4', base: '#DB7093', stroke: '#C71585' },
      red:    { highlight: '#F44336', base: '#C62828', stroke: '#B71C1C' },
      blue:   { highlight: '#2196F3', base: '#1565C0', stroke: '#0D47A1' },
      green:  { highlight: '#4CAF50', base: '#2E7D32', stroke: '#1B5E20' },
      purple: { highlight: '#9C27B0', base: '#6A1B9A', stroke: '#4A148C' }
    };

    // === SeededRandom Class (T006) ===
    class SeededRandom {
      constructor(seed = Date.now()) {
        this.state = seed;
      }

      next() {
        let t = this.state += 0x6D2B79F5;
        t = Math.imul(t ^ t >>> 15, t | 1);
        t ^= t + Math.imul(t ^ t >>> 7, t | 61);
        return ((t ^ t >>> 14) >>> 0) / 4294967296;
      }

      nextInt(min, max) {
        return Math.floor(this.next() * (max - min + 1)) + min;
      }

      nextFloat(min, max) {
        return this.next() * (max - min) + min;
      }
    }

    // === PhysicsEngine Module (T008, T016, T017, T018) ===
    const PhysicsEngine = {
      gravity: 980,
      friction: 0.98,
      airResistance: 0.995,
      stopThreshold: 5,
      holeRadius: 15,

      add(v1, v2) {
        return { x: v1.x + v2.x, y: v1.y + v2.y };
      },

      subtract(v1, v2) {
        return { x: v1.x - v2.x, y: v1.y - v2.y };
      },

      magnitude(v) {
        return Math.sqrt(v.x * v.x + v.y * v.y);
      },

      normalize(v) {
        const mag = this.magnitude(v);
        if (mag === 0) return { x: 0, y: 0 };
        return { x: v.x / mag, y: v.y / mag };
      },

      distance(p1, p2) {
        const dx = p2.x - p1.x;
        const dy = p2.y - p1.y;
        return Math.sqrt(dx * dx + dy * dy);
      },

      applySwing(ball, swingVector) {
        const maxVelocity = 800;
        ball.velocityX = -Math.cos(swingVector.angle) * swingVector.power * maxVelocity;
        ball.velocityY = -Math.sin(swingVector.angle) * swingVector.power * maxVelocity;
        ball.isAirborne = true;
        ball.isMoving = true;
        ball.spin = swingVector.power * 0.5;
      },

      updateBall(ball, deltaTime, obstacles) {
        if (!ball.isMoving) return;

        // Apply friction (frame-rate independent: same slowdown regardless of FPS)
        const frictionFactor = Math.pow(this.friction, deltaTime * 60);
        ball.velocityX *= frictionFactor;
        ball.velocityY *= frictionFactor;

        // Update position
        ball.x += ball.velocityX * deltaTime;
        ball.y += ball.velocityY * deltaTime;

        // Check obstacle collisions
        if (obstacles) {
          this.checkObstacleCollisions(ball, obstacles);
        }

        // Stop ball if moving too slowly
        const speed = Math.sqrt(ball.velocityX * ball.velocityX + ball.velocityY * ball.velocityY);
        if (speed < this.stopThreshold) {
          ball.velocityX = 0;
          ball.velocityY = 0;
          ball.isMoving = false;
          ball.isAirborne = false;
        }

        ball.rotation += speed * deltaTime * 0.1;
        ball.distanceFromHole = this.distance(ball, ball.holePosition);
      },

      checkObstacleCollisions(ball, obstacles) {
        for (const obstacle of obstacles) {
          if (this.checkCollision(ball, obstacle)) {
            this.handleObstacleCollision(ball, obstacle);
          }
        }
      },

      checkCollision(ball, obstacle) {
        if (obstacle.shape === 'circle') {
          const dist = this.distance(ball, obstacle);
          return dist < (8 + obstacle.radius);
        } else if (obstacle.shape === 'rectangle') {
          return ball.x >= obstacle.x && ball.x <= obstacle.x + obstacle.width &&
                 ball.y >= obstacle.y && ball.y <= obstacle.y + obstacle.height;
        }
        return false;
      },

      handleObstacleCollision(ball, obstacle) {
        // Track if this is a new collision to avoid repeated sounds
        if (!ball.lastCollision || ball.lastCollision !== obstacle) {
          ball.lastCollision = obstacle;
          ball.collisionSoundPlayed = false;
        }

        if (obstacle.type === 'sand') {
          if (!ball.collisionSoundPlayed) {
            AudioManager.playLandSound('sand');
            ball.collisionSoundPlayed = true;
          }
          ball.velocityX *= 0.3;
          ball.velocityY *= 0.3;
          ball.isMoving = ball.velocityX !== 0 || ball.velocityY !== 0;
        } else if (obstacle.type === 'water') {
          if (!ball.collisionSoundPlayed) {
            AudioManager.playLandSound('water');
            ball.collisionSoundPlayed = true;
          }
          if (ball.lastSafePosition) {
            ball.x = ball.lastSafePosition.x;
            ball.y = ball.lastSafePosition.y;
            ball.velocityX = 0;
            ball.velocityY = 0;
            ball.isMoving = false;
            ball.waterPenalty = true;
          }
        } else if (obstacle.type === 'tree' || obstacle.type === 'rock') {
          if (!ball.collisionSoundPlayed) {
            AudioManager.playLandSound('grass');
            ball.collisionSoundPlayed = true;
          }
          const dx = ball.x - obstacle.x;
          const dy = ball.y - obstacle.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          const nx = dx / dist;
          const ny = dy / dist;

          ball.x = obstacle.x + nx * (obstacle.radius + 10);
          ball.y = obstacle.y + ny * (obstacle.radius + 10);

          const dotProduct = ball.velocityX * nx + ball.velocityY * ny;
          ball.velocityX = (ball.velocityX - 2 * dotProduct * nx) * 0.6;
          ball.velocityY = (ball.velocityY - 2 * dotProduct * ny) * 0.6;
        }
      },

      isBallInHole(ball) {
        if (ball.distanceFromHole >= this.holeRadius) return false;

        // Ball goes in if it's in the hole radius and moving slowly or stopped
        const speed = Math.sqrt(ball.velocityX * ball.velocityX + ball.velocityY * ball.velocityY);
        const slowEnough = speed < 50; // Ball moving slower than 50 units/second

        return slowEnough;
      }
    };

    // === Renderer Module (T009, T019, T020, T021) ===
    const Renderer = {
      canvas: null,
      ctx: null,
      backgroundCache: null,

      init(canvas) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        this.backgroundCache = document.createElement('canvas');
        this.resizeCanvas();
        window.addEventListener('resize', () => this.resizeCanvas());
      },

      resizeCanvas() {
        const dpr = window.devicePixelRatio || 1;
        const rect = this.canvas.getBoundingClientRect();

        this.canvas.width = rect.width * dpr;
        this.canvas.height = rect.height * dpr;

        this.ctx.scale(dpr, dpr);

        this.canvas.style.width = rect.width + 'px';
        this.canvas.style.height = rect.height + 'px';
      },

      renderFrame(gameState, animationTime = 0) {
        if (!gameState) return;

        this.clearCanvas();

        if (gameState.currentHole && gameState.ball) {
          this.drawCourse(gameState.currentHole, animationTime);
          if (gameState.currentHole.obstacles) {
            this.drawObstacles(gameState.currentHole.obstacles);
          }
          this.drawBall(gameState.ball);

          if (gameState.strikeFlash && gameState.strikeFlash.active) {
            this.drawStrikeFlash(gameState.ball, gameState.strikeFlash);
          }

          // Draw confetti particles
          ConfettiSystem.draw(this.ctx);

          // Draw streaker (random event)
          RandomEventManager.draw(this.ctx);
        }

        const swingPreview = InputHandler.getSwingPreview();
        if (swingPreview && gameState.ball && !gameState.ball.isMoving) {
          this.drawGuideArrow(swingPreview, gameState.ball, gameState.selectedClub);
        }
      },

      clearCanvas() {
        const rect = this.canvas.getBoundingClientRect();
        this.ctx.clearRect(0, 0, rect.width, rect.height);
      },

      clearRegion(x, y, width, height) {
        this.ctx.clearRect(x, y, width, height);
      },

      drawCourse(hole, animationTime = 0) {
        const ctx = this.ctx;

        // Stylized fairway with gradient background
        const fairwayGradient = ctx.createLinearGradient(0, 0, 0, this.canvas.height);
        fairwayGradient.addColorStop(0, '#7BC96F');
        fairwayGradient.addColorStop(0.5, '#5DBE4C');
        fairwayGradient.addColorStop(1, '#4CAF50');
        ctx.fillStyle = fairwayGradient;
        ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        // Add grass stripe pattern for cartoon effect
        ctx.fillStyle = 'rgba(255, 255, 255, 0.08)';
        for (let y = 0; y < this.canvas.height; y += 30) {
          ctx.fillRect(0, y, this.canvas.width, 15);
        }

        // Add subtle grass texture dots (using deterministic positions based on canvas size)
        ctx.fillStyle = 'rgba(34, 139, 34, 0.3)';
        for (let i = 0; i < 100; i++) {
          // Use deterministic pseudo-random based on index
          const seed1 = (i * 7919 + 1) % 997;
          const seed2 = (i * 6271 + 3) % 991;
          const x = (seed1 / 997) * this.canvas.width;
          const y = (seed2 / 991) * this.canvas.height;
          ctx.beginPath();
          ctx.arc(x, y, 2, 0, Math.PI * 2);
          ctx.fill();
        }

        // Stylized tee box - oval shape with stripes
        ctx.save();
        ctx.translate(hole.teePosition.x, hole.teePosition.y);

        // Tee box shadow
        ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
        ctx.beginPath();
        ctx.ellipse(4, 6, 55, 35, 0, 0, Math.PI * 2);
        ctx.fill();

        // Tee box base
        const teeGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, 50);
        teeGradient.addColorStop(0, '#3CB371');
        teeGradient.addColorStop(1, '#2E8B57');
        ctx.fillStyle = teeGradient;
        ctx.beginPath();
        ctx.ellipse(0, 0, 50, 30, 0, 0, Math.PI * 2);
        ctx.fill();

        // Tee box outline
        ctx.strokeStyle = '#228B22';
        ctx.lineWidth = 3;
        ctx.stroke();

        // Tee markers (cartoon style)
        ctx.fillStyle = '#FF6B6B';
        ctx.beginPath();
        ctx.arc(-20, -5, 6, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = '#CC5555';
        ctx.lineWidth = 2;
        ctx.stroke();

        ctx.fillStyle = '#FF6B6B';
        ctx.beginPath();
        ctx.arc(20, -5, 6, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();

        ctx.restore();

        // Stylized putting green with contours
        ctx.save();
        ctx.translate(hole.greenPosition.x, hole.greenPosition.y);

        // Green shadow
        ctx.fillStyle = 'rgba(0, 0, 0, 0.15)';
        ctx.beginPath();
        ctx.ellipse(5, 8, 95, 75, 0, 0, Math.PI * 2);
        ctx.fill();

        // Outer fringe
        ctx.fillStyle = '#32CD32';
        ctx.beginPath();
        ctx.ellipse(0, 0, 100, 85, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = '#228B22';
        ctx.lineWidth = 3;
        ctx.stroke();

        // Main green with gradient
        const greenGradient = ctx.createRadialGradient(-20, -20, 0, 0, 0, 80);
        greenGradient.addColorStop(0, '#90EE90');
        greenGradient.addColorStop(0.7, '#3CB371');
        greenGradient.addColorStop(1, '#2E8B57');
        ctx.fillStyle = greenGradient;
        ctx.beginPath();
        ctx.ellipse(0, 0, 85, 70, 0, 0, Math.PI * 2);
        ctx.fill();

        // Putting surface (smoothest part)
        const puttingGradient = ctx.createRadialGradient(-10, -10, 0, 0, 0, 50);
        puttingGradient.addColorStop(0, '#98FB98');
        puttingGradient.addColorStop(1, '#7CCD7C');
        ctx.fillStyle = puttingGradient;
        ctx.beginPath();
        ctx.ellipse(0, 0, 55, 45, 0, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();

        // Stylized hole
        const hx = hole.holePosition.x;
        const hy = hole.holePosition.y;

        // Hole shadow/depth
        ctx.fillStyle = '#1a1a1a';
        ctx.beginPath();
        ctx.ellipse(hx, hy + 2, 18, 14, 0, 0, Math.PI * 2);
        ctx.fill();

        // Hole opening with gradient for depth
        const holeGradient = ctx.createRadialGradient(hx, hy, 0, hx, hy, 15);
        holeGradient.addColorStop(0, '#000000');
        holeGradient.addColorStop(0.7, '#1a1a1a');
        holeGradient.addColorStop(1, '#333333');
        ctx.fillStyle = holeGradient;
        ctx.beginPath();
        ctx.ellipse(hx, hy, 15, 12, 0, 0, Math.PI * 2);
        ctx.fill();

        // Hole rim (white cup edge)
        ctx.strokeStyle = '#FFFFFF';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.ellipse(hx, hy, 15, 12, 0, 0, Math.PI * 2);
        ctx.stroke();

        // Stylized flagstick with cartoon 3D effect
        // Flagstick shadow
        ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
        ctx.lineWidth = 6;
        ctx.beginPath();
        ctx.moveTo(hx + 3, hy);
        ctx.lineTo(hx + 3, hy - 70);
        ctx.stroke();

        // Main flagstick
        const poleGradient = ctx.createLinearGradient(hx - 3, 0, hx + 3, 0);
        poleGradient.addColorStop(0, '#FFE4B5');
        poleGradient.addColorStop(0.5, '#FAFAD2');
        poleGradient.addColorStop(1, '#DAA520');
        ctx.strokeStyle = poleGradient;
        ctx.lineWidth = 5;
        ctx.lineCap = 'round';
        ctx.beginPath();
        ctx.moveTo(hx, hy);
        ctx.lineTo(hx, hy - 75);
        ctx.stroke();

        // Stylized flag with animated wave effect
        ctx.save();
        ctx.translate(hx, hy - 75);

        // Wave animation parameters
        const waveSpeed = 3; // cycles per second
        const waveAmplitude = 4; // pixels
        const wave1 = Math.sin(animationTime * waveSpeed * Math.PI * 2) * waveAmplitude;
        const wave2 = Math.sin(animationTime * waveSpeed * Math.PI * 2 + 1) * waveAmplitude;
        const wave3 = Math.sin(animationTime * waveSpeed * Math.PI * 2 + 2) * waveAmplitude;

        // Flag shadow (with wave)
        ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
        ctx.beginPath();
        ctx.moveTo(2, 2);
        ctx.quadraticCurveTo(18, 8 + wave1 * 0.5, 30 + wave2, 4 + wave1);
        ctx.quadraticCurveTo(22, 17 + wave2 * 0.5, 30 + wave3, 27 + wave2);
        ctx.quadraticCurveTo(15, 22 + wave3 * 0.5, 2, 27);
        ctx.closePath();
        ctx.fill();

        // Flag main color with gradient
        const flagGradient = ctx.createLinearGradient(0, 0, 28, 25);
        flagGradient.addColorStop(0, '#FF4757');
        flagGradient.addColorStop(0.5, '#FF6B81');
        flagGradient.addColorStop(1, '#EE3B4D');
        ctx.fillStyle = flagGradient;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.quadraticCurveTo(15, 5 + wave1 * 0.5, 28 + wave2, 2 + wave1);
        ctx.quadraticCurveTo(20, 15 + wave2 * 0.5, 28 + wave3, 25 + wave2);
        ctx.quadraticCurveTo(12, 20 + wave3 * 0.5, 0, 25);
        ctx.closePath();
        ctx.fill();

        // Flag outline
        ctx.strokeStyle = '#CC2936';
        ctx.lineWidth = 2;
        ctx.stroke();

        // Flag highlight (with wave)
        ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
        ctx.beginPath();
        ctx.moveTo(3, 3);
        ctx.quadraticCurveTo(12, 6 + wave1 * 0.3, 20 + wave2 * 0.5, 4 + wave1 * 0.5);
        ctx.quadraticCurveTo(14, 10 + wave2 * 0.3, 8, 12);
        ctx.quadraticCurveTo(5, 8, 3, 3);
        ctx.fill();

        // Ball on top of flagstick
        ctx.beginPath();
        ctx.arc(0, -3, 4, 0, Math.PI * 2);
        ctx.fillStyle = '#FFD700';
        ctx.fill();
        ctx.strokeStyle = '#DAA520';
        ctx.lineWidth = 1;
        ctx.stroke();

        ctx.restore();
      },

      drawObstacles(obstacles) {
        const ctx = this.ctx;

        for (const obstacle of obstacles) {
          if (obstacle.type === 'sand') {
            // Stylized sand bunker with organic shape
            ctx.save();
            ctx.translate(obstacle.x, obstacle.y);

            // Bunker shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
            ctx.beginPath();
            ctx.ellipse(4, 5, obstacle.radius * 1.1, obstacle.radius * 0.85, 0.1, 0, Math.PI * 2);
            ctx.fill();

            // Bunker rim (darker edge)
            ctx.fillStyle = '#C4A35A';
            ctx.beginPath();
            ctx.ellipse(0, 0, obstacle.radius * 1.05, obstacle.radius * 0.8, 0.1, 0, Math.PI * 2);
            ctx.fill();

            // Main sand with gradient
            const sandGradient = ctx.createRadialGradient(-5, -5, 0, 0, 0, obstacle.radius);
            sandGradient.addColorStop(0, '#F5DEB3');
            sandGradient.addColorStop(0.5, '#E6D5A8');
            sandGradient.addColorStop(1, '#D4B896');
            ctx.fillStyle = sandGradient;
            ctx.beginPath();
            ctx.ellipse(0, 0, obstacle.radius * 0.95, obstacle.radius * 0.7, 0.1, 0, Math.PI * 2);
            ctx.fill();

            // Sand texture - small dots (deterministic positions)
            ctx.fillStyle = 'rgba(139, 119, 101, 0.4)';
            for (let i = 0; i < 12; i++) {
              const seed = (i * 137 + Math.floor(obstacle.x)) % 100;
              const angle = (seed / 100) * Math.PI * 2;
              const dist = ((i * 73) % 70) / 100 * obstacle.radius * 0.7;
              const dotX = Math.cos(angle) * dist;
              const dotY = Math.sin(angle) * dist * 0.7;
              const dotSize = 2 + (i % 3);
              ctx.beginPath();
              ctx.arc(dotX, dotY, dotSize, 0, Math.PI * 2);
              ctx.fill();
            }

            // Highlight
            ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.beginPath();
            ctx.ellipse(-obstacle.radius * 0.3, -obstacle.radius * 0.2, obstacle.radius * 0.4, obstacle.radius * 0.25, -0.3, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();

          } else if (obstacle.type === 'water') {
            // Stylized water hazard with cartoon look
            ctx.save();

            const cx = obstacle.x + obstacle.width / 2;
            const cy = obstacle.y + obstacle.height / 2;

            // Water shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
            ctx.beginPath();
            ctx.ellipse(cx + 4, cy + 5, obstacle.width / 2 + 5, obstacle.height / 2 + 3, 0, 0, Math.PI * 2);
            ctx.fill();

            // Water base with gradient
            const waterGradient = ctx.createRadialGradient(cx - 10, cy - 10, 0, cx, cy, obstacle.width / 2);
            waterGradient.addColorStop(0, '#5BC0EB');
            waterGradient.addColorStop(0.6, '#3498DB');
            waterGradient.addColorStop(1, '#2171A5');
            ctx.fillStyle = waterGradient;
            ctx.beginPath();
            ctx.ellipse(cx, cy, obstacle.width / 2, obstacle.height / 2, 0, 0, Math.PI * 2);
            ctx.fill();

            // Water outline
            ctx.strokeStyle = '#1A5276';
            ctx.lineWidth = 3;
            ctx.stroke();

            // Cartoon sparkle/reflection
            ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
            ctx.beginPath();
            ctx.ellipse(cx - obstacle.width * 0.2, cy - obstacle.height * 0.15, obstacle.width * 0.15, obstacle.height * 0.1, -0.4, 0, Math.PI * 2);
            ctx.fill();

            // Small sparkle
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.beginPath();
            ctx.arc(cx - obstacle.width * 0.25, cy - obstacle.height * 0.2, 3, 0, Math.PI * 2);
            ctx.fill();

            // Ripple lines
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.ellipse(cx + 5, cy + 5, obstacle.width * 0.25, obstacle.height * 0.15, 0, 0, Math.PI * 2);
            ctx.stroke();

            ctx.restore();

          } else if (obstacle.type === 'tree') {
            // Stylized cartoon tree
            ctx.save();
            ctx.translate(obstacle.x, obstacle.y);

            const r = obstacle.radius;

            // Tree shadow on ground
            ctx.fillStyle = 'rgba(0, 0, 0, 0.25)';
            ctx.beginPath();
            ctx.ellipse(8, 15, r * 0.8, r * 0.3, 0, 0, Math.PI * 2);
            ctx.fill();

            // Trunk shadow
            ctx.fillStyle = '#5D4037';
            ctx.beginPath();
            ctx.moveTo(8, 5);
            ctx.lineTo(12, 30);
            ctx.lineTo(4, 30);
            ctx.closePath();
            ctx.fill();

            // Main trunk with gradient
            const trunkGradient = ctx.createLinearGradient(-8, 0, 8, 0);
            trunkGradient.addColorStop(0, '#8B5A2B');
            trunkGradient.addColorStop(0.3, '#A0522D');
            trunkGradient.addColorStop(0.7, '#8B4513');
            trunkGradient.addColorStop(1, '#654321');
            ctx.fillStyle = trunkGradient;
            ctx.beginPath();
            ctx.moveTo(-6, 0);
            ctx.lineTo(-10, 28);
            ctx.lineTo(10, 28);
            ctx.lineTo(6, 0);
            ctx.closePath();
            ctx.fill();

            // Trunk outline
            ctx.strokeStyle = '#3E2723';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Trunk detail lines
            ctx.strokeStyle = 'rgba(62, 39, 35, 0.5)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(-2, 5);
            ctx.lineTo(-3, 25);
            ctx.moveTo(3, 8);
            ctx.lineTo(4, 22);
            ctx.stroke();

            // Foliage layers (back to front for depth)
            // Back layer
            const foliageGradient1 = ctx.createRadialGradient(-5, -r - 5, 0, 0, -r / 2, r * 1.2);
            foliageGradient1.addColorStop(0, '#43A047');
            foliageGradient1.addColorStop(1, '#1B5E20');
            ctx.fillStyle = foliageGradient1;
            ctx.beginPath();
            ctx.arc(-8, -r * 0.6, r * 0.7, 0, Math.PI * 2);
            ctx.fill();

            ctx.beginPath();
            ctx.arc(10, -r * 0.5, r * 0.65, 0, Math.PI * 2);
            ctx.fill();

            // Middle layer
            const foliageGradient2 = ctx.createRadialGradient(-3, -r - 3, 0, 0, -r / 2, r);
            foliageGradient2.addColorStop(0, '#66BB6A');
            foliageGradient2.addColorStop(1, '#2E7D32');
            ctx.fillStyle = foliageGradient2;
            ctx.beginPath();
            ctx.arc(0, -r * 0.8, r * 0.85, 0, Math.PI * 2);
            ctx.fill();

            // Front layer (brightest)
            const foliageGradient3 = ctx.createRadialGradient(-5, -r - 8, 0, 0, -r * 0.7, r * 0.7);
            foliageGradient3.addColorStop(0, '#81C784');
            foliageGradient3.addColorStop(1, '#4CAF50');
            ctx.fillStyle = foliageGradient3;
            ctx.beginPath();
            ctx.arc(-3, -r, r * 0.6, 0, Math.PI * 2);
            ctx.fill();

            // Foliage outline
            ctx.strokeStyle = '#1B5E20';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(0, -r * 0.8, r * 0.85, 0, Math.PI * 2);
            ctx.stroke();

            // Highlight spots
            ctx.fillStyle = 'rgba(255, 255, 255, 0.25)';
            ctx.beginPath();
            ctx.arc(-r * 0.3, -r * 1.1, r * 0.2, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();

          } else if (obstacle.type === 'rock') {
            // Stylized cartoon rock
            ctx.save();
            ctx.translate(obstacle.x, obstacle.y);

            const r = obstacle.radius;

            // Rock shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.beginPath();
            ctx.ellipse(5, r * 0.8, r * 0.9, r * 0.35, 0, 0, Math.PI * 2);
            ctx.fill();

            // Main rock shape (irregular polygon for cartoon look)
            const rockGradient = ctx.createRadialGradient(-r * 0.3, -r * 0.3, 0, 0, 0, r * 1.2);
            rockGradient.addColorStop(0, '#9E9E9E');
            rockGradient.addColorStop(0.5, '#757575');
            rockGradient.addColorStop(1, '#424242');
            ctx.fillStyle = rockGradient;

            ctx.beginPath();
            ctx.moveTo(-r * 0.8, r * 0.3);
            ctx.lineTo(-r * 0.9, -r * 0.2);
            ctx.lineTo(-r * 0.5, -r * 0.7);
            ctx.lineTo(r * 0.1, -r * 0.8);
            ctx.lineTo(r * 0.7, -r * 0.5);
            ctx.lineTo(r * 0.9, r * 0.1);
            ctx.lineTo(r * 0.6, r * 0.6);
            ctx.lineTo(-r * 0.2, r * 0.7);
            ctx.closePath();
            ctx.fill();

            // Rock outline
            ctx.strokeStyle = '#212121';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Rock highlight
            ctx.fillStyle = 'rgba(255, 255, 255, 0.35)';
            ctx.beginPath();
            ctx.moveTo(-r * 0.5, -r * 0.4);
            ctx.lineTo(-r * 0.2, -r * 0.6);
            ctx.lineTo(r * 0.2, -r * 0.5);
            ctx.lineTo(r * 0.1, -r * 0.2);
            ctx.lineTo(-r * 0.3, -r * 0.1);
            ctx.closePath();
            ctx.fill();

            // Crack details
            ctx.strokeStyle = 'rgba(33, 33, 33, 0.5)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(-r * 0.2, -r * 0.3);
            ctx.lineTo(r * 0.1, r * 0.2);
            ctx.lineTo(r * 0.3, r * 0.1);
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(r * 0.3, -r * 0.3);
            ctx.lineTo(r * 0.4, r * 0.1);
            ctx.stroke();

            ctx.restore();
          }
        }
      },

      drawBall(ball) {
        const ctx = this.ctx;
        const colors = BallColors[ball.color] || BallColors.white;

        // Calculate shadow properties based on airborne state
        const baseHeight = ball.isAirborne ? 1.5 : 0;
        const heightFactor = baseHeight + (ball.isAirborne ? Math.abs(ball.velocityY || 0) / 400 : 0);
        const shadowOffset = 4 + heightFactor * 3;
        const shadowScale = 1 + heightFactor * 0.5;
        const shadowOpacity = Math.max(0.1, 0.35 - heightFactor * 0.1);

        if (ball.inHole && ball.holeProgress !== undefined) {
          const fadeProgress = ball.holeProgress;
          if (fadeProgress >= 1) return;

          // Draw shadow (fading with ball)
          ctx.save();
          ctx.globalAlpha = (1 - fadeProgress) * shadowOpacity;
          ctx.fillStyle = 'rgba(0, 0, 0, 1)';
          ctx.beginPath();
          ctx.ellipse(ball.x + shadowOffset, ball.y + shadowOffset, 8 * shadowScale, 5 * shadowScale, 0, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();

          ctx.save();
          ctx.globalAlpha = 1 - fadeProgress;
          ctx.translate(ball.x, ball.y);
          ctx.rotate(ball.rotation);

          const scale = 1 - (fadeProgress * 0.5);
          ctx.scale(scale, scale);

          const gradient = ctx.createRadialGradient(-2, -2, 0, 0, 0, 8);
          gradient.addColorStop(0, colors.highlight);
          gradient.addColorStop(1, colors.base);

          ctx.fillStyle = gradient;
          ctx.beginPath();
          ctx.arc(0, 0, 8, 0, Math.PI * 2);
          ctx.fill();

          ctx.strokeStyle = colors.stroke;
          ctx.lineWidth = 0.5;
          ctx.stroke();

          ctx.restore();
          return;
        }

        // Draw ball shadow (ellipse offset to bottom-right for 3D effect)
        ctx.save();
        ctx.globalAlpha = shadowOpacity;
        ctx.fillStyle = 'rgba(0, 0, 0, 1)';
        ctx.beginPath();
        ctx.ellipse(ball.x + shadowOffset, ball.y + shadowOffset, 8 * shadowScale, 5 * shadowScale, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();

        // Draw ball
        ctx.save();
        ctx.translate(ball.x, ball.y);
        ctx.rotate(ball.rotation);

        const gradient = ctx.createRadialGradient(-2, -2, 0, 0, 0, 8);
        gradient.addColorStop(0, colors.highlight);
        gradient.addColorStop(1, colors.base);

        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(0, 0, 8, 0, Math.PI * 2);
        ctx.fill();

        ctx.strokeStyle = colors.stroke;
        ctx.lineWidth = 0.5;
        ctx.stroke();

        ctx.restore();
      },

      drawGuideArrow(swingPreview, ball, selectedClub) {
        const ctx = this.ctx;
        const dx = swingPreview.current.x - swingPreview.start.x;
        const dy = swingPreview.current.y - swingPreview.start.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        const swingPower = Math.min(distance / 150, 1.0); // User's swing 0-100%

        const club = ClubSystem.getClub(selectedClub || 'driver');
        const effectivePower = swingPower * club.maxPower; // Actual ball power

        const arrowLength = effectivePower * 150;
        const angle = Math.atan2(dy, dx) + Math.PI;

        const endX = ball.x + Math.cos(angle) * arrowLength;
        const endY = ball.y + Math.sin(angle) * arrowLength;

        // Color based on user's swing power (0-100%), not club-adjusted power
        const arrowColor = swingPower > 0.8 ? [255, 100, 0] :
                          swingPower > 0.5 ? [255, 200, 0] : [100, 200, 255];

        ctx.strokeStyle = `rgba(${arrowColor[0]}, ${arrowColor[1]}, ${arrowColor[2]}, ${0.4 + effectivePower * 0.4})`;
        ctx.lineWidth = 3 + effectivePower * 5;
        ctx.setLineDash([5, 5]);

        ctx.beginPath();
        ctx.moveTo(ball.x, ball.y);
        ctx.lineTo(endX, endY);
        ctx.stroke();

        ctx.setLineDash([]);

        const arrowSize = 12 + effectivePower * 12;
        ctx.fillStyle = `rgba(${arrowColor[0]}, ${arrowColor[1]}, ${arrowColor[2]}, ${0.6 + effectivePower * 0.4})`;
        ctx.beginPath();
        ctx.moveTo(endX, endY);
        ctx.lineTo(
          endX - arrowSize * Math.cos(angle - Math.PI / 6),
          endY - arrowSize * Math.sin(angle - Math.PI / 6)
        );
        ctx.lineTo(
          endX - arrowSize * Math.cos(angle + Math.PI / 6),
          endY - arrowSize * Math.sin(angle + Math.PI / 6)
        );
        ctx.closePath();
        ctx.fill();

        ctx.font = 'bold 16px Arial';
        ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
        ctx.fillText(`Power: ${Math.round(swingPower * 100)}%`, ball.x + 15, ball.y - 15);
        ctx.fillText(`${club.name}`, ball.x + 15, ball.y - 35);

        const powerBarWidth = 100;
        const powerBarHeight = 10;
        const powerBarX = ball.x - powerBarWidth / 2;
        const powerBarY = ball.y - 55;

        ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
        ctx.fillRect(powerBarX, powerBarY, powerBarWidth, powerBarHeight);

        ctx.fillStyle = `rgba(${arrowColor[0]}, ${arrowColor[1]}, ${arrowColor[2]}, 0.8)`;
        ctx.fillRect(powerBarX, powerBarY, powerBarWidth * swingPower, powerBarHeight);

        ctx.strokeStyle = 'rgba(0, 0, 0, 0.6)';
        ctx.lineWidth = 2;
        ctx.strokeRect(powerBarX, powerBarY, powerBarWidth, powerBarHeight);
      },

      drawStrikeFlash(ball, strikeFlash) {
        const ctx = this.ctx;
        const progress = strikeFlash.progress;
        const alpha = 1 - progress;
        const radius = 15 + progress * 20;

        ctx.save();
        ctx.globalAlpha = alpha * 0.6;

        const gradient = ctx.createRadialGradient(ball.x, ball.y, 0, ball.x, ball.y, radius);
        gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
        gradient.addColorStop(0.5, 'rgba(255, 200, 0, 0.8)');
        gradient.addColorStop(1, 'rgba(255, 100, 0, 0)');

        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(ball.x, ball.y, radius, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();
      }
    };

    // === InputHandler Module (T010 + Mouse Support) ===
    const InputHandler = {
      canvas: null,
      gameEngine: null,
      touchStartPos: null,
      currentTouchPos: null,
      isSwinging: false,

      init(canvas, gameEngine) {
        this.canvas = canvas;
        this.gameEngine = gameEngine;

        canvas.addEventListener('touchstart', (e) => this.onTouchStart(e), { passive: false });
        canvas.addEventListener('touchmove', (e) => this.onTouchMove(e), { passive: false });
        canvas.addEventListener('touchend', (e) => this.onTouchEnd(e), { passive: false });

        canvas.addEventListener('mousedown', (e) => this.onMouseDown(e));
        canvas.addEventListener('mousemove', (e) => this.onMouseMove(e));
        canvas.addEventListener('mouseup', (e) => this.onMouseUp(e));

        const resetBtn = document.getElementById('reset-shot-btn');
        resetBtn.addEventListener('click', () => this.resetShot());
      },

      resetShot() {
        this.touchStartPos = null;
        this.currentTouchPos = null;
        this.isSwinging = false;
        document.getElementById('reset-shot-btn').classList.add('hidden');
      },

      onTouchStart(e) {
        e.preventDefault();
        if (this.gameEngine && this.gameEngine.gameState && this.gameEngine.gameState.ball && this.gameEngine.gameState.ball.isMoving) {
          return;
        }
        const touch = e.touches[0];
        const rect = this.canvas.getBoundingClientRect();
        this.touchStartPos = {
          x: touch.clientX - rect.left,
          y: touch.clientY - rect.top
        };
        this.isSwinging = true;
      },

      onTouchMove(e) {
        e.preventDefault();
        if (!this.isSwinging) return;

        const touch = e.touches[0];
        const rect = this.canvas.getBoundingClientRect();
        this.currentTouchPos = {
          x: touch.clientX - rect.left,
          y: touch.clientY - rect.top
        };

        document.getElementById('reset-shot-btn').classList.remove('hidden');
      },

      onTouchEnd(e) {
        e.preventDefault();
        if (!this.isSwinging) return;

        document.getElementById('reset-shot-btn').classList.add('hidden');

        const swingVector = this.calculateSwingVector();
        if (swingVector && this.gameEngine) {
          this.gameEngine.executeSwing(swingVector);
        }

        this.touchStartPos = null;
        this.currentTouchPos = null;
        this.isSwinging = false;
      },

      onMouseDown(e) {
        if (this.gameEngine && this.gameEngine.gameState && this.gameEngine.gameState.ball && this.gameEngine.gameState.ball.isMoving) {
          return;
        }
        const rect = this.canvas.getBoundingClientRect();
        this.touchStartPos = {
          x: e.clientX - rect.left,
          y: e.clientY - rect.top
        };
        this.isSwinging = true;
      },

      onMouseMove(e) {
        if (!this.isSwinging) return;

        const rect = this.canvas.getBoundingClientRect();
        this.currentTouchPos = {
          x: e.clientX - rect.left,
          y: e.clientY - rect.top
        };

        document.getElementById('reset-shot-btn').classList.remove('hidden');
      },

      onMouseUp(e) {
        if (!this.isSwinging) return;

        document.getElementById('reset-shot-btn').classList.add('hidden');

        const swingVector = this.calculateSwingVector();
        if (swingVector && this.gameEngine) {
          this.gameEngine.executeSwing(swingVector);
        }

        this.touchStartPos = null;
        this.currentTouchPos = null;
        this.isSwinging = false;
      },

      calculateSwingVector() {
        if (!this.touchStartPos || !this.currentTouchPos) return null;

        const dx = this.currentTouchPos.x - this.touchStartPos.x;
        const dy = this.currentTouchPos.y - this.touchStartPos.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        const angle = Math.atan2(dy, dx);

        return {
          power: Math.min(distance / 150, 1.0),
          angle: angle
        };
      },

      getSwingPreview() {
        return this.currentTouchPos && this.touchStartPos ? {
          start: this.touchStartPos,
          current: this.currentTouchPos
        } : null;
      }
    };

    // === CourseGenerator Module (T026-T029) ===
    const CourseGenerator = {
      holeTemplates: null,
      rng: null,

      init(seed) {
        this.rng = new SeededRandom(seed);
        this.holeTemplates = this.defineHoleTemplates();
      },

      defineHoleTemplates() {
        return [
          { holeNumber: 1, par: 3, length: 'short', distance: 525 },
          { holeNumber: 2, par: 4, length: 'medium', distance: 788 },
          { holeNumber: 3, par: 3, length: 'short', distance: 438 },
          { holeNumber: 4, par: 5, length: 'long', distance: 1050 },
          { holeNumber: 5, par: 4, length: 'medium', distance: 700 },
          { holeNumber: 6, par: 4, length: 'medium', distance: 875 },
          { holeNumber: 7, par: 3, length: 'short', distance: 490 },
          { holeNumber: 8, par: 5, length: 'long', distance: 1138 },
          { holeNumber: 9, par: 4, length: 'medium', distance: 840 }
        ];
      },

      generateHole(holeNumber, canvasWidth, canvasHeight) {
        const template = this.holeTemplates[holeNumber - 1];

        const teeX = 100;
        const teeY = canvasHeight / 2 + this.rng.nextInt(-50, 50);

        const greenX = Math.min(teeX + template.distance, canvasWidth - 150);
        const greenY = canvasHeight / 2 + this.rng.nextInt(-100, 100);

        const hole = {
          holeNumber: template.holeNumber,
          par: template.par,
          length: template.length,
          teePosition: { x: teeX, y: teeY },
          greenPosition: { x: greenX, y: greenY },
          holePosition: { x: greenX, y: greenY },
          obstacles: this.placeObstacles(template, teeX, teeY, greenX, greenY, canvasWidth, canvasHeight)
        };

        return hole;
      },

      placeObstacles(template, teeX, teeY, greenX, greenY, canvasWidth, canvasHeight) {
        const obstacles = [];

        // Calculate fairway direction and perpendicular
        const fairwayDx = greenX - teeX;
        const fairwayDy = greenY - teeY;
        const fairwayLength = Math.sqrt(fairwayDx * fairwayDx + fairwayDy * fairwayDy);
        const fairwayNormX = fairwayDx / fairwayLength;
        const fairwayNormY = fairwayDy / fairwayLength;

        // Perpendicular direction (for placing obstacles to sides of fairway)
        const perpX = -fairwayNormY;
        const perpY = fairwayNormX;

        // Helper to check if position overlaps existing obstacles
        const overlapsExisting = (x, y, radius) => {
          for (const obs of obstacles) {
            const obsRadius = obs.shape === 'rectangle'
              ? Math.max(obs.width, obs.height) / 2 + 10
              : obs.radius + 10;
            const dist = Math.sqrt((x - obs.x) ** 2 + (y - obs.y) ** 2);
            const minDist = radius + obsRadius + 15; // 15px buffer between obstacles
            if (dist < minDist) return true;
          }
          return false;
        };

        // Helper to check if position is valid (not too close to tee/green, on screen)
        const isValidPosition = (x, y, radius) => {
          const distFromTee = Math.sqrt((x - teeX) ** 2 + (y - teeY) ** 2);
          const distFromGreen = Math.sqrt((x - greenX) ** 2 + (y - greenY) ** 2);
          const margin = 50;
          return distFromTee > 80 &&
                 distFromGreen > 100 &&
                 x > margin && x < canvasWidth - margin &&
                 y > margin && y < canvasHeight - margin;
        };

        // Helper to try placing an obstacle of a specific type
        const tryPlaceObstacle = (type, minDist, maxDist, sideOnly, closerToCenter) => {
          for (let attempt = 0; attempt < 20; attempt++) {
            const distAlongFairway = minDist + this.rng.next() * (maxDist - minDist);
            const baseX = teeX + fairwayDx * distAlongFairway;
            const baseY = teeY + fairwayDy * distAlongFairway;

            let perpOffset;
            if (sideOnly) {
              perpOffset = (this.rng.next() < 0.5 ? -1 : 1) * (60 + this.rng.nextInt(0, 80));
            } else if (closerToCenter) {
              // Place closer to the fairway center line for more challenge
              perpOffset = this.rng.nextInt(-70, 70);
            } else {
              perpOffset = this.rng.nextInt(-100, 100);
            }

            const x = baseX + perpX * perpOffset;
            const y = baseY + perpY * perpOffset;

            let radius, width, height, shape;
            if (type === 'water') {
              width = this.rng.nextInt(80, 110);
              height = this.rng.nextInt(50, 70);
              radius = Math.max(width, height) / 2;
              shape = 'rectangle';
            } else if (type === 'sand') {
              radius = this.rng.nextInt(30, 42);
              width = 0;
              height = 0;
              shape = 'circle';
            } else if (type === 'tree') {
              radius = this.rng.nextInt(24, 32);
              width = 0;
              height = 0;
              shape = 'circle';
            } else { // rock
              radius = this.rng.nextInt(16, 26);
              width = 0;
              height = 0;
              shape = 'circle';
            }

            if (isValidPosition(x, y, radius) && !overlapsExisting(x, y, radius)) {
              obstacles.push({ type, x, y, radius, width, height, shape });
              return true;
            }
          }
          return false;
        };

        // === GUARANTEED MINIMUM OBSTACLES ===

        // 2 trees minimum - one on each side of fairway in early-mid section
        tryPlaceObstacle('tree', 0.25, 0.45, true, false);  // Left or right side
        tryPlaceObstacle('tree', 0.35, 0.55, true, false);  // Other side

        // 2-3 rocks minimum - scattered along fairway
        tryPlaceObstacle('rock', 0.20, 0.40, false, false);
        tryPlaceObstacle('rock', 0.45, 0.65, false, true);  // Mid fairway, closer to center
        if (this.rng.next() < 0.6) {
          tryPlaceObstacle('rock', 0.55, 0.75, false, false);
        }

        // 1 sand bunker minimum - near the green approach
        tryPlaceObstacle('sand', 0.65, 0.85, false, true);  // Closer to center for challenge

        // === ADDITIONAL RANDOM OBSTACLES FOR DIFFICULTY ===

        // Extra obstacles based on hole length
        const extraCount = template.length === 'short' ? this.rng.nextInt(1, 2) :
                          template.length === 'medium' ? this.rng.nextInt(2, 3) :
                          this.rng.nextInt(2, 4);

        for (let i = 0; i < extraCount; i++) {
          const rand = this.rng.next();
          let type, minD, maxD, side, center;

          if (rand < 0.25) {
            // Extra tree
            type = 'tree';
            minD = 0.30;
            maxD = 0.70;
            side = this.rng.next() < 0.5;
            center = false;
          } else if (rand < 0.45) {
            // Extra rock in play area
            type = 'rock';
            minD = 0.35;
            maxD = 0.75;
            side = false;
            center = true;  // More challenging - in the way!
          } else if (rand < 0.70) {
            // Extra sand bunker
            type = 'sand';
            minD = 0.50;
            maxD = 0.80;
            side = false;
            center = this.rng.next() < 0.6;
          } else {
            // Water hazard - dangerous!
            type = 'water';
            minD = 0.40;
            maxD = 0.65;
            side = false;
            center = this.rng.next() < 0.4;  // Sometimes in the way
          }

          tryPlaceObstacle(type, minD, maxD, side, center);
        }

        // Sort obstacles for proper draw order (water first, then sand, then trees/rocks)
        const typeOrder = { water: 0, sand: 1, rock: 2, tree: 3 };
        obstacles.sort((a, b) => typeOrder[a.type] - typeOrder[b.type]);

        return obstacles;
      }
    };

    // === ScoreKeeper Module (T022, T033, T057-T063) ===
    const ScoreKeeper = {
      recordStroke(round) {
        round.currentStrokeCount++;
        this.updateUI(round);
      },

      getCurrentStrokes(round) {
        return round.currentStrokeCount;
      },

      completeHole(round, hole) {
        const holeScore = {
          holeNumber: hole.holeNumber,
          strokes: round.currentStrokeCount,
          par: hole.par,
          scoreRelativeToPar: round.currentStrokeCount - hole.par
        };

        round.holeScores.push(holeScore);
        round.totalStrokes += round.currentStrokeCount;
        round.totalPar += hole.par;
        round.scoreRelativeToPar = round.totalStrokes - round.totalPar;

        return holeScore;
      },

      getRoundSummary(round) {
        return {
          totalStrokes: round.totalStrokes,
          totalPar: round.totalPar,
          scoreRelativeToPar: round.scoreRelativeToPar,
          holeScores: round.holeScores,
          completedHoles: round.holeScores.length,
          remainingHoles: 9 - round.holeScores.length
        };
      },

      updateUI(round) {
        document.getElementById('stroke-count').textContent = round.currentStrokeCount;
        document.getElementById('total-score').textContent = this.getScoreDisplay(round.scoreRelativeToPar);
      },

      getScoreDisplay(score) {
        if (score === 0) return 'E';
        if (score > 0) return `+${score}`;
        return `${score}`;
      },

      getScoreColor(scoreRelativeToPar) {
        if (scoreRelativeToPar <= -2) return '#FFD700';
        if (scoreRelativeToPar === -1) return '#4CAF50';
        if (scoreRelativeToPar === 0) return '#2196F3';
        if (scoreRelativeToPar === 1) return '#FF9800';
        return '#F44336';
      },

      getScoreName(scoreRelativeToPar) {
        if (scoreRelativeToPar <= -3) return 'Albatross!';
        if (scoreRelativeToPar === -2) return 'Eagle!';
        if (scoreRelativeToPar === -1) return 'Birdie!';
        if (scoreRelativeToPar === 0) return 'Par';
        if (scoreRelativeToPar === 1) return 'Bogey';
        if (scoreRelativeToPar === 2) return 'Double Bogey';
        return `+${scoreRelativeToPar}`;
      }
    };

    // === ClubSystem Module (T039-T043, T048-T049) ===
    const ClubSystem = {
      clubs: {
        driver: { id: 'driver', name: 'Driver', maxPower: 1.0, arcMultiplier: 1.0, spinMultiplier: 1.0 },
        wood3: { id: 'wood3', name: '3 Wood', maxPower: 0.9, arcMultiplier: 0.95, spinMultiplier: 0.95 },
        wood5: { id: 'wood5', name: '5 Wood', maxPower: 0.85, arcMultiplier: 0.9, spinMultiplier: 0.9 },
        iron4: { id: 'iron4', name: '4 Iron', maxPower: 0.8, arcMultiplier: 0.85, spinMultiplier: 1.1 },
        iron5: { id: 'iron5', name: '5 Iron', maxPower: 0.75, arcMultiplier: 0.8, spinMultiplier: 1.15 },
        iron6: { id: 'iron6', name: '6 Iron', maxPower: 0.7, arcMultiplier: 0.75, spinMultiplier: 1.2 },
        iron7: { id: 'iron7', name: '7 Iron', maxPower: 0.65, arcMultiplier: 0.7, spinMultiplier: 1.25 },
        iron8: { id: 'iron8', name: '8 Iron', maxPower: 0.6, arcMultiplier: 0.65, spinMultiplier: 1.3 },
        iron9: { id: 'iron9', name: '9 Iron', maxPower: 0.55, arcMultiplier: 0.6, spinMultiplier: 1.35 },
        wedge: { id: 'wedge', name: 'Wedge', maxPower: 0.5, arcMultiplier: 0.55, spinMultiplier: 1.5 },
        putter: { id: 'putter', name: 'Putter', maxPower: 0.3, arcMultiplier: 0.0, spinMultiplier: 0.0 }
      },

      getClub(clubId) {
        return this.clubs[clubId] || this.clubs.driver;
      },

      getAllClubs() {
        return Object.values(this.clubs);
      },

      getAvailableClubs(isFirstStroke) {
        if (isFirstStroke) {
          return [this.clubs.driver];
        }
        return this.getAllClubs();
      },

      applyClubToSwing(swingVector, clubId) {
        const club = this.getClub(clubId);
        return {
          power: swingVector.power * club.maxPower,
          angle: swingVector.angle,
          arc: club.arcMultiplier,
          spin: club.spinMultiplier
        };
      },

      getRecommendedClub(ball, holePosition) {
        // Convert pixel distance to yards (same conversion as getMaxDistance)
        const pixelDistance = PhysicsEngine.distance(ball, holePosition);
        const distanceYards = pixelDistance * 1.09361;

        // Get all clubs sorted by max distance (shortest first)
        const allClubs = ['putter', 'wedge', 'iron9', 'iron8', 'iron7', 'iron6', 'iron5', 'iron4', '5wood', '3wood', 'driver'];

        // Find the club with the shortest max distance that can still reach the hole
        let bestClub = 'driver'; // Default to driver if nothing else works

        for (const clubId of allClubs) {
          const maxDistance = this.getMaxDistance(clubId);
          if (maxDistance >= distanceYards) {
            bestClub = clubId;
            break; // Found the shortest club that can reach
          }
        }

        return bestClub;
      },

      // Calculate max distance for a club at 100% power (in yards)
      getMaxDistance(clubId) {
        const club = this.getClub(clubId);
        const maxVelocity = 800;
        const friction = 0.98;
        const stopThreshold = 5;
        const deltaTime = 1/60; // 60 FPS

        // Simulate ball flight
        let velocityX = maxVelocity * club.maxPower;
        let distance = 0;

        while (Math.abs(velocityX) > stopThreshold) {
          distance += velocityX * deltaTime;
          velocityX *= friction;
        }

        // Convert meters to yards (1m = 1.09361yd)
        return Math.round(distance * 1.09361);
      }
    };

    // === StorageManager Module (T064-T073) ===
    const StorageManager = {
      dbName: 'CartoonGolfDB',
      dbVersion: 1,
      storeName: 'gameStates',
      db: null,

      async init() {
        return new Promise((resolve, reject) => {
          const request = indexedDB.open(this.dbName, this.dbVersion);

          request.onerror = () => {
            console.error('IndexedDB error:', request.error);
            reject(request.error);
          };

          request.onsuccess = () => {
            this.db = request.result;
            resolve(this.db);
          };

          request.onupgradeneeded = (event) => {
            const db = event.target.result;

            if (!db.objectStoreNames.contains(this.storeName)) {
              const objectStore = db.createObjectStore(this.storeName, { keyPath: 'id' });
              objectStore.createIndex('timestamp', 'timestamp', { unique: false });
            }
          };
        });
      },

      async saveGameState(gameState) {
        try {
          if (!this.db) {
            await this.init();
          }

          const stateToSave = {
            id: 'current-game',
            timestamp: Date.now(),
            gameState: {
              currentHole: gameState.currentHole,
              round: gameState.round,
              ball: {
                x: gameState.ball.x,
                y: gameState.ball.y,
                velocityX: gameState.ball.velocityX,
                velocityY: gameState.ball.velocityY,
                spin: gameState.ball.spin,
                isAirborne: gameState.ball.isAirborne,
                isMoving: gameState.ball.isMoving,
                rotation: gameState.ball.rotation,
                groundY: gameState.ball.groundY,
                holePosition: gameState.ball.holePosition,
                distanceFromHole: gameState.ball.distanceFromHole,
                lastSafePosition: gameState.ball.lastSafePosition,
                waterPenalty: gameState.ball.waterPenalty,
                color: gameState.ball.color
              },
              selectedClub: gameState.selectedClub,
              seed: gameState.seed,
              ballColor: gameState.ballColor
            }
          };

          const transaction = this.db.transaction([this.storeName], 'readwrite');
          const objectStore = transaction.objectStore(this.storeName);
          const request = objectStore.put(stateToSave);

          return new Promise((resolve, reject) => {
            request.onsuccess = () => resolve(true);
            request.onerror = () => {
              console.error('Save error:', request.error);
              reject(request.error);
            };
          });
        } catch (error) {
          console.error('Failed to save game state:', error);
          return false;
        }
      },

      async loadGameState() {
        try {
          if (!this.db) {
            await this.init();
          }

          const transaction = this.db.transaction([this.storeName], 'readonly');
          const objectStore = transaction.objectStore(this.storeName);
          const request = objectStore.get('current-game');

          return new Promise((resolve, reject) => {
            request.onsuccess = () => {
              if (request.result) {
                resolve(request.result.gameState);
              } else {
                resolve(null);
              }
            };
            request.onerror = () => {
              console.error('Load error:', request.error);
              reject(request.error);
            };
          });
        } catch (error) {
          console.error('Failed to load game state:', error);
          return null;
        }
      },

      async clearGameState() {
        try {
          if (!this.db) {
            await this.init();
          }

          const transaction = this.db.transaction([this.storeName], 'readwrite');
          const objectStore = transaction.objectStore(this.storeName);
          const request = objectStore.delete('current-game');

          return new Promise((resolve, reject) => {
            request.onsuccess = () => resolve(true);
            request.onerror = () => {
              console.error('Clear error:', request.error);
              reject(request.error);
            };
          });
        } catch (error) {
          console.error('Failed to clear game state:', error);
          return false;
        }
      },

      async hasSavedGame() {
        try {
          const savedState = await this.loadGameState();
          return savedState !== null && !savedState.round.isComplete;
        } catch (error) {
          console.error('Error checking for saved game:', error);
          return false;
        }
      },

      saveSettings(settings) {
        try {
          localStorage.setItem('golf-settings', JSON.stringify(settings));
          return true;
        } catch (error) {
          console.error('Failed to save settings:', error);
          return false;
        }
      },

      loadSettings() {
        try {
          const settings = localStorage.getItem('golf-settings');
          return settings ? JSON.parse(settings) : this.getDefaultSettings();
        } catch (error) {
          console.error('Failed to load settings:', error);
          return this.getDefaultSettings();
        }
      },

      getDefaultSettings() {
        return {
          soundEnabled: true,
          debugMode: false,
          tutorialCompleted: false
        };
      },

      // === Leaderboard Methods (T074-T076) ===
      async addLeaderboardEntry(entry) {
        try {
          if (!this.db) {
            await this.init();
          }

          const leaderboard = await this.getLeaderboard();

          // Add new entry
          leaderboard.push({
            scoreRelativeToPar: entry.scoreRelativeToPar,
            totalStrokes: entry.totalStrokes,
            completedAt: entry.completedAt || Date.now(),
            playerInitials: entry.playerInitials || 'YOU'
          });

          // Sort by score (lower is better)
          leaderboard.sort((a, b) => a.scoreRelativeToPar - b.scoreRelativeToPar);

          // Keep only top 10
          const top10 = leaderboard.slice(0, 10);

          // Save to IndexedDB
          const transaction = this.db.transaction([this.storeName], 'readwrite');
          const objectStore = transaction.objectStore(this.storeName);
          const request = objectStore.put({
            id: 'leaderboard',
            entries: top10,
            timestamp: Date.now()
          });

          return new Promise((resolve, reject) => {
            request.onsuccess = () => resolve(top10);
            request.onerror = () => {
              console.error('Leaderboard save error:', request.error);
              reject(request.error);
            };
          });
        } catch (error) {
          console.error('Failed to add leaderboard entry:', error);
          return [];
        }
      },

      async getLeaderboard() {
        try {
          if (!this.db) {
            await this.init();
          }

          const transaction = this.db.transaction([this.storeName], 'readonly');
          const objectStore = transaction.objectStore(this.storeName);
          const request = objectStore.get('leaderboard');

          return new Promise((resolve, reject) => {
            request.onsuccess = () => {
              if (request.result && request.result.entries) {
                resolve(request.result.entries);
              } else {
                resolve([]);
              }
            };
            request.onerror = () => {
              console.error('Leaderboard load error:', request.error);
              reject(request.error);
            };
          });
        } catch (error) {
          console.error('Failed to load leaderboard:', error);
          return [];
        }
      }
    };

    // === AudioManager Module (T073f, T073g) ===
    const AudioManager = {
      context: null,
      sounds: {},
      muted: false,

      init() {
        try {
          this.context = new (window.AudioContext || window.webkitAudioContext)();
          this.muted = StorageManager.loadSettings().soundEnabled === false;
        } catch (error) {
          console.error('Web Audio API not supported:', error);
        }
      },

      unlock() {
        if (!this.context) return;

        if (this.context.state === 'suspended') {
          this.context.resume();
        }

        const buffer = this.context.createBuffer(1, 1, 22050);
        const source = this.context.createBufferSource();
        source.buffer = buffer;
        source.connect(this.context.destination);
        source.start(0);
      },

      // === T096: Enhanced club hit sounds ===
      playHitSound(power) {
        if (this.muted || !this.context) return;

        const oscillator = this.context.createOscillator();
        const gainNode = this.context.createGain();

        oscillator.connect(gainNode);
        gainNode.connect(this.context.destination);

        // Soft, medium, hard hit sounds based on power
        let frequency, volume, duration;
        if (power < 0.3) {
          frequency = 180;
          volume = 0.08;
          duration = 0.04;
        } else if (power < 0.6) {
          frequency = 280;
          volume = 0.15;
          duration = 0.06;
        } else {
          frequency = 380;
          volume = 0.22;
          duration = 0.08;
        }

        oscillator.frequency.value = frequency;
        oscillator.type = 'sine';

        gainNode.gain.setValueAtTime(volume, this.context.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, this.context.currentTime + duration);

        oscillator.start(this.context.currentTime);
        oscillator.stop(this.context.currentTime + duration);
      },

      // === T097: Landing sounds based on surface ===
      playLandSound(surfaceType = 'grass') {
        if (this.muted || !this.context) return;

        const oscillator = this.context.createOscillator();
        const gainNode = this.context.createGain();

        oscillator.connect(gainNode);
        gainNode.connect(this.context.destination);

        let frequency, duration, volume;
        switch (surfaceType) {
          case 'sand':
            frequency = 120;
            duration = 0.15;
            volume = 0.12;
            break;
          case 'water':
            frequency = 200;
            duration = 0.2;
            volume = 0.18;
            oscillator.type = 'triangle';
            break;
          case 'grass':
          default:
            frequency = 150;
            duration = 0.08;
            volume = 0.1;
            break;
        }

        oscillator.frequency.value = frequency;
        if (surfaceType !== 'water') oscillator.type = 'sine';

        gainNode.gain.setValueAtTime(volume, this.context.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, this.context.currentTime + duration);

        oscillator.start(this.context.currentTime);
        oscillator.stop(this.context.currentTime + duration);
      },

      // === T098: Cheer sound for exceptional shots ===
      playCheerSound() {
        if (this.muted || !this.context) return;

        // Play a rising three-note cheer
        const notes = [523.25, 659.25, 783.99]; // C5, E5, G5
        notes.forEach((freq, i) => {
          setTimeout(() => {
            const osc = this.context.createOscillator();
            const gain = this.context.createGain();
            osc.connect(gain);
            gain.connect(this.context.destination);
            osc.frequency.value = freq;
            osc.type = 'sine';
            gain.gain.setValueAtTime(0.15, this.context.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, this.context.currentTime + 0.3);
            osc.start(this.context.currentTime);
            osc.stop(this.context.currentTime + 0.3);
          }, i * 100);
        });
      },

      // === T099: Hole completion jingle ===
      playHoleSound() {
        if (this.muted || !this.context) return;

        const oscillator = this.context.createOscillator();
        const gainNode = this.context.createGain();

        oscillator.connect(gainNode);
        gainNode.connect(this.context.destination);

        oscillator.frequency.value = 523.25;
        oscillator.type = 'sine';

        gainNode.gain.setValueAtTime(0.2, this.context.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, this.context.currentTime + 0.3);

        oscillator.start(this.context.currentTime);
        oscillator.stop(this.context.currentTime + 0.3);

        setTimeout(() => {
          const osc2 = this.context.createOscillator();
          const gain2 = this.context.createGain();
          osc2.connect(gain2);
          gain2.connect(this.context.destination);
          osc2.frequency.value = 659.25;
          osc2.type = 'sine';
          gain2.gain.setValueAtTime(0.2, this.context.currentTime);
          gain2.gain.exponentialRampToValueAtTime(0.01, this.context.currentTime + 0.3);
          osc2.start(this.context.currentTime);
          osc2.stop(this.context.currentTime + 0.3);
        }, 150);
      },

      playStreakerSound() {
        if (this.muted || !this.context) return;

        // Create a funny "AAAHHHH!" scream sound
        const duration = 1.2;
        const now = this.context.currentTime;

        // Main scream oscillator - starts high, wobbles
        const screamOsc = this.context.createOscillator();
        const screamGain = this.context.createGain();
        const vibrato = this.context.createOscillator();
        const vibratoGain = this.context.createGain();

        // Vibrato for wobbly scream effect
        vibrato.frequency.value = 12; // Fast wobble
        vibratoGain.gain.value = 50; // Amount of pitch wobble
        vibrato.connect(vibratoGain);
        vibratoGain.connect(screamOsc.frequency);

        screamOsc.connect(screamGain);
        screamGain.connect(this.context.destination);

        // Scream starts high and drops slightly
        screamOsc.frequency.setValueAtTime(800, now);
        screamOsc.frequency.linearRampToValueAtTime(600, now + 0.3);
        screamOsc.frequency.linearRampToValueAtTime(700, now + 0.6);
        screamOsc.frequency.linearRampToValueAtTime(500, now + duration);

        screamOsc.type = 'sawtooth'; // Harsh, scream-like

        // Volume envelope - loud start, sustain, fade
        screamGain.gain.setValueAtTime(0, now);
        screamGain.gain.linearRampToValueAtTime(0.15, now + 0.05);
        screamGain.gain.setValueAtTime(0.12, now + 0.3);
        screamGain.gain.linearRampToValueAtTime(0.08, now + 0.8);
        screamGain.gain.exponentialRampToValueAtTime(0.01, now + duration);

        vibrato.start(now);
        screamOsc.start(now);
        vibrato.stop(now + duration);
        screamOsc.stop(now + duration);

        // Add a second higher harmonic for more "voice" quality
        const harmonic = this.context.createOscillator();
        const harmonicGain = this.context.createGain();
        harmonic.connect(harmonicGain);
        harmonicGain.connect(this.context.destination);

        harmonic.frequency.setValueAtTime(1200, now);
        harmonic.frequency.linearRampToValueAtTime(900, now + 0.3);
        harmonic.frequency.linearRampToValueAtTime(1000, now + duration);
        harmonic.type = 'sine';

        harmonicGain.gain.setValueAtTime(0, now);
        harmonicGain.gain.linearRampToValueAtTime(0.05, now + 0.05);
        harmonicGain.gain.exponentialRampToValueAtTime(0.01, now + duration);

        harmonic.start(now);
        harmonic.stop(now + duration);
      },

      // === T094, T100: Mute toggle ===
      setMuted(muted) {
        this.muted = muted;
        const settings = StorageManager.loadSettings();
        settings.soundEnabled = !muted;
        StorageManager.saveSettings(settings);
      }
    };

    // === ConfettiSystem Module (T102-T105: Visual Polish) ===
    const ConfettiSystem = {
      particles: [],

      // Color palettes for different score types
      colors: {
        standard: ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7', '#DDA0DD'],
        birdie: ['#4CAF50', '#8BC34A', '#CDDC39', '#FFD700'],
        eagle: ['#FFD700', '#FFA500', '#FF6347', '#FF69B4', '#9370DB', '#00CED1']
      },

      spawn(x, y, count, colorPalette = 'standard') {
        const palette = this.colors[colorPalette] || this.colors.standard;

        for (let i = 0; i < count; i++) {
          const angle = (Math.PI * 2 * i / count) + (Math.random() - 0.5) * 0.5;
          const speed = 150 + Math.random() * 200;

          this.particles.push({
            x: x,
            y: y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed - 100, // Bias upward
            rotation: Math.random() * Math.PI * 2,
            rotationSpeed: (Math.random() - 0.5) * 10,
            color: palette[Math.floor(Math.random() * palette.length)],
            size: 4 + Math.random() * 6,
            life: 1.0, // 1.0 = full life, 0 = dead
            gravity: 300
          });
        }
      },

      update(deltaTime) {
        for (let i = this.particles.length - 1; i >= 0; i--) {
          const p = this.particles[i];

          // Apply physics
          p.vy += p.gravity * deltaTime;
          p.x += p.vx * deltaTime;
          p.y += p.vy * deltaTime;
          p.rotation += p.rotationSpeed * deltaTime;

          // Apply drag
          p.vx *= 0.99;
          p.vy *= 0.99;

          // Decay life
          p.life -= deltaTime * 0.5;

          // Remove dead particles
          if (p.life <= 0) {
            this.particles.splice(i, 1);
          }
        }
      },

      draw(ctx) {
        for (const p of this.particles) {
          ctx.save();
          ctx.translate(p.x, p.y);
          ctx.rotate(p.rotation);
          ctx.globalAlpha = Math.min(p.life, 1);
          ctx.fillStyle = p.color;
          ctx.fillRect(-p.size / 2, -p.size / 4, p.size, p.size / 2);
          ctx.restore();
        }
      },

      clear() {
        this.particles = [];
      }
    };

    // === RandomEventManager Module (T108-T115: Random Events & Humor) ===
    const RandomEventManager = {
      streaker: null,
      cooldownTimer: 0,
      minCooldown: 8, // Minimum seconds between events
      triggerChance: 0.25, // 25% chance per stroke check

      // Streaker configuration
      streakerConfig: {
        speed: 600, // pixels per second
        size: 40,
        color: '#FFD6B3', // Skin tone silhouette
        trailColor: 'rgba(255, 214, 179, 0.3)'
      },

      reset() {
        this.streaker = null;
        this.cooldownTimer = 0;
      },

      // Check if we should trigger an event (called after each stroke)
      checkTrigger() {
        // Don't trigger during cooldown
        if (this.cooldownTimer > 0) return false;

        // Don't trigger if streaker already active
        if (this.streaker) return false;

        // Random chance to trigger
        if (Math.random() < this.triggerChance) {
          this.spawnStreaker();
          return true;
        }
        return false;
      },

      spawnStreaker() {
        const canvas = document.getElementById('game-canvas');
        const height = canvas.height;
        const width = canvas.width;

        // Randomly choose direction (left-to-right or right-to-left)
        const goingRight = Math.random() > 0.5;

        // Vertical position - center of screen
        const yPos = height * 0.5;

        this.streaker = {
          x: goingRight ? -60 : width + 60,
          y: yPos,
          targetX: goingRight ? width + 60 : -60,
          direction: goingRight ? 1 : -1,
          animationPhase: 0,
          trail: [],
          warningTimer: 1.0, // Show warning for 1 second before running
          started: false
        };

        // Set cooldown
        this.cooldownTimer = this.minCooldown + Math.random() * 10;
      },

      update(deltaTime) {
        // Update cooldown
        if (this.cooldownTimer > 0) {
          this.cooldownTimer -= deltaTime;
        }

        // Update streaker if active
        if (this.streaker) {
          const s = this.streaker;
          const config = this.streakerConfig;

          // Warning phase - show text before streaker runs
          if (s.warningTimer > 0) {
            s.warningTimer -= deltaTime;
            if (s.warningTimer <= 0) {
              s.started = true;
              // Play scream when streaker starts running
              AudioManager.playStreakerSound();
            }
            return; // Don't move streaker during warning
          }

          // Move streaker
          s.x += config.speed * s.direction * deltaTime;

          // Animate running (bobbing motion)
          s.animationPhase += deltaTime * 15;

          // Add trail position
          s.trail.push({ x: s.x, y: s.y, alpha: 1 });

          // Limit trail length
          if (s.trail.length > 8) {
            s.trail.shift();
          }

          // Fade trail
          for (const t of s.trail) {
            t.alpha *= 0.85;
          }

          // Check if streaker has exited screen
          if ((s.direction > 0 && s.x > s.targetX) ||
              (s.direction < 0 && s.x < s.targetX)) {
            this.streaker = null;
          }
        }
      },

      draw(ctx) {
        if (!this.streaker) return;

        const s = this.streaker;
        const config = this.streakerConfig;
        const canvas = ctx.canvas;

        // During warning phase, show big text
        if (s.warningTimer > 0) {
          ctx.save();

          // Pulsing effect
          const pulse = 1 + Math.sin(s.warningTimer * 15) * 0.1;

          // Big bold text
          ctx.font = `bold ${60 * pulse}px Arial`;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';

          // Text shadow
          ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
          ctx.fillText('STREAKER INCOMING!', canvas.width / 2 + 3, canvas.height / 2 + 3);

          // Main text - red/orange gradient feel
          ctx.fillStyle = '#FF4444';
          ctx.fillText('STREAKER INCOMING!', canvas.width / 2, canvas.height / 2);

          // White stroke for visibility
          ctx.strokeStyle = '#FFFFFF';
          ctx.lineWidth = 2;
          ctx.strokeText('STREAKER INCOMING!', canvas.width / 2, canvas.height / 2);

          ctx.restore();
          return; // Don't draw streaker yet
        }

        // Draw trail first
        for (const t of s.trail) {
          ctx.save();
          ctx.globalAlpha = t.alpha * 0.5;
          ctx.fillStyle = config.trailColor;
          ctx.beginPath();
          ctx.ellipse(t.x, t.y, config.size * 0.3, config.size * 0.6, 0, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        }

        // Running animation - bobbing up/down + arm/leg motion
        const bob = Math.sin(s.animationPhase) * 5;
        const armSwing = Math.sin(s.animationPhase) * 0.5;
        const legSwing = Math.sin(s.animationPhase + Math.PI) * 0.4;

        ctx.save();
        ctx.translate(s.x, s.y + bob);

        // Flip if going left
        if (s.direction < 0) {
          ctx.scale(-1, 1);
        }

        // Draw silhouette style figure (PG-friendly!)
        const bodyColor = config.color;
        const outlineColor = '#CC9966';

        // Body (oval)
        ctx.fillStyle = bodyColor;
        ctx.strokeStyle = outlineColor;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.ellipse(0, 0, config.size * 0.25, config.size * 0.4, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();

        // Head
        ctx.beginPath();
        ctx.arc(0, -config.size * 0.55, config.size * 0.2, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();

        // Arms (swinging)
        ctx.lineWidth = 6;
        ctx.lineCap = 'round';
        ctx.strokeStyle = bodyColor;

        // Back arm
        ctx.save();
        ctx.rotate(armSwing - 0.3);
        ctx.beginPath();
        ctx.moveTo(0, -config.size * 0.2);
        ctx.lineTo(-config.size * 0.35, config.size * 0.1);
        ctx.stroke();
        ctx.restore();

        // Front arm
        ctx.save();
        ctx.rotate(-armSwing + 0.3);
        ctx.beginPath();
        ctx.moveTo(0, -config.size * 0.2);
        ctx.lineTo(config.size * 0.35, config.size * 0.1);
        ctx.stroke();
        ctx.restore();

        // Legs (running)
        ctx.strokeStyle = bodyColor;

        // Back leg
        ctx.save();
        ctx.rotate(legSwing);
        ctx.beginPath();
        ctx.moveTo(0, config.size * 0.25);
        ctx.lineTo(-config.size * 0.15, config.size * 0.6);
        ctx.stroke();
        ctx.restore();

        // Front leg
        ctx.save();
        ctx.rotate(-legSwing);
        ctx.beginPath();
        ctx.moveTo(0, config.size * 0.25);
        ctx.lineTo(config.size * 0.15, config.size * 0.6);
        ctx.stroke();
        ctx.restore();

        // Funny detail - wild hair
        ctx.strokeStyle = '#8B4513';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(-config.size * 0.1, -config.size * 0.7);
        ctx.lineTo(-config.size * 0.2, -config.size * 0.85);
        ctx.moveTo(0, -config.size * 0.75);
        ctx.lineTo(0, -config.size * 0.9);
        ctx.moveTo(config.size * 0.1, -config.size * 0.7);
        ctx.lineTo(config.size * 0.15, -config.size * 0.85);
        ctx.stroke();

        ctx.restore();
      },

      isActive() {
        return this.streaker !== null;
      }
    };

    // === TutorialManager Module (T082-T089: Tutorial System) ===
    const TutorialManager = {
      steps: [
        {
          title: "Welcome to Howlett Golf Chaos!",
          text: "Let's learn by playing a practice hole! Tap 'Next' to begin.",
          highlight: null,
          action: null,
          waitForAction: false
        },
        {
          title: "Step 1: Take Your First Swing!",
          text: "Drag BACKWARD from the ball toward the bottom of the screen, then release to shoot FORWARD toward the hole. Try it now!",
          highlight: 'game-canvas',
          action: 'swing',
          waitForAction: true
        },
        {
          title: "Great Shot!",
          text: "You did it! The ball moves opposite to your drag direction. The longer you drag, the more power!",
          highlight: null,
          action: null,
          waitForAction: false
        },
        {
          title: "Step 2: Choose a Club",
          text: "Now pick a different club! Tap on any club in the bag below. Each club has a different max distance - choose wisely!",
          highlight: 'club-selector',
          action: 'selectClub',
          waitForAction: true
        },
        {
          title: "Nice Choice!",
          text: "The glowing club is recommended for your distance. Driver hits far, Irons for mid-range, Putter for the green!",
          highlight: 'club-selector',
          action: null,
          waitForAction: false
        },
        {
          title: "Step 3: Sink the Ball!",
          text: "Keep hitting until you get the ball in the hole! Watch the distance display and use the right club.",
          highlight: null,
          action: 'holeComplete',
          waitForAction: true
        },
        {
          title: "Hole Complete!",
          text: "Awesome! You scored on the practice hole. Now you're ready for the real game!",
          highlight: null,
          action: null,
          waitForAction: false
        }
      ],

      currentStep: 0,
      isActive: false,
      gameEngine: null,
      waitingForAction: false,

      start(gameEngine) {
        this.gameEngine = gameEngine;
        this.currentStep = 0;
        this.isActive = true;
        this.waitingForAction = false;

        // Start a tutorial practice hole
        this.startPracticeHole();

        this.showStep();
        document.getElementById('tutorial-overlay').classList.remove('hidden');
      },

      startPracticeHole() {
        if (!this.gameEngine) return;

        // Create a simple short practice hole
        const canvas = this.gameEngine.canvas;
        const canvasRect = canvas.getBoundingClientRect();

        // Simple short par 3 hole
        const practiceHole = {
          holeNumber: 0,
          par: 3,
          teePosition: { x: canvasRect.width * 0.2, y: canvasRect.height * 0.7 },
          holePosition: { x: canvasRect.width * 0.75, y: canvasRect.height * 0.35 },
          greenRadius: 60,
          fairwayWidth: 120,
          obstacles: [] // No obstacles for practice
        };

        const ball = {
          x: practiceHole.teePosition.x,
          y: practiceHole.teePosition.y,
          velocityX: 0,
          velocityY: 0,
          rotation: 0,
          isMoving: false,
          isAirborne: false,
          inHole: false,
          color: 'white'
        };

        this.gameEngine.gameState = {
          currentHole: practiceHole,
          round: {
            roundId: 'tutorial',
            startTime: Date.now(),
            endTime: null,
            currentHoleNumber: 0,
            isComplete: false,
            holeScores: [],
            totalStrokes: 0,
            totalPar: 0,
            scoreRelativeToPar: 0,
            currentStrokeCount: 0
          },
          ball: ball,
          selectedClub: 'driver',
          seed: Date.now(),
          playerName: 'Student',
          isTutorial: true
        };

        this.gameEngine.updateUI();
        this.gameEngine.updateClubSelector();

        // Hide menu, show game
        document.getElementById('menu-overlay').classList.add('hidden');
        document.getElementById('club-selector-container').style.display = 'block';
      },

      showStep() {
        const step = this.steps[this.currentStep];
        document.getElementById('tutorial-title').textContent = step.title;
        document.getElementById('tutorial-text').textContent = step.text;
        document.getElementById('tutorial-progress').textContent =
          `Step ${this.currentStep + 1} of ${this.steps.length}`;

        // Update button visibility based on whether we're waiting for action
        const nextBtn = document.getElementById('tutorial-next-btn');
        const skipBtn = document.getElementById('tutorial-skip-btn');

        if (step.waitForAction) {
          nextBtn.style.display = 'none';
          this.waitingForAction = true;
        } else {
          nextBtn.style.display = 'inline-block';
          nextBtn.textContent = this.currentStep === this.steps.length - 1 ? "Start Game!" : "Next";
          this.waitingForAction = false;
        }

        // Handle highlighting
        this.unhighlightAll();
        if (step.highlight) {
          this.highlightElement(step.highlight);
        }
      },

      // Called by game when player performs an action
      onAction(actionType) {
        if (!this.isActive || !this.waitingForAction) return;

        const step = this.steps[this.currentStep];
        if (step.action === actionType) {
          // Action completed! Move to next step
          setTimeout(() => {
            this.nextStep();
          }, actionType === 'holeComplete' ? 1500 : 500);
        }
      },

      nextStep() {
        this.unhighlightAll();
        this.currentStep++;

        if (this.currentStep >= this.steps.length) {
          this.complete();
        } else {
          this.showStep();
        }
      },

      skip() {
        this.unhighlightAll();
        this.complete();
      },

      complete() {
        this.isActive = false;
        this.currentStep = 0;
        this.waitingForAction = false;
        document.getElementById('tutorial-overlay').classList.add('hidden');
        document.getElementById('tutorial-next-btn').style.display = 'inline-block';

        // Mark tutorial as completed
        const settings = StorageManager.loadSettings();
        settings.tutorialCompleted = true;
        StorageManager.saveSettings(settings);

        // Return to main menu
        if (this.gameEngine) {
          this.gameEngine.gameState = null;
          document.getElementById('menu-overlay').classList.remove('hidden');
          document.getElementById('club-selector-container').style.display = 'none';
        }
      },

      highlightElement(id) {
        const element = document.getElementById(id);
        if (element) {
          element.classList.add('tutorial-highlight');
        }
      },

      unhighlightAll() {
        document.querySelectorAll('.tutorial-highlight').forEach(el => {
          el.classList.remove('tutorial-highlight');
        });
      }
    };

    // === GameEngine Module (T007, T011, T013-T025) ===
    class GameEngine {
      constructor(canvas) {
        this.canvas = canvas;
        this.isRunning = false;
        this.isPaused = false;
        this.lastFrameTime = 0;
        this.fps = 60;
        this.debugMode = false;
        this.holeCompleting = false;
        this.animationTime = 0; // Global animation time for visual effects

        this.gameState = null;

        Renderer.init(canvas);
        InputHandler.init(canvas, this);

        this.checkDebugMode();
      }

      checkDebugMode() {
        const params = new URLSearchParams(window.location.search);
        this.debugMode = params.get('debug') === 'true';
        if (this.debugMode) {
          document.getElementById('debug-info').classList.remove('hidden');
        }
      }

      start() {
        this.isRunning = true;
        this.lastFrameTime = performance.now();
        requestAnimationFrame((t) => this.update(t));
      }

      pause() {
        this.isPaused = true;
      }

      resume() {
        this.isPaused = false;
        this.lastFrameTime = performance.now();
      }

      async startNewRound(seed = null, playerName = 'Player', ballColor = 'white') {
        const usedSeed = seed || Date.now();
        CourseGenerator.init(usedSeed);

        const canvasRect = this.canvas.getBoundingClientRect();
        const hole = CourseGenerator.generateHole(1, canvasRect.width, canvasRect.height);

        const ball = this.createBall(hole, ballColor);

        this.gameState = {
          currentHole: hole,
          round: {
            roundId: 'round-' + Date.now(),
            startTime: Date.now(),
            endTime: null,
            currentHoleNumber: 1,
            isComplete: false,
            holeScores: [],
            totalStrokes: 0,
            totalPar: 0,
            scoreRelativeToPar: 0,
            currentStrokeCount: 0
          },
          ball: ball,
          selectedClub: 'driver',
          seed: usedSeed,
          playerName: playerName,
          ballColor: ballColor
        };

        this.updateUI();
        document.getElementById('menu-overlay').classList.add('hidden');

        // Reset random events for new round
        RandomEventManager.reset();

        await StorageManager.clearGameState();
      }

      async loadRound() {
        try {
          const savedState = await StorageManager.loadGameState();
          if (!savedState) {
            console.error('No saved game state found');
            return false;
          }

          CourseGenerator.init(savedState.seed);

          const canvasRect = this.canvas.getBoundingClientRect();
          const hole = CourseGenerator.generateHole(
            savedState.round.currentHoleNumber,
            canvasRect.width,
            canvasRect.height
          );

          const ballColor = savedState.ballColor || savedState.ball?.color || 'white';
          this.gameState = {
            currentHole: hole,
            round: savedState.round,
            ball: this.createBall(hole, ballColor),
            selectedClub: savedState.selectedClub,
            seed: savedState.seed,
            ballColor: ballColor
          };

          this.gameState.ball.x = savedState.ball.x;
          this.gameState.ball.y = savedState.ball.y;
          this.gameState.ball.velocityX = savedState.ball.velocityX;
          this.gameState.ball.velocityY = savedState.ball.velocityY;
          this.gameState.ball.isMoving = savedState.ball.isMoving;
          this.gameState.ball.lastSafePosition = savedState.ball.lastSafePosition;

          // Ensure ball is never loaded in a "in hole" state (prevents infinite loop bug)
          this.gameState.ball.inHole = false;
          this.gameState.ball.holeProgress = 0;
          delete this.gameState.ball.holeStartTime;

          this.updateUI();
          this.updateRoundProgress();
          document.getElementById('menu-overlay').classList.add('hidden');

          return true;
        } catch (error) {
          console.error('Failed to load saved game:', error);
          return false;
        }
      }

      createBall(hole, color = 'white') {
        return {
          x: hole.teePosition.x,
          y: hole.teePosition.y,
          velocityX: 0,
          velocityY: 0,
          spin: 0,
          isAirborne: false,
          isMoving: false,
          rotation: 0,
          groundY: hole.teePosition.y,
          holePosition: hole.holePosition,
          distanceFromHole: PhysicsEngine.distance(hole.teePosition, hole.holePosition),
          lastSafePosition: { x: hole.teePosition.x, y: hole.teePosition.y },
          waterPenalty: false,
          color: color
        };
      }

      updateUI() {
        const round = this.gameState.round;
        const hole = this.gameState.currentHole;

        document.getElementById('hole-number').textContent = round.currentHoleNumber;
        document.getElementById('hole-par').textContent = hole.par;
        document.getElementById('stroke-count').textContent = round.currentStrokeCount;
        document.getElementById('total-score').textContent = ScoreKeeper.getScoreDisplay(round.scoreRelativeToPar);

        const club = ClubSystem.getClub(this.gameState.selectedClub);
        document.getElementById('current-club').textContent = club.name;

        // Convert distance from meters to yards (1m = 1.09361yd)
        const distance = Math.round(this.gameState.ball.distanceFromHole * 1.09361);
        document.getElementById('distance-to-hole').textContent = distance;

        // Update real-time distance display in lower right
        const distanceDisplay = document.getElementById('distance-display');
        const distanceValue = document.getElementById('distance-value');
        if (distanceDisplay && distanceValue) {
          distanceValue.textContent = distance;
          distanceDisplay.classList.remove('hidden');
        }

        this.updateClubSelector();
      }

      selectClub(clubId) {
        if (!this.gameState || !this.gameState.ball) return;
        if (this.gameState.ball.isMoving) return;

        const isFirstStroke = this.gameState.round.currentStrokeCount === 0;
        if (isFirstStroke && clubId !== 'driver') {
          return;
        }

        this.gameState.selectedClub = clubId;

        const club = ClubSystem.getClub(clubId);
        document.getElementById('current-club').textContent = club.name;

        this.updateClubSelector();

        // Notify tutorial of club selection
        if (TutorialManager.isActive) {
          TutorialManager.onAction('selectClub');
        }
      }

      updateClubSelector() {
        if (!this.gameState) return;

        const isFirstStroke = this.gameState.round.currentStrokeCount === 0;
        const availableClubs = ClubSystem.getAvailableClubs(isFirstStroke);
        const selectedClub = this.gameState.selectedClub;

        const clubSelector = document.getElementById('club-selector');
        clubSelector.innerHTML = '';

        const recommendedClub = ClubSystem.getRecommendedClub(this.gameState.ball, this.gameState.currentHole.holePosition);

        // Helper to get club type for styling
        const getClubType = (clubId) => {
          if (clubId === 'driver') return 'driver';
          if (clubId.includes('wood')) return 'wood';
          if (clubId === 'wedge') return 'wedge';
          if (clubId === 'putter') return 'putter';
          return 'iron';
        };

        // Helper to get short label for club head
        const getClubLabel = (club) => {
          if (club.id === 'driver') return 'D';
          if (club.id === '3wood') return '3W';
          if (club.id === '5wood') return '5W';
          if (club.id === 'wedge') return 'W';
          if (club.id === 'putter') return 'P';
          // Irons: extract number
          const match = club.id.match(/iron(\d)/);
          return match ? match[1] : club.name.charAt(0);
        };

        for (const club of availableClubs) {
          const maxDistance = ClubSystem.getMaxDistance(club.id);
          const clubType = getClubType(club.id);
          const label = getClubLabel(club);

          const slot = document.createElement('div');
          slot.className = 'club-slot';
          slot.dataset.club = club.id;

          if (club.id === selectedClub) {
            slot.classList.add('selected');
          }

          if (club.id === recommendedClub && !isFirstStroke) {
            slot.classList.add('recommended');
          }

          slot.innerHTML = `
            <div class="club-head ${clubType}">${label}</div>
            <div class="club-shaft"></div>
            <div class="club-distance">${maxDistance}yd</div>
          `;

          slot.addEventListener('click', () => this.selectClub(club.id));
          clubSelector.appendChild(slot);
        }

        const clubContainer = document.getElementById('club-selector-container');
        clubContainer.style.display = 'block';
      }

      executeSwing(swingVector) {
        if (!this.gameState || !this.gameState.ball) return;
        if (this.gameState.ball.isMoving) return;
        if (this.gameState.round.isComplete) return; // Prevent strokes after round ends

        this.gameState.ball.lastSafePosition = { x: this.gameState.ball.x, y: this.gameState.ball.y };
        this.gameState.ball.waterPenalty = false;

        const modifiedSwing = ClubSystem.applyClubToSwing(swingVector, this.gameState.selectedClub);
        PhysicsEngine.applySwing(this.gameState.ball, modifiedSwing);
        ScoreKeeper.recordStroke(this.gameState.round);

        this.gameState.strikeFlash = { active: true, progress: 0, startTime: performance.now() };

        AudioManager.playHitSound(swingVector.power);

        if (this.gameState.ball.waterPenalty) {
          ScoreKeeper.recordStroke(this.gameState.round);
        }

        // Check for random event trigger (streaker) - not during tutorial
        if (!this.gameState.isTutorial) {
          RandomEventManager.checkTrigger();
        }

        // Notify tutorial of swing
        if (TutorialManager.isActive) {
          TutorialManager.onAction('swing');
        }

        // Only save if ball is not in hole (prevents corrupted state on reload)
        if (!this.gameState.ball.inHole && !this.holeCompleting && !this.gameState.isTutorial) {
          StorageManager.saveGameState(this.gameState);
        }
      }

      update(timestamp) {
        if (!this.isRunning) return;

        // Cap deltaTime to prevent physics jumps on slow devices or when resuming
        const rawDeltaTime = (timestamp - this.lastFrameTime) / 1000;
        const deltaTime = Math.min(rawDeltaTime, 1/30);
        this.lastFrameTime = timestamp;

        if (!this.isPaused && this.gameState) {
          this.updateFPS(deltaTime);

          // Update animation time for visual effects
          this.animationTime += deltaTime;

          if (this.gameState.strikeFlash && this.gameState.strikeFlash.active) {
            const elapsed = timestamp - this.gameState.strikeFlash.startTime;
            this.gameState.strikeFlash.progress = Math.min(elapsed / 300, 1);
            if (this.gameState.strikeFlash.progress >= 1) {
              this.gameState.strikeFlash.active = false;
            }
          }

          if (this.gameState.ball) {
            const obstacles = this.gameState.currentHole.obstacles || [];
            PhysicsEngine.updateBall(this.gameState.ball, deltaTime, obstacles);

            if (PhysicsEngine.isBallInHole(this.gameState.ball) && !this.holeCompleting) {
              if (!this.gameState.ball.inHole) {
                this.gameState.ball.inHole = true;
                this.gameState.ball.holeProgress = 0;
                this.gameState.ball.holeStartTime = timestamp;
                AudioManager.playHoleSound();
              }
            }

            if (this.gameState.ball.inHole) {
              const elapsed = timestamp - this.gameState.ball.holeStartTime;
              this.gameState.ball.holeProgress = Math.min(elapsed / 800, 1);

              if (this.gameState.ball.holeProgress >= 1 && !this.holeCompleting && !this.gameState.round.isComplete) {
                this.completeHole();
              }
            }

            this.updateBallStateIndicator();
          }

          // Update confetti particles
          ConfettiSystem.update(deltaTime);

          // Update random events (streaker)
          RandomEventManager.update(deltaTime);

          Renderer.renderFrame(this.gameState, this.animationTime);
        }

        requestAnimationFrame((t) => this.update(t));
      }

      updateBallStateIndicator() {
        const ball = this.gameState.ball;
        const stateElement = document.getElementById('ball-state');
        if (!stateElement) return;

        const wasMoving = this.ballWasMoving || false;
        this.ballWasMoving = ball.isMoving;

        // Update distance display in real-time
        const distance = Math.round(ball.distanceFromHole * 1.09361); // Convert to yards
        const distanceValue = document.getElementById('distance-value');
        if (distanceValue) {
          distanceValue.textContent = distance;
        }

        if (ball.isMoving) {
          const speed = Math.sqrt(ball.velocityX * ball.velocityX + ball.velocityY * ball.velocityY);
          if (speed > 100) {
            stateElement.textContent = 'üèåÔ∏è Flying';
            stateElement.style.color = '#FF6B35';
          } else {
            stateElement.textContent = '‚õ≥ Rolling';
            stateElement.style.color = '#4ECDC4';
          }
        } else {
          stateElement.textContent = 'üî¥ Ready';
          stateElement.style.color = '#2E8B57';

          if (wasMoving && !ball.isMoving) {
            this.updateClubSelector();
          }
        }
      }

      completeHole() {
        const round = this.gameState.round;
        const hole = this.gameState.currentHole;

        // Prevent completing hole without hitting the ball
        if (round.currentStrokeCount === 0) {
          return;
        }

        // Prevent multiple simultaneous completions
        if (this.holeCompleting) {
          return;
        }

        this.holeCompleting = true;

        // Notify tutorial of hole completion
        if (TutorialManager.isActive) {
          TutorialManager.onAction('holeComplete');
          // Skip the normal hole complete flow for tutorial
          this.holeCompleting = false;
          return;
        }

        const holeScore = ScoreKeeper.completeHole(round, hole);

        this.updateRoundProgress();

        const scoreName = ScoreKeeper.getScoreName(holeScore.scoreRelativeToPar);

        // Spawn confetti at hole position for any completion
        const holeX = hole.holePosition.x;
        const holeY = hole.holePosition.y;
        ConfettiSystem.spawn(holeX, holeY, 25, 'standard');

        if (holeScore.scoreRelativeToPar <= -1) {
          this.celebrateGoodScore(holeScore.scoreRelativeToPar, holeX, holeY);
        }

        setTimeout(() => {
          this.showHoleCompleteModal(hole, round, holeScore, scoreName);
        }, 500);
      }

      showHoleCompleteModal(hole, round, holeScore, scoreName) {
        // Update modal content
        document.getElementById('hole-complete-number').textContent = hole.holeNumber;
        document.getElementById('hole-complete-strokes').textContent = holeScore.strokes;
        document.getElementById('hole-complete-par').textContent = hole.par;
        document.getElementById('hole-complete-total').textContent = ScoreKeeper.getScoreDisplay(round.scoreRelativeToPar);

        // Set score name and color class
        const scoreNameEl = document.getElementById('hole-complete-score-name');
        scoreNameEl.textContent = scoreName;
        scoreNameEl.className = 'hole-complete-score-name';

        if (holeScore.scoreRelativeToPar <= -2) {
          scoreNameEl.classList.add('eagle');
        } else if (holeScore.scoreRelativeToPar === -1) {
          scoreNameEl.classList.add('birdie');
        } else if (holeScore.scoreRelativeToPar === 0) {
          scoreNameEl.classList.add('par');
        } else if (holeScore.scoreRelativeToPar === 1) {
          scoreNameEl.classList.add('bogey');
        } else {
          scoreNameEl.classList.add('double-bogey');
        }

        // Update button text based on whether this is the last hole
        const btn = document.getElementById('hole-complete-btn');
        const isLastHole = round.currentHoleNumber >= 9;
        btn.textContent = isLastHole ? 'View Scorecard' : 'Next Hole';

        // Show modal
        document.getElementById('hole-complete-overlay').classList.remove('hidden');

        // Set up button handler (remove old listener first)
        const newBtn = btn.cloneNode(true);
        btn.parentNode.replaceChild(newBtn, btn);

        newBtn.addEventListener('click', () => {
          document.getElementById('hole-complete-overlay').classList.add('hidden');

          if (isLastHole) {
            round.isComplete = true;
            round.endTime = Date.now();
            this.showRoundSummary();
          } else {
            this.advanceToNextHole();
          }
        });
      }

      // === T098: Play cheer for exceptional shots ===
      celebrateGoodScore(scoreRelativeToPar, holeX, holeY) {
        if (scoreRelativeToPar <= -2) {
          console.log('üéâ EAGLE OR BETTER! üéâ');
          AudioManager.playCheerSound();
          // Extra confetti burst for eagle or better
          ConfettiSystem.spawn(holeX, holeY, 60, 'eagle');
        } else if (scoreRelativeToPar === -1) {
          console.log('üéä BIRDIE! üéä');
          AudioManager.playCheerSound();
          // Extra confetti for birdie
          ConfettiSystem.spawn(holeX, holeY, 40, 'birdie');
        }
      }

      updateRoundProgress() {
        const summary = ScoreKeeper.getRoundSummary(this.gameState.round);
        const progressElement = document.getElementById('round-progress');
        const progressText = document.getElementById('progress-text');

        if (progressElement && progressText) {
          progressText.textContent = `${summary.completedHoles}/9 holes`;
          progressElement.classList.remove('hidden');
        }
      }

      advanceToNextHole() {
        const round = this.gameState.round;
        round.currentHoleNumber++;
        round.currentStrokeCount = 0;

        const canvasRect = this.canvas.getBoundingClientRect();
        const hole = CourseGenerator.generateHole(round.currentHoleNumber, canvasRect.width, canvasRect.height);

        this.gameState.currentHole = hole;
        this.gameState.ball = this.createBall(hole, this.gameState.ballColor || 'white');

        this.updateUI();

        // Reset flag to allow next hole completion
        this.holeCompleting = false;

        StorageManager.saveGameState(this.gameState);
      }

      async showRoundSummary() {
        const round = this.gameState.round;
        const summary = ScoreKeeper.getRoundSummary(round);

        let tableHTML = '<table class="scorecard-table">';
        tableHTML += '<tr><th>Hole</th><th>Par</th><th>Strokes</th><th>Score</th></tr>';

        for (const holeScore of round.holeScores) {
          const scoreClass = this.getScoreClass(holeScore.scoreRelativeToPar);
          const scoreDisplay = ScoreKeeper.getScoreDisplay(holeScore.scoreRelativeToPar);

          tableHTML += `<tr>`;
          tableHTML += `<td>${holeScore.holeNumber}</td>`;
          tableHTML += `<td>${holeScore.par}</td>`;
          tableHTML += `<td>${holeScore.strokes}</td>`;
          tableHTML += `<td class="${scoreClass}">${scoreDisplay}</td>`;
          tableHTML += `</tr>`;
        }

        tableHTML += '</table>';
        tableHTML += `<div style="margin-top: 20px; font-size: 18px;">`;
        tableHTML += `<strong>Total Strokes:</strong> ${summary.totalStrokes}<br>`;
        tableHTML += `<strong>Total Par:</strong> ${summary.totalPar}<br>`;
        tableHTML += `<strong>Final Score:</strong> <span style="color: ${ScoreKeeper.getScoreColor(summary.scoreRelativeToPar)}; font-weight: bold; font-size: 24px;">${ScoreKeeper.getScoreDisplay(summary.scoreRelativeToPar)}</span>`;
        tableHTML += `</div>`;

        document.getElementById('scorecard-content').innerHTML = tableHTML;
        document.getElementById('scorecard-overlay').classList.remove('hidden');
        document.getElementById('menu-overlay').classList.remove('hidden');

        // === T078: Save to leaderboard ===
        await this.saveToLeaderboard(summary);

        // Reset flag for next round
        this.holeCompleting = false;

        StorageManager.clearGameState();
      }

      // === T078, T080: Save round to leaderboard (global API) ===
      async saveToLeaderboard(summary) {
        const playerName = this.gameState?.playerName || 'Player';

        try {
          // Try to save to global leaderboard API
          const response = await fetch('/api/leaderboard', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              playerName: playerName,
              scoreRelativeToPar: summary.scoreRelativeToPar,
              totalStrokes: summary.totalStrokes
            })
          });

          if (response.ok) {
            const result = await response.json();
            console.log('Score saved to global leaderboard');

            // Check if made top 3
            if (result.rank && result.rank <= 3) {
              const medals = ['ü•á', 'ü•à', 'ü•â'];
              console.log(`${medals[result.rank - 1]} NEW TOP SCORE! Rank #${result.rank}`);
            }
          } else {
            throw new Error('API response not ok');
          }
        } catch (error) {
          console.error('Failed to save to global leaderboard, saving locally:', error);
          // Fallback to local storage if API fails
          try {
            const entry = {
              scoreRelativeToPar: summary.scoreRelativeToPar,
              totalStrokes: summary.totalStrokes,
              completedAt: Date.now(),
              playerName: playerName
            };
            await StorageManager.addLeaderboardEntry(entry);
          } catch (localError) {
            console.error('Failed to save locally too:', localError);
          }
        }
      }

      // === T077, T081: Display leaderboard (global API with local fallback) ===
      static async showLeaderboard() {
        const content = document.getElementById('leaderboard-content');
        content.innerHTML = '<div class="leaderboard-empty">Loading...</div>';
        document.getElementById('leaderboard-overlay').classList.remove('hidden');

        let leaderboard = [];

        try {
          // Try to fetch from global API first
          const response = await fetch('/api/leaderboard');
          if (response.ok) {
            leaderboard = await response.json();
          } else {
            throw new Error('API response not ok');
          }
        } catch (error) {
          console.error('Failed to fetch global leaderboard, trying local:', error);
          // Fallback to local storage
          try {
            leaderboard = await StorageManager.getLeaderboard();
          } catch (localError) {
            console.error('Failed to load local leaderboard:', localError);
          }
        }

        if (!leaderboard || leaderboard.length === 0) {
          content.innerHTML = '<div class="leaderboard-empty">No scores yet. Complete a round to get on the leaderboard!</div>';
        } else {
          let tableHTML = '<table class="leaderboard-table">';
          tableHTML += '<tr><th>Rank</th><th>Player</th><th>Score</th><th>Strokes</th><th>Date</th></tr>';

          leaderboard.forEach((entry, index) => {
            const rank = index + 1;
            const rankClass = rank <= 3 ? `leaderboard-rank-${rank}` : '';
            let scoreClass = 'leaderboard-score-par';
            if (entry.scoreRelativeToPar < 0) scoreClass = 'leaderboard-score-under';
            else if (entry.scoreRelativeToPar > 0) scoreClass = 'leaderboard-score-over';

            const scoreDisplay = ScoreKeeper.getScoreDisplay(entry.scoreRelativeToPar);
            const date = new Date(entry.completedAt).toLocaleDateString();
            // Support both playerName (new) and playerInitials (old local data)
            const playerName = entry.playerName || entry.playerInitials || 'Unknown';

            tableHTML += `<tr>`;
            tableHTML += `<td class="leaderboard-rank ${rankClass}">#${rank}</td>`;
            tableHTML += `<td>${playerName}</td>`;
            tableHTML += `<td class="${scoreClass}">${scoreDisplay}</td>`;
            tableHTML += `<td>${entry.totalStrokes}</td>`;
            tableHTML += `<td>${date}</td>`;
            tableHTML += `</tr>`;
          });

          tableHTML += '</table>';
          content.innerHTML = tableHTML;
        }
      }

      getScoreClass(scoreRelativeToPar) {
        if (scoreRelativeToPar <= -2) return 'score-eagle';
        if (scoreRelativeToPar === -1) return 'score-birdie';
        if (scoreRelativeToPar === 0) return 'score-par';
        if (scoreRelativeToPar === 1) return 'score-bogey';
        return 'score-double';
      }

      updateFPS(deltaTime) {
        this.fps = Math.round(1 / deltaTime);
        if (this.debugMode) {
          const debugDiv = document.getElementById('debug-info');
          debugDiv.innerHTML = `FPS: ${this.fps}<br>Ball: (${Math.round(this.gameState.ball.x)}, ${Math.round(this.gameState.ball.y)})<br>Velocity: (${Math.round(this.gameState.ball.velocityX)}, ${Math.round(this.gameState.ball.velocityY)})<br>Moving: ${this.gameState.ball.isMoving}`;
        }
      }
    }

    // === Initialize Game (T005, T011, T012) ===
    window.addEventListener('DOMContentLoaded', async () => {
      console.log('DOM Content Loaded');

      const canvas = document.getElementById('game-canvas');
      if (!canvas) {
        console.error('Canvas element not found!');
        return;
      }

      console.log('Canvas found, initializing game engine...');

      let gameEngine;
      try {
        gameEngine = new GameEngine(canvas);
        window.gameEngine = gameEngine; // Expose for testing
        console.log('Game engine initialized successfully');
      } catch (error) {
        console.error('Error initializing game engine:', error);
        alert('Error initializing game: ' + error.message);
        return;
      }

      const newGameBtn = document.getElementById('new-game-btn');
      const resumeGameBtn = document.getElementById('resume-game-btn');

      if (!newGameBtn) {
        console.error('New game button not found!');
        return;
      }

      AudioManager.init();

      try {
        await StorageManager.init();
        const hasSavedGame = await StorageManager.hasSavedGame();

        if (hasSavedGame) {
          resumeGameBtn.classList.remove('hidden');
        } else {
          resumeGameBtn.classList.add('hidden');
        }
      } catch (error) {
        console.error('Error checking for saved game:', error);
        resumeGameBtn.classList.add('hidden');
      }

      // Name entry modal elements
      const nameEntryOverlay = document.getElementById('name-entry-overlay');
      const playerNameInput = document.getElementById('player-name-input');
      const startWithNameBtn = document.getElementById('start-with-name-btn');
      const cancelNameEntryBtn = document.getElementById('cancel-name-entry-btn');
      const ballColorOptions = document.getElementById('ball-color-options');

      // Load last used name and ball color from localStorage
      const lastPlayerName = localStorage.getItem('golf-player-name') || '';
      const lastBallColor = localStorage.getItem('golf-ball-color') || 'white';
      playerNameInput.value = lastPlayerName;

      // Set up ball color selection
      let selectedBallColor = lastBallColor;
      const colorButtons = ballColorOptions.querySelectorAll('.ball-color-option');

      // Initialize selected state from saved preference
      colorButtons.forEach(btn => {
        if (btn.dataset.color === lastBallColor) {
          btn.classList.add('selected');
        } else {
          btn.classList.remove('selected');
        }
      });

      // Ball color click handlers
      ballColorOptions.addEventListener('click', (e) => {
        const colorOption = e.target.closest('.ball-color-option');
        if (!colorOption) return;

        // Update selection
        colorButtons.forEach(btn => btn.classList.remove('selected'));
        colorOption.classList.add('selected');
        selectedBallColor = colorOption.dataset.color;
      });

      newGameBtn.addEventListener('click', () => {
        console.log('New Game button clicked');
        AudioManager.unlock();
        // Show name entry modal instead of starting immediately
        nameEntryOverlay.classList.remove('hidden');
        playerNameInput.focus();
        playerNameInput.select();
      });

      // Handle starting game with name
      const startGameWithName = async () => {
        const playerName = playerNameInput.value.trim() || 'Player';
        console.log('Starting game with player:', playerName, 'ball color:', selectedBallColor);

        // Save name and ball color for next time
        localStorage.setItem('golf-player-name', playerName);
        localStorage.setItem('golf-ball-color', selectedBallColor);

        // Hide name entry modal
        nameEntryOverlay.classList.add('hidden');

        try {
          await gameEngine.startNewRound(null, playerName, selectedBallColor);
          gameEngine.start();
          resumeGameBtn.classList.add('hidden');
          console.log('Game started successfully');
        } catch (error) {
          console.error('Error starting game:', error);
          alert('Error starting game: ' + error.message);
        }
      };

      startWithNameBtn.addEventListener('click', startGameWithName);

      // Allow Enter key to start game
      playerNameInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
          startGameWithName();
        }
      });

      // Cancel button
      cancelNameEntryBtn.addEventListener('click', () => {
        nameEntryOverlay.classList.add('hidden');
      });

      resumeGameBtn.addEventListener('click', async () => {
        console.log('Resume Game button clicked');
        AudioManager.unlock();
        try {
          const loaded = await gameEngine.loadRound();
          if (loaded) {
            gameEngine.start();
            console.log('Game resumed successfully');
          } else {
            alert('Failed to load saved game');
            resumeGameBtn.classList.add('hidden');
          }
        } catch (error) {
          console.error('Error resuming game:', error);
          alert('Error resuming game: ' + error.message);
        }
      });

      // === T081: Leaderboard button handler ===
      const leaderboardBtn = document.getElementById('leaderboard-btn');
      if (leaderboardBtn) {
        leaderboardBtn.addEventListener('click', async () => {
          console.log('Leaderboard button clicked');
          await GameEngine.showLeaderboard();
        });
      }

      // === T082-T089: Tutorial handlers ===
      const tutorialBtn = document.getElementById('tutorial-btn');
      const tutorialNextBtn = document.getElementById('tutorial-next-btn');
      const tutorialSkipBtn = document.getElementById('tutorial-skip-btn');
      const tutorialYesBtn = document.getElementById('tutorial-yes-btn');
      const tutorialNoBtn = document.getElementById('tutorial-no-btn');
      const tutorialPromptOverlay = document.getElementById('tutorial-prompt-overlay');

      // Tutorial button in menu (manual replay)
      if (tutorialBtn) {
        tutorialBtn.addEventListener('click', () => {
          console.log('Tutorial button clicked');
          gameEngine.start(); // Make sure game engine is running
          TutorialManager.start(gameEngine);
        });
      }

      // Tutorial navigation buttons
      if (tutorialNextBtn) {
        tutorialNextBtn.addEventListener('click', () => {
          TutorialManager.nextStep();
        });
      }

      if (tutorialSkipBtn) {
        tutorialSkipBtn.addEventListener('click', () => {
          TutorialManager.skip();
        });
      }

      // First-time tutorial prompt handlers
      if (tutorialYesBtn) {
        tutorialYesBtn.addEventListener('click', () => {
          tutorialPromptOverlay.classList.add('hidden');
          gameEngine.start(); // Make sure game engine is running
          TutorialManager.start(gameEngine);
        });
      }

      if (tutorialNoBtn) {
        tutorialNoBtn.addEventListener('click', () => {
          tutorialPromptOverlay.classList.add('hidden');
          // Mark as completed so we don't ask again
          const settings = StorageManager.loadSettings();
          settings.tutorialCompleted = true;
          StorageManager.saveSettings(settings);
        });
      }

      // Check if first-time user and show tutorial prompt
      const settings = StorageManager.loadSettings();
      if (!settings.tutorialCompleted) {
        tutorialPromptOverlay.classList.remove('hidden');
      }

      // Club selector toggle button handler
      const clubToggleBtn = document.getElementById('club-toggle-btn');
      const clubSelector = document.getElementById('club-selector');
      if (clubToggleBtn && clubSelector) {
        clubToggleBtn.addEventListener('click', () => {
          clubSelector.classList.toggle('minimized');
          clubToggleBtn.textContent = clubSelector.classList.contains('minimized') ? 'Show Clubs' : 'Hide Clubs';
        });
      }

      console.log('Howlett Golf Chaos - Ready!');
    });
  </script>
</body>
</html>
