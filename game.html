<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-fullscreen">
  <title>Howlett Golf Chaos</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      user-select: none;
    }

    body {
      width: 100vw;
      height: 100vh;
      overflow: hidden;
      background: #87CEEB;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
      touch-action: none;
    }

    #game-canvas {
      display: block;
      width: 100%;
      height: 100%;
      touch-action: none;
    }

    #ui-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }

    #ui-overlay > * {
      pointer-events: auto;
    }

    #scoreboard {
      position: absolute;
      top: 20px;
      left: 20px;
      background: rgba(255, 255, 255, 0.95);
      padding: 15px 20px;
      border-radius: 12px;
      font-size: 18px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    }

    #scoreboard div {
      margin: 5px 0;
    }

    #ball-state {
      position: absolute;
      top: 20px;
      right: 20px;
      background: rgba(255, 255, 255, 0.95);
      padding: 10px 20px;
      border-radius: 12px;
      font-size: 16px;
      font-weight: bold;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    }

    #distance-display {
      position: absolute;
      bottom: 20px;
      right: 20px;
      background: rgba(255, 255, 255, 0.95);
      padding: 15px 25px;
      border-radius: 12px;
      font-size: 24px;
      font-weight: bold;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      color: #2196F3;
    }

    #distance-display .label {
      font-size: 12px;
      color: #666;
      font-weight: normal;
      display: block;
      margin-bottom: 5px;
    }

    #club-selector-container {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: none;
    }

    #club-selector {
      background: rgba(255, 255, 255, 0.95);
      padding: 10px;
      border-radius: 12px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      transition: all 0.3s ease;
    }

    #club-selector.minimized {
      display: none;
    }

    #club-toggle-btn {
      background: rgba(255, 255, 255, 0.95);
      border: none;
      border-radius: 8px;
      padding: 10px 20px;
      font-size: 16px;
      font-weight: bold;
      cursor: pointer;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      margin-top: 10px;
      width: 100%;
    }

    #club-toggle-btn:active {
      background: rgba(230, 230, 230, 0.95);
    }

    .button {
      padding: 12px 24px;
      margin: 5px;
      background: #4CAF50;
      color: white;
      border: none;
      border-radius: 8px;
      font-size: 16px;
      cursor: pointer;
      font-weight: 600;
      transition: background 0.2s;
    }

    .button:active {
      background: #45a049;
    }

    .button.selected {
      background: #2196F3;
    }

    #debug-info {
      position: absolute;
      top: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 10px;
      border-radius: 8px;
      font-size: 14px;
      font-family: monospace;
    }

    #menu-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      justify-content: center;
      align-items: center;
      flex-direction: column;
    }

    #menu-overlay h1 {
      color: white;
      font-size: 48px;
      margin-bottom: 40px;
    }

    .menu-button {
      padding: 16px 48px;
      margin: 10px;
      background: #4CAF50;
      color: white;
      border: none;
      border-radius: 12px;
      font-size: 24px;
      cursor: pointer;
      font-weight: 700;
      transition: background 0.2s;
    }

    .menu-button:active {
      background: #45a049;
    }

    .hidden {
      display: none !important;
    }

    #scorecard-overlay {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(255, 255, 255, 0.98);
      padding: 30px;
      border-radius: 16px;
      box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
      max-width: 500px;
      max-height: 80vh;
      overflow-y: auto;
    }

    #scorecard-overlay h2 {
      margin-bottom: 20px;
      color: #333;
    }

    .scorecard-table {
      width: 100%;
      border-collapse: collapse;
      margin: 20px 0;
    }

    .scorecard-table th, .scorecard-table td {
      padding: 10px;
      text-align: center;
      border-bottom: 1px solid #ddd;
    }

    .scorecard-table th {
      background: #f5f5f5;
      font-weight: bold;
    }

    .score-birdie { color: #4CAF50; font-weight: bold; }
    .score-eagle { color: #FFD700; font-weight: bold; }
    .score-par { color: #2196F3; }
    .score-bogey { color: #FF9800; }
    .score-double { color: #F44336; }

    #round-progress {
      position: absolute;
      bottom: 80px;
      left: 20px;
      background: rgba(255, 255, 255, 0.95);
      padding: 10px 15px;
      border-radius: 8px;
      font-size: 14px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    }

    #reset-shot-btn {
      position: absolute;
      bottom: 100px;
      right: 20px;
      padding: 8px 16px;
      background: rgba(244, 67, 54, 0.9);
      color: white;
      border: none;
      border-radius: 8px;
      font-size: 14px;
      font-weight: bold;
      cursor: pointer;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
      z-index: 1000;
      transition: background 0.2s;
    }

    #reset-shot-btn:active {
      background: rgba(211, 47, 47, 0.95);
    }

    .club-power-info {
      font-size: 12px;
      color: #666;
      margin-top: 2px;
    }

    /* === Leaderboard Styles (T077) === */
    #leaderboard-overlay {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(255, 255, 255, 0.98);
      padding: 30px;
      border-radius: 16px;
      box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
      max-width: 600px;
      max-height: 80vh;
      overflow-y: auto;
      z-index: 1000;
    }

    #leaderboard-overlay h2 {
      margin-bottom: 20px;
      color: #333;
      text-align: center;
    }

    .leaderboard-table {
      width: 100%;
      border-collapse: collapse;
      margin: 20px 0;
    }

    .leaderboard-table th,
    .leaderboard-table td {
      padding: 12px;
      text-align: center;
      border-bottom: 1px solid #ddd;
    }

    .leaderboard-table th {
      background: #f5f5f5;
      font-weight: bold;
      position: sticky;
      top: 0;
    }

    .leaderboard-table tr:hover {
      background: #f9f9f9;
    }

    .leaderboard-rank {
      font-weight: bold;
      color: #666;
    }

    .leaderboard-rank-1 { color: #FFD700; }
    .leaderboard-rank-2 { color: #C0C0C0; }
    .leaderboard-rank-3 { color: #CD7F32; }

    .leaderboard-score-under { color: #4CAF50; font-weight: bold; }
    .leaderboard-score-par { color: #2196F3; }
    .leaderboard-score-over { color: #F44336; }

    .leaderboard-empty {
      text-align: center;
      padding: 40px 20px;
      color: #999;
      font-style: italic;
    }

    .new-best-indicator {
      background: #FFD700;
      color: #333;
      padding: 10px 20px;
      border-radius: 8px;
      margin-bottom: 20px;
      text-align: center;
      font-weight: bold;
      animation: pulse 1s ease-in-out;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }

    /* === Name Entry Modal Styles === */
    #name-entry-overlay {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(255, 255, 255, 0.98);
      padding: 30px;
      border-radius: 16px;
      box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
      max-width: 400px;
      width: 90%;
      z-index: 1001;
      text-align: center;
    }

    #name-entry-overlay h2 {
      margin-bottom: 10px;
      color: #333;
    }

    #name-entry-overlay p {
      color: #666;
      margin-bottom: 20px;
      font-size: 14px;
    }

    #player-name-input {
      width: 100%;
      padding: 15px;
      font-size: 18px;
      border: 2px solid #ddd;
      border-radius: 8px;
      margin-bottom: 20px;
      text-align: center;
      outline: none;
      transition: border-color 0.2s;
    }

    #player-name-input:focus {
      border-color: #4CAF50;
    }

    .name-entry-buttons {
      display: flex;
      gap: 10px;
      justify-content: center;
    }

    .name-entry-buttons .button {
      flex: 1;
      max-width: 150px;
    }

    .name-entry-buttons .cancel-btn {
      background: #999;
    }

    .name-entry-buttons .cancel-btn:active {
      background: #777;
    }

    /* Mobile phone optimizations */
    @media (max-width: 480px) {
      #scoreboard {
        top: 10px;
        left: 10px;
        padding: 8px 12px;
        font-size: 14px;
        border-radius: 8px;
      }

      #scoreboard div {
        margin: 3px 0;
      }

      #ball-state {
        top: 10px;
        right: 10px;
        padding: 6px 12px;
        font-size: 13px;
        border-radius: 8px;
      }

      #distance-display {
        bottom: 10px;
        right: 10px;
        padding: 10px 15px;
        font-size: 18px;
        border-radius: 8px;
      }

      #distance-display .label {
        font-size: 10px;
      }

      #club-selector-container {
        bottom: 10px;
        max-width: calc(100% - 20px);
      }

      #club-selector {
        padding: 5px;
        max-width: 100%;
        overflow-x: auto;
        overflow-y: hidden;
        white-space: nowrap;
        -webkit-overflow-scrolling: touch;
      }

      #club-toggle-btn {
        padding: 8px 16px;
        font-size: 14px;
        margin-top: 5px;
      }

      .button {
        padding: 8px 16px;
        margin: 3px;
        font-size: 13px;
        border-radius: 6px;
      }

      .club-power-info {
        font-size: 10px;
      }

      #menu-container {
        padding: 20px 15px;
      }

      #menu-container h1 {
        font-size: 32px;
      }

      #round-progress {
        top: auto;
        bottom: 120px;
        left: 10px;
        font-size: 12px;
        padding: 6px 12px;
      }

      .overlay-panel {
        padding: 20px 15px;
        max-width: 95%;
      }

      .overlay-panel h2 {
        font-size: 22px;
      }

      .scorecard-table, .leaderboard-table {
        font-size: 13px;
      }

      .scorecard-table th,
      .scorecard-table td,
      .leaderboard-table th,
      .leaderboard-table td {
        padding: 6px 8px;
      }
    }

    /* Small tablets and large phones */
    @media (min-width: 481px) and (max-width: 768px) {
      #scoreboard {
        top: 15px;
        left: 15px;
        padding: 12px 16px;
        font-size: 16px;
      }

      #ball-state {
        top: 15px;
        right: 15px;
        padding: 8px 16px;
        font-size: 14px;
      }

      #distance-display {
        bottom: 15px;
        right: 15px;
        padding: 12px 20px;
        font-size: 20px;
      }

      #club-selector-container {
        bottom: 15px;
        max-width: calc(100% - 30px);
      }

      #club-selector {
        overflow-x: auto;
        white-space: nowrap;
        -webkit-overflow-scrolling: touch;
      }

      .button {
        padding: 10px 20px;
        margin: 4px;
        font-size: 15px;
      }

      .club-power-info {
        font-size: 11px;
      }
    }
  </style>
</head>
<body>
  <canvas id="game-canvas"></canvas>

  <div id="ui-overlay">
    <div id="scoreboard">
      <div><strong>Hole:</strong> <span id="hole-number">1</span>/9</div>
      <div><strong>Par:</strong> <span id="hole-par">3</span></div>
      <div><strong>Strokes:</strong> <span id="stroke-count">0</span></div>
      <div><strong>Score:</strong> <span id="total-score">E</span></div>
      <div><strong>Club:</strong> <span id="current-club">Driver</span></div>
      <div><strong>Distance:</strong> <span id="distance-to-hole">---</span>m</div>
    </div>

    <div id="ball-state">üî¥ Ready</div>

    <div id="distance-display" class="hidden">
      <span class="label">Distance to Hole</span>
      <span id="distance-value">---</span>yd
    </div>

    <div id="round-progress" class="hidden">
      <strong>Progress:</strong> <span id="progress-text">0/9 holes</span>
    </div>

    <div id="club-selector-container">
      <div id="club-selector">
        <button class="button selected" data-club="driver">Driver</button>
      </div>
      <button id="club-toggle-btn">Hide Clubs</button>
    </div>

    <div id="scorecard-overlay" class="hidden">
      <h2>Scorecard</h2>
      <div id="scorecard-content"></div>
      <button class="button" onclick="document.getElementById('scorecard-overlay').classList.add('hidden')">Close</button>
    </div>

    <div id="leaderboard-overlay" class="hidden">
      <h2>üèÜ Leaderboard - Top 10</h2>
      <div id="leaderboard-content"></div>
      <button class="button" onclick="document.getElementById('leaderboard-overlay').classList.add('hidden')">Close</button>
    </div>

    <div id="name-entry-overlay" class="hidden">
      <h2>Enter Your Name</h2>
      <p>Your scores will appear on the global leaderboard!</p>
      <input type="text" id="player-name-input" maxlength="20" placeholder="Your name" autocomplete="off">
      <div class="name-entry-buttons">
        <button class="button" id="start-with-name-btn">Start Game</button>
        <button class="button cancel-btn" id="cancel-name-entry-btn">Cancel</button>
      </div>
    </div>

    <div id="debug-info" class="hidden"></div>

    <button id="reset-shot-btn" class="hidden">Cancel Shot</button>
  </div>

  <div id="menu-overlay">
    <h1>Howlett Golf Chaos</h1>
    <p style="color: white; font-size: 18px; margin: 20px; max-width: 500px; text-align: center;">
      üñ±Ô∏è Desktop: Click and drag backward from the ball, then release to swing<br>
      üì± Touch: Drag backward from the ball, then release
    </p>
    <button class="menu-button" id="new-game-btn">New Game</button>
    <button class="menu-button hidden" id="resume-game-btn">Resume Game</button>
    <button class="menu-button" id="leaderboard-btn">Leaderboard</button>
  </div>

  <script>
    'use strict';

    // T001-T005: Basic setup complete
    // T006-T012: Foundational modules below

    // === SeededRandom Class (T006) ===
    class SeededRandom {
      constructor(seed = Date.now()) {
        this.state = seed;
      }

      next() {
        let t = this.state += 0x6D2B79F5;
        t = Math.imul(t ^ t >>> 15, t | 1);
        t ^= t + Math.imul(t ^ t >>> 7, t | 61);
        return ((t ^ t >>> 14) >>> 0) / 4294967296;
      }

      nextInt(min, max) {
        return Math.floor(this.next() * (max - min + 1)) + min;
      }

      nextFloat(min, max) {
        return this.next() * (max - min) + min;
      }
    }

    // === PhysicsEngine Module (T008, T016, T017, T018) ===
    const PhysicsEngine = {
      gravity: 980,
      friction: 0.98,
      airResistance: 0.995,
      stopThreshold: 5,
      holeRadius: 15,

      add(v1, v2) {
        return { x: v1.x + v2.x, y: v1.y + v2.y };
      },

      subtract(v1, v2) {
        return { x: v1.x - v2.x, y: v1.y - v2.y };
      },

      magnitude(v) {
        return Math.sqrt(v.x * v.x + v.y * v.y);
      },

      normalize(v) {
        const mag = this.magnitude(v);
        if (mag === 0) return { x: 0, y: 0 };
        return { x: v.x / mag, y: v.y / mag };
      },

      distance(p1, p2) {
        const dx = p2.x - p1.x;
        const dy = p2.y - p1.y;
        return Math.sqrt(dx * dx + dy * dy);
      },

      applySwing(ball, swingVector) {
        const maxVelocity = 800;
        ball.velocityX = -Math.cos(swingVector.angle) * swingVector.power * maxVelocity;
        ball.velocityY = -Math.sin(swingVector.angle) * swingVector.power * maxVelocity;
        ball.isAirborne = true;
        ball.isMoving = true;
        ball.spin = swingVector.power * 0.5;
      },

      updateBall(ball, deltaTime, obstacles) {
        if (!ball.isMoving) return;

        // Apply friction (frame-rate independent: same slowdown regardless of FPS)
        const frictionFactor = Math.pow(this.friction, deltaTime * 60);
        ball.velocityX *= frictionFactor;
        ball.velocityY *= frictionFactor;

        // Update position
        ball.x += ball.velocityX * deltaTime;
        ball.y += ball.velocityY * deltaTime;

        // Check obstacle collisions
        if (obstacles) {
          this.checkObstacleCollisions(ball, obstacles);
        }

        // Stop ball if moving too slowly
        const speed = Math.sqrt(ball.velocityX * ball.velocityX + ball.velocityY * ball.velocityY);
        if (speed < this.stopThreshold) {
          ball.velocityX = 0;
          ball.velocityY = 0;
          ball.isMoving = false;
          ball.isAirborne = false;
        }

        ball.rotation += speed * deltaTime * 0.1;
        ball.distanceFromHole = this.distance(ball, ball.holePosition);
      },

      checkObstacleCollisions(ball, obstacles) {
        for (const obstacle of obstacles) {
          if (this.checkCollision(ball, obstacle)) {
            this.handleObstacleCollision(ball, obstacle);
          }
        }
      },

      checkCollision(ball, obstacle) {
        if (obstacle.shape === 'circle') {
          const dist = this.distance(ball, obstacle);
          return dist < (8 + obstacle.radius);
        } else if (obstacle.shape === 'rectangle') {
          return ball.x >= obstacle.x && ball.x <= obstacle.x + obstacle.width &&
                 ball.y >= obstacle.y && ball.y <= obstacle.y + obstacle.height;
        }
        return false;
      },

      handleObstacleCollision(ball, obstacle) {
        // Track if this is a new collision to avoid repeated sounds
        if (!ball.lastCollision || ball.lastCollision !== obstacle) {
          ball.lastCollision = obstacle;
          ball.collisionSoundPlayed = false;
        }

        if (obstacle.type === 'sand') {
          if (!ball.collisionSoundPlayed) {
            AudioManager.playLandSound('sand');
            ball.collisionSoundPlayed = true;
          }
          ball.velocityX *= 0.3;
          ball.velocityY *= 0.3;
          ball.isMoving = ball.velocityX !== 0 || ball.velocityY !== 0;
        } else if (obstacle.type === 'water') {
          if (!ball.collisionSoundPlayed) {
            AudioManager.playLandSound('water');
            ball.collisionSoundPlayed = true;
          }
          if (ball.lastSafePosition) {
            ball.x = ball.lastSafePosition.x;
            ball.y = ball.lastSafePosition.y;
            ball.velocityX = 0;
            ball.velocityY = 0;
            ball.isMoving = false;
            ball.waterPenalty = true;
          }
        } else if (obstacle.type === 'tree' || obstacle.type === 'rock') {
          if (!ball.collisionSoundPlayed) {
            AudioManager.playLandSound('grass');
            ball.collisionSoundPlayed = true;
          }
          const dx = ball.x - obstacle.x;
          const dy = ball.y - obstacle.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          const nx = dx / dist;
          const ny = dy / dist;

          ball.x = obstacle.x + nx * (obstacle.radius + 10);
          ball.y = obstacle.y + ny * (obstacle.radius + 10);

          const dotProduct = ball.velocityX * nx + ball.velocityY * ny;
          ball.velocityX = (ball.velocityX - 2 * dotProduct * nx) * 0.6;
          ball.velocityY = (ball.velocityY - 2 * dotProduct * ny) * 0.6;
        }
      },

      isBallInHole(ball) {
        if (ball.distanceFromHole >= this.holeRadius) return false;

        // Ball goes in if it's in the hole radius and moving slowly or stopped
        const speed = Math.sqrt(ball.velocityX * ball.velocityX + ball.velocityY * ball.velocityY);
        const slowEnough = speed < 50; // Ball moving slower than 50 units/second

        return slowEnough;
      }
    };

    // === Renderer Module (T009, T019, T020, T021) ===
    const Renderer = {
      canvas: null,
      ctx: null,
      backgroundCache: null,

      init(canvas) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        this.backgroundCache = document.createElement('canvas');
        this.resizeCanvas();
        window.addEventListener('resize', () => this.resizeCanvas());
      },

      resizeCanvas() {
        const dpr = window.devicePixelRatio || 1;
        const rect = this.canvas.getBoundingClientRect();

        this.canvas.width = rect.width * dpr;
        this.canvas.height = rect.height * dpr;

        this.ctx.scale(dpr, dpr);

        this.canvas.style.width = rect.width + 'px';
        this.canvas.style.height = rect.height + 'px';
      },

      renderFrame(gameState) {
        if (!gameState) return;

        this.clearCanvas();

        if (gameState.currentHole && gameState.ball) {
          this.drawCourse(gameState.currentHole);
          if (gameState.currentHole.obstacles) {
            this.drawObstacles(gameState.currentHole.obstacles);
          }
          this.drawBall(gameState.ball);

          if (gameState.strikeFlash && gameState.strikeFlash.active) {
            this.drawStrikeFlash(gameState.ball, gameState.strikeFlash);
          }
        }

        const swingPreview = InputHandler.getSwingPreview();
        if (swingPreview && gameState.ball && !gameState.ball.isMoving) {
          this.drawGuideArrow(swingPreview, gameState.ball, gameState.selectedClub);
        }
      },

      clearCanvas() {
        const rect = this.canvas.getBoundingClientRect();
        this.ctx.clearRect(0, 0, rect.width, rect.height);
      },

      clearRegion(x, y, width, height) {
        this.ctx.clearRect(x, y, width, height);
      },

      drawCourse(hole) {
        const ctx = this.ctx;

        ctx.fillStyle = '#90EE90';
        ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        ctx.fillStyle = '#2E8B57';
        ctx.fillRect(hole.teePosition.x - 40, hole.teePosition.y - 40, 80, 80);

        ctx.fillStyle = '#228B22';
        const greenRadius = 80;
        ctx.beginPath();
        ctx.arc(hole.greenPosition.x, hole.greenPosition.y, greenRadius, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = '#000000';
        ctx.beginPath();
        ctx.arc(hole.holePosition.x, hole.holePosition.y, 15, 0, Math.PI * 2);
        ctx.fill();

        ctx.strokeStyle = '#8B4513';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(hole.holePosition.x, hole.holePosition.y);
        ctx.lineTo(hole.holePosition.x, hole.holePosition.y - 50);
        ctx.stroke();

        ctx.fillStyle = '#FF0000';
        ctx.beginPath();
        ctx.moveTo(hole.holePosition.x, hole.holePosition.y - 50);
        ctx.lineTo(hole.holePosition.x + 20, hole.holePosition.y - 40);
        ctx.lineTo(hole.holePosition.x, hole.holePosition.y - 30);
        ctx.fill();
      },

      drawObstacles(obstacles) {
        const ctx = this.ctx;

        for (const obstacle of obstacles) {
          if (obstacle.type === 'sand') {
            ctx.fillStyle = '#DEB887';
            ctx.beginPath();
            ctx.arc(obstacle.x, obstacle.y, obstacle.radius, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = 'rgba(222, 184, 135, 0.5)';
            for (let i = 0; i < 3; i++) {
              ctx.beginPath();
              ctx.arc(obstacle.x + (i - 1) * 8, obstacle.y + (i - 1) * 5, obstacle.radius * 0.6, 0, Math.PI * 2);
              ctx.fill();
            }
          } else if (obstacle.type === 'water') {
            const gradient = ctx.createLinearGradient(obstacle.x, obstacle.y, obstacle.x, obstacle.y + obstacle.height);
            gradient.addColorStop(0, '#4682B4');
            gradient.addColorStop(1, '#1E3A5F');

            ctx.fillStyle = gradient;
            ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);

            ctx.strokeStyle = '#6495ED';
            ctx.lineWidth = 2;
            ctx.beginPath();
            for (let i = 0; i < obstacle.width; i += 10) {
              ctx.moveTo(obstacle.x + i, obstacle.y + 5);
              ctx.quadraticCurveTo(obstacle.x + i + 5, obstacle.y, obstacle.x + i + 10, obstacle.y + 5);
            }
            ctx.stroke();
          } else if (obstacle.type === 'tree') {
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(obstacle.x - 5, obstacle.y, 10, 20);

            const treeGradient = ctx.createRadialGradient(obstacle.x, obstacle.y - obstacle.radius / 2, 0, obstacle.x, obstacle.y - obstacle.radius / 2, obstacle.radius);
            treeGradient.addColorStop(0, '#228B22');
            treeGradient.addColorStop(1, '#006400');

            ctx.fillStyle = treeGradient;
            ctx.beginPath();
            ctx.arc(obstacle.x, obstacle.y - obstacle.radius / 2, obstacle.radius, 0, Math.PI * 2);
            ctx.fill();
          } else if (obstacle.type === 'rock') {
            const rockGradient = ctx.createRadialGradient(obstacle.x - 5, obstacle.y - 5, 0, obstacle.x, obstacle.y, obstacle.radius);
            rockGradient.addColorStop(0, '#A9A9A9');
            rockGradient.addColorStop(1, '#696969');

            ctx.fillStyle = rockGradient;
            ctx.beginPath();
            ctx.arc(obstacle.x, obstacle.y, obstacle.radius, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.beginPath();
            ctx.ellipse(obstacle.x + 5, obstacle.y + obstacle.radius + 2, obstacle.radius * 0.8, obstacle.radius * 0.3, 0, 0, Math.PI * 2);
            ctx.fill();
          }
        }
      },

      drawBall(ball) {
        const ctx = this.ctx;

        if (ball.inHole && ball.holeProgress !== undefined) {
          const fadeProgress = ball.holeProgress;
          if (fadeProgress >= 1) return;

          ctx.save();
          ctx.globalAlpha = 1 - fadeProgress;
          ctx.translate(ball.x, ball.y);
          ctx.rotate(ball.rotation);

          const scale = 1 - (fadeProgress * 0.5);
          ctx.scale(scale, scale);

          const gradient = ctx.createRadialGradient(-2, -2, 0, 0, 0, 8);
          gradient.addColorStop(0, '#FFFFFF');
          gradient.addColorStop(1, '#CCCCCC');

          ctx.fillStyle = gradient;
          ctx.beginPath();
          ctx.arc(0, 0, 8, 0, Math.PI * 2);
          ctx.fill();

          ctx.strokeStyle = '#999999';
          ctx.lineWidth = 0.5;
          ctx.stroke();

          ctx.restore();
          return;
        }

        ctx.save();
        ctx.translate(ball.x, ball.y);
        ctx.rotate(ball.rotation);

        const gradient = ctx.createRadialGradient(-2, -2, 0, 0, 0, 8);
        gradient.addColorStop(0, '#FFFFFF');
        gradient.addColorStop(1, '#CCCCCC');

        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(0, 0, 8, 0, Math.PI * 2);
        ctx.fill();

        ctx.strokeStyle = '#999999';
        ctx.lineWidth = 0.5;
        ctx.stroke();

        ctx.restore();
      },

      drawGuideArrow(swingPreview, ball, selectedClub) {
        const ctx = this.ctx;
        const dx = swingPreview.current.x - swingPreview.start.x;
        const dy = swingPreview.current.y - swingPreview.start.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        const swingPower = Math.min(distance / 150, 1.0); // User's swing 0-100%

        const club = ClubSystem.getClub(selectedClub || 'driver');
        const effectivePower = swingPower * club.maxPower; // Actual ball power

        const arrowLength = effectivePower * 150;
        const angle = Math.atan2(dy, dx) + Math.PI;

        const endX = ball.x + Math.cos(angle) * arrowLength;
        const endY = ball.y + Math.sin(angle) * arrowLength;

        // Color based on user's swing power (0-100%), not club-adjusted power
        const arrowColor = swingPower > 0.8 ? [255, 100, 0] :
                          swingPower > 0.5 ? [255, 200, 0] : [100, 200, 255];

        ctx.strokeStyle = `rgba(${arrowColor[0]}, ${arrowColor[1]}, ${arrowColor[2]}, ${0.4 + effectivePower * 0.4})`;
        ctx.lineWidth = 3 + effectivePower * 5;
        ctx.setLineDash([5, 5]);

        ctx.beginPath();
        ctx.moveTo(ball.x, ball.y);
        ctx.lineTo(endX, endY);
        ctx.stroke();

        ctx.setLineDash([]);

        const arrowSize = 12 + effectivePower * 12;
        ctx.fillStyle = `rgba(${arrowColor[0]}, ${arrowColor[1]}, ${arrowColor[2]}, ${0.6 + effectivePower * 0.4})`;
        ctx.beginPath();
        ctx.moveTo(endX, endY);
        ctx.lineTo(
          endX - arrowSize * Math.cos(angle - Math.PI / 6),
          endY - arrowSize * Math.sin(angle - Math.PI / 6)
        );
        ctx.lineTo(
          endX - arrowSize * Math.cos(angle + Math.PI / 6),
          endY - arrowSize * Math.sin(angle + Math.PI / 6)
        );
        ctx.closePath();
        ctx.fill();

        ctx.font = 'bold 16px Arial';
        ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
        ctx.fillText(`Power: ${Math.round(swingPower * 100)}%`, ball.x + 15, ball.y - 15);
        ctx.fillText(`${club.name}`, ball.x + 15, ball.y - 35);

        const powerBarWidth = 100;
        const powerBarHeight = 10;
        const powerBarX = ball.x - powerBarWidth / 2;
        const powerBarY = ball.y - 55;

        ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
        ctx.fillRect(powerBarX, powerBarY, powerBarWidth, powerBarHeight);

        ctx.fillStyle = `rgba(${arrowColor[0]}, ${arrowColor[1]}, ${arrowColor[2]}, 0.8)`;
        ctx.fillRect(powerBarX, powerBarY, powerBarWidth * swingPower, powerBarHeight);

        ctx.strokeStyle = 'rgba(0, 0, 0, 0.6)';
        ctx.lineWidth = 2;
        ctx.strokeRect(powerBarX, powerBarY, powerBarWidth, powerBarHeight);
      },

      drawStrikeFlash(ball, strikeFlash) {
        const ctx = this.ctx;
        const progress = strikeFlash.progress;
        const alpha = 1 - progress;
        const radius = 15 + progress * 20;

        ctx.save();
        ctx.globalAlpha = alpha * 0.6;

        const gradient = ctx.createRadialGradient(ball.x, ball.y, 0, ball.x, ball.y, radius);
        gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
        gradient.addColorStop(0.5, 'rgba(255, 200, 0, 0.8)');
        gradient.addColorStop(1, 'rgba(255, 100, 0, 0)');

        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(ball.x, ball.y, radius, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();
      }
    };

    // === InputHandler Module (T010 + Mouse Support) ===
    const InputHandler = {
      canvas: null,
      gameEngine: null,
      touchStartPos: null,
      currentTouchPos: null,
      isSwinging: false,

      init(canvas, gameEngine) {
        this.canvas = canvas;
        this.gameEngine = gameEngine;

        canvas.addEventListener('touchstart', (e) => this.onTouchStart(e), { passive: false });
        canvas.addEventListener('touchmove', (e) => this.onTouchMove(e), { passive: false });
        canvas.addEventListener('touchend', (e) => this.onTouchEnd(e), { passive: false });

        canvas.addEventListener('mousedown', (e) => this.onMouseDown(e));
        canvas.addEventListener('mousemove', (e) => this.onMouseMove(e));
        canvas.addEventListener('mouseup', (e) => this.onMouseUp(e));

        const resetBtn = document.getElementById('reset-shot-btn');
        resetBtn.addEventListener('click', () => this.resetShot());
      },

      resetShot() {
        this.touchStartPos = null;
        this.currentTouchPos = null;
        this.isSwinging = false;
        document.getElementById('reset-shot-btn').classList.add('hidden');
      },

      onTouchStart(e) {
        e.preventDefault();
        if (this.gameEngine && this.gameEngine.gameState && this.gameEngine.gameState.ball && this.gameEngine.gameState.ball.isMoving) {
          return;
        }
        const touch = e.touches[0];
        const rect = this.canvas.getBoundingClientRect();
        this.touchStartPos = {
          x: touch.clientX - rect.left,
          y: touch.clientY - rect.top
        };
        this.isSwinging = true;
      },

      onTouchMove(e) {
        e.preventDefault();
        if (!this.isSwinging) return;

        const touch = e.touches[0];
        const rect = this.canvas.getBoundingClientRect();
        this.currentTouchPos = {
          x: touch.clientX - rect.left,
          y: touch.clientY - rect.top
        };

        document.getElementById('reset-shot-btn').classList.remove('hidden');
      },

      onTouchEnd(e) {
        e.preventDefault();
        if (!this.isSwinging) return;

        document.getElementById('reset-shot-btn').classList.add('hidden');

        const swingVector = this.calculateSwingVector();
        if (swingVector && this.gameEngine) {
          this.gameEngine.executeSwing(swingVector);
        }

        this.touchStartPos = null;
        this.currentTouchPos = null;
        this.isSwinging = false;
      },

      onMouseDown(e) {
        if (this.gameEngine && this.gameEngine.gameState && this.gameEngine.gameState.ball && this.gameEngine.gameState.ball.isMoving) {
          return;
        }
        const rect = this.canvas.getBoundingClientRect();
        this.touchStartPos = {
          x: e.clientX - rect.left,
          y: e.clientY - rect.top
        };
        this.isSwinging = true;
      },

      onMouseMove(e) {
        if (!this.isSwinging) return;

        const rect = this.canvas.getBoundingClientRect();
        this.currentTouchPos = {
          x: e.clientX - rect.left,
          y: e.clientY - rect.top
        };

        document.getElementById('reset-shot-btn').classList.remove('hidden');
      },

      onMouseUp(e) {
        if (!this.isSwinging) return;

        document.getElementById('reset-shot-btn').classList.add('hidden');

        const swingVector = this.calculateSwingVector();
        if (swingVector && this.gameEngine) {
          this.gameEngine.executeSwing(swingVector);
        }

        this.touchStartPos = null;
        this.currentTouchPos = null;
        this.isSwinging = false;
      },

      calculateSwingVector() {
        if (!this.touchStartPos || !this.currentTouchPos) return null;

        const dx = this.currentTouchPos.x - this.touchStartPos.x;
        const dy = this.currentTouchPos.y - this.touchStartPos.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        const angle = Math.atan2(dy, dx);

        return {
          power: Math.min(distance / 150, 1.0),
          angle: angle
        };
      },

      getSwingPreview() {
        return this.currentTouchPos && this.touchStartPos ? {
          start: this.touchStartPos,
          current: this.currentTouchPos
        } : null;
      }
    };

    // === CourseGenerator Module (T026-T029) ===
    const CourseGenerator = {
      holeTemplates: null,
      rng: null,

      init(seed) {
        this.rng = new SeededRandom(seed);
        this.holeTemplates = this.defineHoleTemplates();
      },

      defineHoleTemplates() {
        return [
          { holeNumber: 1, par: 3, length: 'short', distance: 525 },
          { holeNumber: 2, par: 4, length: 'medium', distance: 788 },
          { holeNumber: 3, par: 3, length: 'short', distance: 438 },
          { holeNumber: 4, par: 5, length: 'long', distance: 1050 },
          { holeNumber: 5, par: 4, length: 'medium', distance: 700 },
          { holeNumber: 6, par: 4, length: 'medium', distance: 875 },
          { holeNumber: 7, par: 3, length: 'short', distance: 490 },
          { holeNumber: 8, par: 5, length: 'long', distance: 1138 },
          { holeNumber: 9, par: 4, length: 'medium', distance: 840 }
        ];
      },

      generateHole(holeNumber, canvasWidth, canvasHeight) {
        const template = this.holeTemplates[holeNumber - 1];

        const teeX = 100;
        const teeY = canvasHeight / 2 + this.rng.nextInt(-50, 50);

        const greenX = Math.min(teeX + template.distance, canvasWidth - 150);
        const greenY = canvasHeight / 2 + this.rng.nextInt(-100, 100);

        const hole = {
          holeNumber: template.holeNumber,
          par: template.par,
          length: template.length,
          teePosition: { x: teeX, y: teeY },
          greenPosition: { x: greenX, y: greenY },
          holePosition: { x: greenX, y: greenY },
          obstacles: this.placeObstacles(template, teeX, teeY, greenX, greenY, canvasWidth, canvasHeight)
        };

        return hole;
      },

      placeObstacles(template, teeX, teeY, greenX, greenY, canvasWidth, canvasHeight) {
        const obstacles = [];
        const obstacleCount = template.length === 'short' ? this.rng.nextInt(2, 4) :
                             template.length === 'medium' ? this.rng.nextInt(3, 5) :
                             this.rng.nextInt(4, 6);

        const midX = (teeX + greenX) / 2;
        const midY = (teeY + greenY) / 2;

        for (let i = 0; i < obstacleCount; i++) {
          const rand = this.rng.next();
          let type;
          if (rand < 0.35) type = 'sand';
          else if (rand < 0.6) type = 'tree';
          else if (rand < 0.85) type = 'rock';
          else type = 'water';

          const offsetX = this.rng.nextInt(-200, 200);
          const offsetY = this.rng.nextInt(-150, 150);
          const x = midX + offsetX;
          const y = midY + offsetY;

          const distFromTee = Math.sqrt((x - teeX) ** 2 + (y - teeY) ** 2);
          const distFromGreen = Math.sqrt((x - greenX) ** 2 + (y - greenY) ** 2);

          if (distFromTee > 80 && distFromGreen > 100 && x > 50 && x < canvasWidth - 50 && y > 50 && y < canvasHeight - 50) {
            obstacles.push({
              type: type,
              x: x,
              y: y,
              radius: type === 'tree' ? 25 : type === 'rock' ? 20 : 30,
              width: type === 'water' ? this.rng.nextInt(60, 100) : 0,
              height: type === 'water' ? this.rng.nextInt(40, 60) : 0,
              shape: type === 'water' ? 'rectangle' : 'circle'
            });
          }
        }

        return obstacles;
      }
    };

    // === ScoreKeeper Module (T022, T033, T057-T063) ===
    const ScoreKeeper = {
      recordStroke(round) {
        round.currentStrokeCount++;
        this.updateUI(round);
      },

      getCurrentStrokes(round) {
        return round.currentStrokeCount;
      },

      completeHole(round, hole) {
        const holeScore = {
          holeNumber: hole.holeNumber,
          strokes: round.currentStrokeCount,
          par: hole.par,
          scoreRelativeToPar: round.currentStrokeCount - hole.par
        };

        round.holeScores.push(holeScore);
        round.totalStrokes += round.currentStrokeCount;
        round.totalPar += hole.par;
        round.scoreRelativeToPar = round.totalStrokes - round.totalPar;

        return holeScore;
      },

      getRoundSummary(round) {
        return {
          totalStrokes: round.totalStrokes,
          totalPar: round.totalPar,
          scoreRelativeToPar: round.scoreRelativeToPar,
          holeScores: round.holeScores,
          completedHoles: round.holeScores.length,
          remainingHoles: 9 - round.holeScores.length
        };
      },

      updateUI(round) {
        document.getElementById('stroke-count').textContent = round.currentStrokeCount;
        document.getElementById('total-score').textContent = this.getScoreDisplay(round.scoreRelativeToPar);
      },

      getScoreDisplay(score) {
        if (score === 0) return 'E';
        if (score > 0) return `+${score}`;
        return `${score}`;
      },

      getScoreColor(scoreRelativeToPar) {
        if (scoreRelativeToPar <= -2) return '#FFD700';
        if (scoreRelativeToPar === -1) return '#4CAF50';
        if (scoreRelativeToPar === 0) return '#2196F3';
        if (scoreRelativeToPar === 1) return '#FF9800';
        return '#F44336';
      },

      getScoreName(scoreRelativeToPar) {
        if (scoreRelativeToPar <= -3) return 'Albatross!';
        if (scoreRelativeToPar === -2) return 'Eagle!';
        if (scoreRelativeToPar === -1) return 'Birdie!';
        if (scoreRelativeToPar === 0) return 'Par';
        if (scoreRelativeToPar === 1) return 'Bogey';
        if (scoreRelativeToPar === 2) return 'Double Bogey';
        return `+${scoreRelativeToPar}`;
      }
    };

    // === ClubSystem Module (T039-T043, T048-T049) ===
    const ClubSystem = {
      clubs: {
        driver: { id: 'driver', name: 'Driver', maxPower: 1.0, arcMultiplier: 1.0, spinMultiplier: 1.0 },
        wood3: { id: 'wood3', name: '3 Wood', maxPower: 0.9, arcMultiplier: 0.95, spinMultiplier: 0.95 },
        wood5: { id: 'wood5', name: '5 Wood', maxPower: 0.85, arcMultiplier: 0.9, spinMultiplier: 0.9 },
        iron4: { id: 'iron4', name: '4 Iron', maxPower: 0.8, arcMultiplier: 0.85, spinMultiplier: 1.1 },
        iron5: { id: 'iron5', name: '5 Iron', maxPower: 0.75, arcMultiplier: 0.8, spinMultiplier: 1.15 },
        iron6: { id: 'iron6', name: '6 Iron', maxPower: 0.7, arcMultiplier: 0.75, spinMultiplier: 1.2 },
        iron7: { id: 'iron7', name: '7 Iron', maxPower: 0.65, arcMultiplier: 0.7, spinMultiplier: 1.25 },
        iron8: { id: 'iron8', name: '8 Iron', maxPower: 0.6, arcMultiplier: 0.65, spinMultiplier: 1.3 },
        iron9: { id: 'iron9', name: '9 Iron', maxPower: 0.55, arcMultiplier: 0.6, spinMultiplier: 1.35 },
        wedge: { id: 'wedge', name: 'Wedge', maxPower: 0.5, arcMultiplier: 0.55, spinMultiplier: 1.5 },
        putter: { id: 'putter', name: 'Putter', maxPower: 0.3, arcMultiplier: 0.0, spinMultiplier: 0.0 }
      },

      getClub(clubId) {
        return this.clubs[clubId] || this.clubs.driver;
      },

      getAllClubs() {
        return Object.values(this.clubs);
      },

      getAvailableClubs(isFirstStroke) {
        if (isFirstStroke) {
          return [this.clubs.driver];
        }
        return this.getAllClubs();
      },

      applyClubToSwing(swingVector, clubId) {
        const club = this.getClub(clubId);
        return {
          power: swingVector.power * club.maxPower,
          angle: swingVector.angle,
          arc: club.arcMultiplier,
          spin: club.spinMultiplier
        };
      },

      getRecommendedClub(ball, holePosition) {
        const distance = PhysicsEngine.distance(ball, holePosition);

        if (distance < 50) {
          return 'putter';
        } else if (distance < 100) {
          return 'wedge';
        } else if (distance < 150) {
          return 'iron9';
        } else if (distance < 200) {
          return 'iron7';
        } else if (distance < 250) {
          return 'iron5';
        } else if (distance < 350) {
          return 'iron4';
        } else if (distance < 450) {
          return 'wood5';
        } else {
          return 'driver';
        }
      },

      // Calculate max distance for a club at 100% power (in yards)
      getMaxDistance(clubId) {
        const club = this.getClub(clubId);
        const maxVelocity = 800;
        const friction = 0.98;
        const stopThreshold = 5;
        const deltaTime = 1/60; // 60 FPS

        // Simulate ball flight
        let velocityX = maxVelocity * club.maxPower;
        let distance = 0;

        while (Math.abs(velocityX) > stopThreshold) {
          distance += velocityX * deltaTime;
          velocityX *= friction;
        }

        // Convert meters to yards (1m = 1.09361yd)
        return Math.round(distance * 1.09361);
      }
    };

    // === StorageManager Module (T064-T073) ===
    const StorageManager = {
      dbName: 'CartoonGolfDB',
      dbVersion: 1,
      storeName: 'gameStates',
      db: null,

      async init() {
        return new Promise((resolve, reject) => {
          const request = indexedDB.open(this.dbName, this.dbVersion);

          request.onerror = () => {
            console.error('IndexedDB error:', request.error);
            reject(request.error);
          };

          request.onsuccess = () => {
            this.db = request.result;
            resolve(this.db);
          };

          request.onupgradeneeded = (event) => {
            const db = event.target.result;

            if (!db.objectStoreNames.contains(this.storeName)) {
              const objectStore = db.createObjectStore(this.storeName, { keyPath: 'id' });
              objectStore.createIndex('timestamp', 'timestamp', { unique: false });
            }
          };
        });
      },

      async saveGameState(gameState) {
        try {
          if (!this.db) {
            await this.init();
          }

          const stateToSave = {
            id: 'current-game',
            timestamp: Date.now(),
            gameState: {
              currentHole: gameState.currentHole,
              round: gameState.round,
              ball: {
                x: gameState.ball.x,
                y: gameState.ball.y,
                velocityX: gameState.ball.velocityX,
                velocityY: gameState.ball.velocityY,
                spin: gameState.ball.spin,
                isAirborne: gameState.ball.isAirborne,
                isMoving: gameState.ball.isMoving,
                rotation: gameState.ball.rotation,
                groundY: gameState.ball.groundY,
                holePosition: gameState.ball.holePosition,
                distanceFromHole: gameState.ball.distanceFromHole,
                lastSafePosition: gameState.ball.lastSafePosition,
                waterPenalty: gameState.ball.waterPenalty
              },
              selectedClub: gameState.selectedClub,
              seed: gameState.seed
            }
          };

          const transaction = this.db.transaction([this.storeName], 'readwrite');
          const objectStore = transaction.objectStore(this.storeName);
          const request = objectStore.put(stateToSave);

          return new Promise((resolve, reject) => {
            request.onsuccess = () => resolve(true);
            request.onerror = () => {
              console.error('Save error:', request.error);
              reject(request.error);
            };
          });
        } catch (error) {
          console.error('Failed to save game state:', error);
          return false;
        }
      },

      async loadGameState() {
        try {
          if (!this.db) {
            await this.init();
          }

          const transaction = this.db.transaction([this.storeName], 'readonly');
          const objectStore = transaction.objectStore(this.storeName);
          const request = objectStore.get('current-game');

          return new Promise((resolve, reject) => {
            request.onsuccess = () => {
              if (request.result) {
                resolve(request.result.gameState);
              } else {
                resolve(null);
              }
            };
            request.onerror = () => {
              console.error('Load error:', request.error);
              reject(request.error);
            };
          });
        } catch (error) {
          console.error('Failed to load game state:', error);
          return null;
        }
      },

      async clearGameState() {
        try {
          if (!this.db) {
            await this.init();
          }

          const transaction = this.db.transaction([this.storeName], 'readwrite');
          const objectStore = transaction.objectStore(this.storeName);
          const request = objectStore.delete('current-game');

          return new Promise((resolve, reject) => {
            request.onsuccess = () => resolve(true);
            request.onerror = () => {
              console.error('Clear error:', request.error);
              reject(request.error);
            };
          });
        } catch (error) {
          console.error('Failed to clear game state:', error);
          return false;
        }
      },

      async hasSavedGame() {
        try {
          const savedState = await this.loadGameState();
          return savedState !== null && !savedState.round.isComplete;
        } catch (error) {
          console.error('Error checking for saved game:', error);
          return false;
        }
      },

      saveSettings(settings) {
        try {
          localStorage.setItem('golf-settings', JSON.stringify(settings));
          return true;
        } catch (error) {
          console.error('Failed to save settings:', error);
          return false;
        }
      },

      loadSettings() {
        try {
          const settings = localStorage.getItem('golf-settings');
          return settings ? JSON.parse(settings) : this.getDefaultSettings();
        } catch (error) {
          console.error('Failed to load settings:', error);
          return this.getDefaultSettings();
        }
      },

      getDefaultSettings() {
        return {
          soundEnabled: true,
          debugMode: false
        };
      },

      // === Leaderboard Methods (T074-T076) ===
      async addLeaderboardEntry(entry) {
        try {
          if (!this.db) {
            await this.init();
          }

          const leaderboard = await this.getLeaderboard();

          // Add new entry
          leaderboard.push({
            scoreRelativeToPar: entry.scoreRelativeToPar,
            totalStrokes: entry.totalStrokes,
            completedAt: entry.completedAt || Date.now(),
            playerInitials: entry.playerInitials || 'YOU'
          });

          // Sort by score (lower is better)
          leaderboard.sort((a, b) => a.scoreRelativeToPar - b.scoreRelativeToPar);

          // Keep only top 10
          const top10 = leaderboard.slice(0, 10);

          // Save to IndexedDB
          const transaction = this.db.transaction([this.storeName], 'readwrite');
          const objectStore = transaction.objectStore(this.storeName);
          const request = objectStore.put({
            id: 'leaderboard',
            entries: top10,
            timestamp: Date.now()
          });

          return new Promise((resolve, reject) => {
            request.onsuccess = () => resolve(top10);
            request.onerror = () => {
              console.error('Leaderboard save error:', request.error);
              reject(request.error);
            };
          });
        } catch (error) {
          console.error('Failed to add leaderboard entry:', error);
          return [];
        }
      },

      async getLeaderboard() {
        try {
          if (!this.db) {
            await this.init();
          }

          const transaction = this.db.transaction([this.storeName], 'readonly');
          const objectStore = transaction.objectStore(this.storeName);
          const request = objectStore.get('leaderboard');

          return new Promise((resolve, reject) => {
            request.onsuccess = () => {
              if (request.result && request.result.entries) {
                resolve(request.result.entries);
              } else {
                resolve([]);
              }
            };
            request.onerror = () => {
              console.error('Leaderboard load error:', request.error);
              reject(request.error);
            };
          });
        } catch (error) {
          console.error('Failed to load leaderboard:', error);
          return [];
        }
      }
    };

    // === AudioManager Module (T073f, T073g) ===
    const AudioManager = {
      context: null,
      sounds: {},
      muted: false,

      init() {
        try {
          this.context = new (window.AudioContext || window.webkitAudioContext)();
          this.muted = StorageManager.loadSettings().soundEnabled === false;
        } catch (error) {
          console.error('Web Audio API not supported:', error);
        }
      },

      unlock() {
        if (!this.context) return;

        if (this.context.state === 'suspended') {
          this.context.resume();
        }

        const buffer = this.context.createBuffer(1, 1, 22050);
        const source = this.context.createBufferSource();
        source.buffer = buffer;
        source.connect(this.context.destination);
        source.start(0);
      },

      // === T096: Enhanced club hit sounds ===
      playHitSound(power) {
        if (this.muted || !this.context) return;

        const oscillator = this.context.createOscillator();
        const gainNode = this.context.createGain();

        oscillator.connect(gainNode);
        gainNode.connect(this.context.destination);

        // Soft, medium, hard hit sounds based on power
        let frequency, volume, duration;
        if (power < 0.3) {
          frequency = 180;
          volume = 0.08;
          duration = 0.04;
        } else if (power < 0.6) {
          frequency = 280;
          volume = 0.15;
          duration = 0.06;
        } else {
          frequency = 380;
          volume = 0.22;
          duration = 0.08;
        }

        oscillator.frequency.value = frequency;
        oscillator.type = 'sine';

        gainNode.gain.setValueAtTime(volume, this.context.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, this.context.currentTime + duration);

        oscillator.start(this.context.currentTime);
        oscillator.stop(this.context.currentTime + duration);
      },

      // === T097: Landing sounds based on surface ===
      playLandSound(surfaceType = 'grass') {
        if (this.muted || !this.context) return;

        const oscillator = this.context.createOscillator();
        const gainNode = this.context.createGain();

        oscillator.connect(gainNode);
        gainNode.connect(this.context.destination);

        let frequency, duration, volume;
        switch (surfaceType) {
          case 'sand':
            frequency = 120;
            duration = 0.15;
            volume = 0.12;
            break;
          case 'water':
            frequency = 200;
            duration = 0.2;
            volume = 0.18;
            oscillator.type = 'triangle';
            break;
          case 'grass':
          default:
            frequency = 150;
            duration = 0.08;
            volume = 0.1;
            break;
        }

        oscillator.frequency.value = frequency;
        if (surfaceType !== 'water') oscillator.type = 'sine';

        gainNode.gain.setValueAtTime(volume, this.context.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, this.context.currentTime + duration);

        oscillator.start(this.context.currentTime);
        oscillator.stop(this.context.currentTime + duration);
      },

      // === T098: Cheer sound for exceptional shots ===
      playCheerSound() {
        if (this.muted || !this.context) return;

        // Play a rising three-note cheer
        const notes = [523.25, 659.25, 783.99]; // C5, E5, G5
        notes.forEach((freq, i) => {
          setTimeout(() => {
            const osc = this.context.createOscillator();
            const gain = this.context.createGain();
            osc.connect(gain);
            gain.connect(this.context.destination);
            osc.frequency.value = freq;
            osc.type = 'sine';
            gain.gain.setValueAtTime(0.15, this.context.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, this.context.currentTime + 0.3);
            osc.start(this.context.currentTime);
            osc.stop(this.context.currentTime + 0.3);
          }, i * 100);
        });
      },

      // === T099: Hole completion jingle ===
      playHoleSound() {
        if (this.muted || !this.context) return;

        const oscillator = this.context.createOscillator();
        const gainNode = this.context.createGain();

        oscillator.connect(gainNode);
        gainNode.connect(this.context.destination);

        oscillator.frequency.value = 523.25;
        oscillator.type = 'sine';

        gainNode.gain.setValueAtTime(0.2, this.context.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, this.context.currentTime + 0.3);

        oscillator.start(this.context.currentTime);
        oscillator.stop(this.context.currentTime + 0.3);

        setTimeout(() => {
          const osc2 = this.context.createOscillator();
          const gain2 = this.context.createGain();
          osc2.connect(gain2);
          gain2.connect(this.context.destination);
          osc2.frequency.value = 659.25;
          osc2.type = 'sine';
          gain2.gain.setValueAtTime(0.2, this.context.currentTime);
          gain2.gain.exponentialRampToValueAtTime(0.01, this.context.currentTime + 0.3);
          osc2.start(this.context.currentTime);
          osc2.stop(this.context.currentTime + 0.3);
        }, 150);
      },

      // === T094, T100: Mute toggle ===
      setMuted(muted) {
        this.muted = muted;
        const settings = StorageManager.loadSettings();
        settings.soundEnabled = !muted;
        StorageManager.saveSettings(settings);
      }
    };

    // === GameEngine Module (T007, T011, T013-T025) ===
    class GameEngine {
      constructor(canvas) {
        this.canvas = canvas;
        this.isRunning = false;
        this.isPaused = false;
        this.lastFrameTime = 0;
        this.fps = 60;
        this.debugMode = false;
        this.holeCompleting = false;

        this.gameState = null;

        Renderer.init(canvas);
        InputHandler.init(canvas, this);

        this.checkDebugMode();
      }

      checkDebugMode() {
        const params = new URLSearchParams(window.location.search);
        this.debugMode = params.get('debug') === 'true';
        if (this.debugMode) {
          document.getElementById('debug-info').classList.remove('hidden');
        }
      }

      start() {
        this.isRunning = true;
        this.lastFrameTime = performance.now();
        requestAnimationFrame((t) => this.update(t));
      }

      pause() {
        this.isPaused = true;
      }

      resume() {
        this.isPaused = false;
        this.lastFrameTime = performance.now();
      }

      async startNewRound(seed = null, playerName = 'Player') {
        const usedSeed = seed || Date.now();
        CourseGenerator.init(usedSeed);

        const canvasRect = this.canvas.getBoundingClientRect();
        const hole = CourseGenerator.generateHole(1, canvasRect.width, canvasRect.height);

        const ball = this.createBall(hole);

        this.gameState = {
          currentHole: hole,
          round: {
            roundId: 'round-' + Date.now(),
            startTime: Date.now(),
            endTime: null,
            currentHoleNumber: 1,
            isComplete: false,
            holeScores: [],
            totalStrokes: 0,
            totalPar: 0,
            scoreRelativeToPar: 0,
            currentStrokeCount: 0
          },
          ball: ball,
          selectedClub: 'driver',
          seed: usedSeed,
          playerName: playerName
        };

        this.updateUI();
        document.getElementById('menu-overlay').classList.add('hidden');

        await StorageManager.clearGameState();
      }

      async loadRound() {
        try {
          const savedState = await StorageManager.loadGameState();
          if (!savedState) {
            console.error('No saved game state found');
            return false;
          }

          CourseGenerator.init(savedState.seed);

          const canvasRect = this.canvas.getBoundingClientRect();
          const hole = CourseGenerator.generateHole(
            savedState.round.currentHoleNumber,
            canvasRect.width,
            canvasRect.height
          );

          this.gameState = {
            currentHole: hole,
            round: savedState.round,
            ball: this.createBall(hole),
            selectedClub: savedState.selectedClub,
            seed: savedState.seed
          };

          this.gameState.ball.x = savedState.ball.x;
          this.gameState.ball.y = savedState.ball.y;
          this.gameState.ball.velocityX = savedState.ball.velocityX;
          this.gameState.ball.velocityY = savedState.ball.velocityY;
          this.gameState.ball.isMoving = savedState.ball.isMoving;
          this.gameState.ball.lastSafePosition = savedState.ball.lastSafePosition;

          // Ensure ball is never loaded in a "in hole" state (prevents infinite loop bug)
          this.gameState.ball.inHole = false;
          this.gameState.ball.holeProgress = 0;
          delete this.gameState.ball.holeStartTime;

          this.updateUI();
          this.updateRoundProgress();
          document.getElementById('menu-overlay').classList.add('hidden');

          return true;
        } catch (error) {
          console.error('Failed to load saved game:', error);
          return false;
        }
      }

      createBall(hole) {
        return {
          x: hole.teePosition.x,
          y: hole.teePosition.y,
          velocityX: 0,
          velocityY: 0,
          spin: 0,
          isAirborne: false,
          isMoving: false,
          rotation: 0,
          groundY: hole.teePosition.y,
          holePosition: hole.holePosition,
          distanceFromHole: PhysicsEngine.distance(hole.teePosition, hole.holePosition),
          lastSafePosition: { x: hole.teePosition.x, y: hole.teePosition.y },
          waterPenalty: false
        };
      }

      updateUI() {
        const round = this.gameState.round;
        const hole = this.gameState.currentHole;

        document.getElementById('hole-number').textContent = round.currentHoleNumber;
        document.getElementById('hole-par').textContent = hole.par;
        document.getElementById('stroke-count').textContent = round.currentStrokeCount;
        document.getElementById('total-score').textContent = ScoreKeeper.getScoreDisplay(round.scoreRelativeToPar);

        const club = ClubSystem.getClub(this.gameState.selectedClub);
        document.getElementById('current-club').textContent = club.name;

        // Convert distance from meters to yards (1m = 1.09361yd)
        const distance = Math.round(this.gameState.ball.distanceFromHole * 1.09361);
        document.getElementById('distance-to-hole').textContent = distance;

        // Update real-time distance display in lower right
        const distanceDisplay = document.getElementById('distance-display');
        const distanceValue = document.getElementById('distance-value');
        if (distanceDisplay && distanceValue) {
          distanceValue.textContent = distance;
          distanceDisplay.classList.remove('hidden');
        }

        this.updateClubSelector();
      }

      selectClub(clubId) {
        if (!this.gameState || !this.gameState.ball) return;
        if (this.gameState.ball.isMoving) return;

        const isFirstStroke = this.gameState.round.currentStrokeCount === 0;
        if (isFirstStroke && clubId !== 'driver') {
          return;
        }

        this.gameState.selectedClub = clubId;

        const club = ClubSystem.getClub(clubId);
        document.getElementById('current-club').textContent = club.name;

        this.updateClubSelector();
      }

      updateClubSelector() {
        if (!this.gameState) return;

        const isFirstStroke = this.gameState.round.currentStrokeCount === 0;
        const availableClubs = ClubSystem.getAvailableClubs(isFirstStroke);
        const selectedClub = this.gameState.selectedClub;

        const clubSelector = document.getElementById('club-selector');
        clubSelector.innerHTML = '';

        for (const club of availableClubs) {
          const button = document.createElement('button');
          button.className = 'button';
          button.dataset.club = club.id;

          const maxDistance = ClubSystem.getMaxDistance(club.id);
          button.innerHTML = `${club.name}<br><span class="club-power-info">${maxDistance}yd max</span>`;

          if (club.id === selectedClub) {
            button.classList.add('selected');
          }

          button.addEventListener('click', () => this.selectClub(club.id));
          clubSelector.appendChild(button);
        }

        const clubContainer = document.getElementById('club-selector-container');
        clubContainer.style.display = 'block';

        const recommendedClub = ClubSystem.getRecommendedClub(this.gameState.ball, this.gameState.currentHole.holePosition);
        const distanceFromHole = Math.round(this.gameState.ball.distanceFromHole);

        if (distanceFromHole < 100 && recommendedClub === 'putter' && selectedClub !== 'putter') {
          const putterButton = clubSelector.querySelector('[data-club="putter"]');
          if (putterButton && !isFirstStroke) {
            putterButton.style.border = '3px solid gold';
          }
        }
      }

      executeSwing(swingVector) {
        if (!this.gameState || !this.gameState.ball) return;
        if (this.gameState.ball.isMoving) return;
        if (this.gameState.round.isComplete) return; // Prevent strokes after round ends

        this.gameState.ball.lastSafePosition = { x: this.gameState.ball.x, y: this.gameState.ball.y };
        this.gameState.ball.waterPenalty = false;

        const modifiedSwing = ClubSystem.applyClubToSwing(swingVector, this.gameState.selectedClub);
        PhysicsEngine.applySwing(this.gameState.ball, modifiedSwing);
        ScoreKeeper.recordStroke(this.gameState.round);

        this.gameState.strikeFlash = { active: true, progress: 0, startTime: performance.now() };

        AudioManager.playHitSound(swingVector.power);

        if (this.gameState.ball.waterPenalty) {
          ScoreKeeper.recordStroke(this.gameState.round);
        }

        // Only save if ball is not in hole (prevents corrupted state on reload)
        if (!this.gameState.ball.inHole && !this.holeCompleting) {
          StorageManager.saveGameState(this.gameState);
        }
      }

      update(timestamp) {
        if (!this.isRunning) return;

        // Cap deltaTime to prevent physics jumps on slow devices or when resuming
        const rawDeltaTime = (timestamp - this.lastFrameTime) / 1000;
        const deltaTime = Math.min(rawDeltaTime, 1/30);
        this.lastFrameTime = timestamp;

        if (!this.isPaused && this.gameState) {
          this.updateFPS(deltaTime);

          if (this.gameState.strikeFlash && this.gameState.strikeFlash.active) {
            const elapsed = timestamp - this.gameState.strikeFlash.startTime;
            this.gameState.strikeFlash.progress = Math.min(elapsed / 300, 1);
            if (this.gameState.strikeFlash.progress >= 1) {
              this.gameState.strikeFlash.active = false;
            }
          }

          if (this.gameState.ball) {
            const obstacles = this.gameState.currentHole.obstacles || [];
            PhysicsEngine.updateBall(this.gameState.ball, deltaTime, obstacles);

            if (PhysicsEngine.isBallInHole(this.gameState.ball) && !this.holeCompleting) {
              if (!this.gameState.ball.inHole) {
                this.gameState.ball.inHole = true;
                this.gameState.ball.holeProgress = 0;
                this.gameState.ball.holeStartTime = timestamp;
                AudioManager.playHoleSound();
              }
            }

            if (this.gameState.ball.inHole) {
              const elapsed = timestamp - this.gameState.ball.holeStartTime;
              this.gameState.ball.holeProgress = Math.min(elapsed / 800, 1);

              if (this.gameState.ball.holeProgress >= 1 && !this.holeCompleting && !this.gameState.round.isComplete) {
                this.completeHole();
              }
            }

            this.updateBallStateIndicator();
          }

          Renderer.renderFrame(this.gameState);
        }

        requestAnimationFrame((t) => this.update(t));
      }

      updateBallStateIndicator() {
        const ball = this.gameState.ball;
        const stateElement = document.getElementById('ball-state');
        if (!stateElement) return;

        const wasMoving = this.ballWasMoving || false;
        this.ballWasMoving = ball.isMoving;

        // Update distance display in real-time
        const distance = Math.round(ball.distanceFromHole * 1.09361); // Convert to yards
        const distanceValue = document.getElementById('distance-value');
        if (distanceValue) {
          distanceValue.textContent = distance;
        }

        if (ball.isMoving) {
          const speed = Math.sqrt(ball.velocityX * ball.velocityX + ball.velocityY * ball.velocityY);
          if (speed > 100) {
            stateElement.textContent = 'üèåÔ∏è Flying';
            stateElement.style.color = '#FF6B35';
          } else {
            stateElement.textContent = '‚õ≥ Rolling';
            stateElement.style.color = '#4ECDC4';
          }
        } else {
          stateElement.textContent = 'üî¥ Ready';
          stateElement.style.color = '#2E8B57';

          if (wasMoving && !ball.isMoving) {
            this.updateClubSelector();
          }
        }
      }

      completeHole() {
        const round = this.gameState.round;
        const hole = this.gameState.currentHole;

        // Prevent completing hole without hitting the ball
        if (round.currentStrokeCount === 0) {
          return;
        }

        // Prevent multiple simultaneous completions
        if (this.holeCompleting) {
          return;
        }

        this.holeCompleting = true;

        const holeScore = ScoreKeeper.completeHole(round, hole);

        this.updateRoundProgress();

        const scoreName = ScoreKeeper.getScoreName(holeScore.scoreRelativeToPar);
        const scoreColor = ScoreKeeper.getScoreColor(holeScore.scoreRelativeToPar);

        setTimeout(() => {
          let message = `Hole ${hole.holeNumber} complete!\n`;
          message += `${scoreName}\n`;
          message += `Strokes: ${round.currentStrokeCount} (Par ${hole.par})\n`;
          message += `Total: ${ScoreKeeper.getScoreDisplay(round.scoreRelativeToPar)}`;

          if (holeScore.scoreRelativeToPar <= -1) {
            this.celebrateGoodScore(holeScore.scoreRelativeToPar);
          }

          if (round.currentHoleNumber < 9) {
            message += `\n\nMoving to hole ${round.currentHoleNumber + 1}...`;
            alert(message);
            this.advanceToNextHole();
          } else {
            round.isComplete = true;
            round.endTime = Date.now();
            alert(message);
            this.showRoundSummary();
          }
        }, 500);
      }

      // === T098: Play cheer for exceptional shots ===
      celebrateGoodScore(scoreRelativeToPar) {
        if (scoreRelativeToPar <= -2) {
          console.log('üéâ EAGLE OR BETTER! üéâ');
          AudioManager.playCheerSound();
        } else if (scoreRelativeToPar === -1) {
          console.log('üéä BIRDIE! üéä');
          AudioManager.playCheerSound();
        }
      }

      updateRoundProgress() {
        const summary = ScoreKeeper.getRoundSummary(this.gameState.round);
        const progressElement = document.getElementById('round-progress');
        const progressText = document.getElementById('progress-text');

        if (progressElement && progressText) {
          progressText.textContent = `${summary.completedHoles}/9 holes`;
          progressElement.classList.remove('hidden');
        }
      }

      advanceToNextHole() {
        const round = this.gameState.round;
        round.currentHoleNumber++;
        round.currentStrokeCount = 0;

        const canvasRect = this.canvas.getBoundingClientRect();
        const hole = CourseGenerator.generateHole(round.currentHoleNumber, canvasRect.width, canvasRect.height);

        this.gameState.currentHole = hole;
        this.gameState.ball = this.createBall(hole);

        this.updateUI();

        // Reset flag to allow next hole completion
        this.holeCompleting = false;

        StorageManager.saveGameState(this.gameState);
      }

      async showRoundSummary() {
        const round = this.gameState.round;
        const summary = ScoreKeeper.getRoundSummary(round);

        let tableHTML = '<table class="scorecard-table">';
        tableHTML += '<tr><th>Hole</th><th>Par</th><th>Strokes</th><th>Score</th></tr>';

        for (const holeScore of round.holeScores) {
          const scoreClass = this.getScoreClass(holeScore.scoreRelativeToPar);
          const scoreDisplay = ScoreKeeper.getScoreDisplay(holeScore.scoreRelativeToPar);

          tableHTML += `<tr>`;
          tableHTML += `<td>${holeScore.holeNumber}</td>`;
          tableHTML += `<td>${holeScore.par}</td>`;
          tableHTML += `<td>${holeScore.strokes}</td>`;
          tableHTML += `<td class="${scoreClass}">${scoreDisplay}</td>`;
          tableHTML += `</tr>`;
        }

        tableHTML += '</table>';
        tableHTML += `<div style="margin-top: 20px; font-size: 18px;">`;
        tableHTML += `<strong>Total Strokes:</strong> ${summary.totalStrokes}<br>`;
        tableHTML += `<strong>Total Par:</strong> ${summary.totalPar}<br>`;
        tableHTML += `<strong>Final Score:</strong> <span style="color: ${ScoreKeeper.getScoreColor(summary.scoreRelativeToPar)}; font-weight: bold; font-size: 24px;">${ScoreKeeper.getScoreDisplay(summary.scoreRelativeToPar)}</span>`;
        tableHTML += `</div>`;

        document.getElementById('scorecard-content').innerHTML = tableHTML;
        document.getElementById('scorecard-overlay').classList.remove('hidden');
        document.getElementById('menu-overlay').classList.remove('hidden');

        // === T078: Save to leaderboard ===
        await this.saveToLeaderboard(summary);

        // Reset flag for next round
        this.holeCompleting = false;

        StorageManager.clearGameState();
      }

      // === T078, T080: Save round to leaderboard (global API) ===
      async saveToLeaderboard(summary) {
        const playerName = this.gameState?.playerName || 'Player';

        try {
          // Try to save to global leaderboard API
          const response = await fetch('/api/leaderboard', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              playerName: playerName,
              scoreRelativeToPar: summary.scoreRelativeToPar,
              totalStrokes: summary.totalStrokes
            })
          });

          if (response.ok) {
            const result = await response.json();
            console.log('Score saved to global leaderboard');

            // Check if made top 3
            if (result.rank && result.rank <= 3) {
              const medals = ['ü•á', 'ü•à', 'ü•â'];
              console.log(`${medals[result.rank - 1]} NEW TOP SCORE! Rank #${result.rank}`);
            }
          } else {
            throw new Error('API response not ok');
          }
        } catch (error) {
          console.error('Failed to save to global leaderboard, saving locally:', error);
          // Fallback to local storage if API fails
          try {
            const entry = {
              scoreRelativeToPar: summary.scoreRelativeToPar,
              totalStrokes: summary.totalStrokes,
              completedAt: Date.now(),
              playerName: playerName
            };
            await StorageManager.addLeaderboardEntry(entry);
          } catch (localError) {
            console.error('Failed to save locally too:', localError);
          }
        }
      }

      // === T077, T081: Display leaderboard (global API with local fallback) ===
      static async showLeaderboard() {
        const content = document.getElementById('leaderboard-content');
        content.innerHTML = '<div class="leaderboard-empty">Loading...</div>';
        document.getElementById('leaderboard-overlay').classList.remove('hidden');

        let leaderboard = [];

        try {
          // Try to fetch from global API first
          const response = await fetch('/api/leaderboard');
          if (response.ok) {
            leaderboard = await response.json();
          } else {
            throw new Error('API response not ok');
          }
        } catch (error) {
          console.error('Failed to fetch global leaderboard, trying local:', error);
          // Fallback to local storage
          try {
            leaderboard = await StorageManager.getLeaderboard();
          } catch (localError) {
            console.error('Failed to load local leaderboard:', localError);
          }
        }

        if (!leaderboard || leaderboard.length === 0) {
          content.innerHTML = '<div class="leaderboard-empty">No scores yet. Complete a round to get on the leaderboard!</div>';
        } else {
          let tableHTML = '<table class="leaderboard-table">';
          tableHTML += '<tr><th>Rank</th><th>Player</th><th>Score</th><th>Strokes</th><th>Date</th></tr>';

          leaderboard.forEach((entry, index) => {
            const rank = index + 1;
            const rankClass = rank <= 3 ? `leaderboard-rank-${rank}` : '';
            let scoreClass = 'leaderboard-score-par';
            if (entry.scoreRelativeToPar < 0) scoreClass = 'leaderboard-score-under';
            else if (entry.scoreRelativeToPar > 0) scoreClass = 'leaderboard-score-over';

            const scoreDisplay = ScoreKeeper.getScoreDisplay(entry.scoreRelativeToPar);
            const date = new Date(entry.completedAt).toLocaleDateString();
            // Support both playerName (new) and playerInitials (old local data)
            const playerName = entry.playerName || entry.playerInitials || 'Unknown';

            tableHTML += `<tr>`;
            tableHTML += `<td class="leaderboard-rank ${rankClass}">#${rank}</td>`;
            tableHTML += `<td>${playerName}</td>`;
            tableHTML += `<td class="${scoreClass}">${scoreDisplay}</td>`;
            tableHTML += `<td>${entry.totalStrokes}</td>`;
            tableHTML += `<td>${date}</td>`;
            tableHTML += `</tr>`;
          });

          tableHTML += '</table>';
          content.innerHTML = tableHTML;
        }
      }

      getScoreClass(scoreRelativeToPar) {
        if (scoreRelativeToPar <= -2) return 'score-eagle';
        if (scoreRelativeToPar === -1) return 'score-birdie';
        if (scoreRelativeToPar === 0) return 'score-par';
        if (scoreRelativeToPar === 1) return 'score-bogey';
        return 'score-double';
      }

      updateFPS(deltaTime) {
        this.fps = Math.round(1 / deltaTime);
        if (this.debugMode) {
          const debugDiv = document.getElementById('debug-info');
          debugDiv.innerHTML = `FPS: ${this.fps}<br>Ball: (${Math.round(this.gameState.ball.x)}, ${Math.round(this.gameState.ball.y)})<br>Velocity: (${Math.round(this.gameState.ball.velocityX)}, ${Math.round(this.gameState.ball.velocityY)})<br>Moving: ${this.gameState.ball.isMoving}`;
        }
      }
    }

    // === Initialize Game (T005, T011, T012) ===
    window.addEventListener('DOMContentLoaded', async () => {
      console.log('DOM Content Loaded');

      const canvas = document.getElementById('game-canvas');
      if (!canvas) {
        console.error('Canvas element not found!');
        return;
      }

      console.log('Canvas found, initializing game engine...');

      let gameEngine;
      try {
        gameEngine = new GameEngine(canvas);
        window.gameEngine = gameEngine; // Expose for testing
        console.log('Game engine initialized successfully');
      } catch (error) {
        console.error('Error initializing game engine:', error);
        alert('Error initializing game: ' + error.message);
        return;
      }

      const newGameBtn = document.getElementById('new-game-btn');
      const resumeGameBtn = document.getElementById('resume-game-btn');

      if (!newGameBtn) {
        console.error('New game button not found!');
        return;
      }

      AudioManager.init();

      try {
        await StorageManager.init();
        const hasSavedGame = await StorageManager.hasSavedGame();

        if (hasSavedGame) {
          resumeGameBtn.classList.remove('hidden');
        } else {
          resumeGameBtn.classList.add('hidden');
        }
      } catch (error) {
        console.error('Error checking for saved game:', error);
        resumeGameBtn.classList.add('hidden');
      }

      // Name entry modal elements
      const nameEntryOverlay = document.getElementById('name-entry-overlay');
      const playerNameInput = document.getElementById('player-name-input');
      const startWithNameBtn = document.getElementById('start-with-name-btn');
      const cancelNameEntryBtn = document.getElementById('cancel-name-entry-btn');

      // Load last used name from localStorage
      const lastPlayerName = localStorage.getItem('golf-player-name') || '';
      playerNameInput.value = lastPlayerName;

      newGameBtn.addEventListener('click', () => {
        console.log('New Game button clicked');
        AudioManager.unlock();
        // Show name entry modal instead of starting immediately
        nameEntryOverlay.classList.remove('hidden');
        playerNameInput.focus();
        playerNameInput.select();
      });

      // Handle starting game with name
      const startGameWithName = async () => {
        const playerName = playerNameInput.value.trim() || 'Player';
        console.log('Starting game with player:', playerName);

        // Save name for next time
        localStorage.setItem('golf-player-name', playerName);

        // Hide name entry modal
        nameEntryOverlay.classList.add('hidden');

        try {
          await gameEngine.startNewRound(null, playerName);
          gameEngine.start();
          resumeGameBtn.classList.add('hidden');
          console.log('Game started successfully');
        } catch (error) {
          console.error('Error starting game:', error);
          alert('Error starting game: ' + error.message);
        }
      };

      startWithNameBtn.addEventListener('click', startGameWithName);

      // Allow Enter key to start game
      playerNameInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
          startGameWithName();
        }
      });

      // Cancel button
      cancelNameEntryBtn.addEventListener('click', () => {
        nameEntryOverlay.classList.add('hidden');
      });

      resumeGameBtn.addEventListener('click', async () => {
        console.log('Resume Game button clicked');
        try {
          const loaded = await gameEngine.loadRound();
          if (loaded) {
            gameEngine.start();
            console.log('Game resumed successfully');
          } else {
            alert('Failed to load saved game');
            resumeGameBtn.classList.add('hidden');
          }
        } catch (error) {
          console.error('Error resuming game:', error);
          alert('Error resuming game: ' + error.message);
        }
      });

      // === T081: Leaderboard button handler ===
      const leaderboardBtn = document.getElementById('leaderboard-btn');
      if (leaderboardBtn) {
        leaderboardBtn.addEventListener('click', async () => {
          console.log('Leaderboard button clicked');
          await GameEngine.showLeaderboard();
        });
      }

      // Club selector toggle button handler
      const clubToggleBtn = document.getElementById('club-toggle-btn');
      const clubSelector = document.getElementById('club-selector');
      if (clubToggleBtn && clubSelector) {
        clubToggleBtn.addEventListener('click', () => {
          clubSelector.classList.toggle('minimized');
          clubToggleBtn.textContent = clubSelector.classList.contains('minimized') ? 'Show Clubs' : 'Hide Clubs';
        });
      }

      console.log('Howlett Golf Chaos - Ready!');
    });
  </script>
</body>
</html>
